
# DSB蛋白数据标准化 ============================================================
# ==============================================================================

dsb_norm <- function(raw = raw,
                     cells = cells,
                     isotype = isotype) {
  library(dsb)
  
  # define cell-containing barcodes and separate cells and empty drops
  
  stained_cells = colnames(cells$`Gene Expression`)
  background = setdiff(colnames(raw$`Gene Expression`), stained_cells)
  
  # split the data into separate matrices for RNA and ADT
  
  prot = raw$`Antibody Capture`
  rna = raw$`Gene Expression`
  
  # create metadata of droplet QC stats used in standard scRNAseq processing
  
  mtgene = grep(pattern = "^MT-", rownames(rna), value = TRUE) # used below
  
  md = data.frame(
    rna.size = log10(Matrix::colSums(rna)), 
    prot.size = log10(Matrix::colSums(prot)), 
    n.gene = Matrix::colSums(rna > 0), 
    mt.prop = Matrix::colSums(rna[mtgene, ]) / Matrix::colSums(rna))
  
  # add indicator for barcodes Cell Ranger called as cells
  
  md$drop.class = ifelse(rownames(md) %in% stained_cells, 'cell', 'background')
  
  # remove barcodes with no evidence of capture in the experiment
  
  md = md[md$rna.size > 0 & md$prot.size > 0, ]
  
  ggplot(md, aes(x = log10(n.gene), y = prot.size )) +
    theme_bw() + 
    geom_bin2d(bins = 300) + 
    scale_fill_viridis_c(option = "C") + 
    facet_wrap(~drop.class)
  
  background_drops = rownames(
    md[ md$prot.size > 1.5 & 
          md$prot.size < 3 & 
          md$rna.size < 2.5, ])
  
  background.adt.mtx = as.matrix(prot[ , background_drops])
  
  # calculate statistical thresholds for droplet filtering.
  
  cellmd = md[md$drop.class == 'cell', ]
  
  # filter drops with + / - 3 median absolute deviations from the median library size
  
  rna.mult = (3*mad(cellmd$rna.size))
  prot.mult = (3*mad(cellmd$prot.size))
  rna.lower = median(cellmd$rna.size) - rna.mult
  rna.upper = median(cellmd$rna.size) + rna.mult
  prot.lower = median(cellmd$prot.size) - prot.mult
  prot.upper = median(cellmd$prot.size) + prot.mult
  
  # filter rows based on droplet qualty control metrics
  
  qc_cells = rownames(
    cellmd[cellmd$prot.size > prot.lower & 
             cellmd$prot.size < prot.upper & 
             cellmd$rna.size > rna.lower & 
             cellmd$rna.size < rna.upper & 
             cellmd$mt.prop < 0.14, ])
  
  # subset the metadata ADT and RNA matrices
  
  cell.adt.raw = as.matrix(prot[ , qc_cells])
  cell.rna.raw = rna[ ,qc_cells]
  cellmd = cellmd[qc_cells, ]
  
  # normalize and denoise with dsb with 
  
  DSBNormalizeProtein(cell_protein_matrix = cell.adt.raw, 
                      empty_drop_matrix = background.adt.mtx, 
                      denoise.counts = TRUE, 
                      use.isotype.control = TRUE, 
                      isotype.control.name.vec = isotype,
                      quantile.clipping = TRUE,
                      quantile.clip = c(0.01, 0.99))
}



# umap图可视化 =================================================================
# ==============================================================================

# dimplot ====================

dimplot_new <- function(data = datafilt,
                        reduction = "umap",
                        pt.size = 1, label = T,
                        group.by = c("seurat_clusters")) {
  
  library(Seurat)
  
  # 设定颜色
  
  info <- data@meta.data
  number <- length(unique(info[,group.by]))
  
  if (number < 17) {
    col <- c("#A6D719", "#176EBF", "#00A8DE", "#AEE0E8",
             "#00A9A3", "#FBD324", "#F28A24", "#A52828",
             "#A37CB7", "#F2D7EE", "#CD6981", "#FBD0C0",
             "#F15E4C", "#ECB2C8", "#B2DBBF", "#CCDAD1")
  } else {
    col <- c("#B8E3EA", "#5CB3DA", "#0070B2", "#FBDD7E", "#F7AE24", "#FF7149", 
             "#F2D7EE", "#A37CB7", "#A231A1", "#ECB2C8", "#E93B8C", "#B91372", 
             "#FF9F99", "#F15E4C", "#DA1735", "#CDE391", "#8BBE53", "#679436", 
             "#98D4C6", "#00A385", "#067D69", "#B2DBBF", "#028090", "#114B5F", 
             "#FBD0C0", "#CD6981", "#A23E48", "#CCDAD1", "#9CAEA9", "#788585")
    col <- colorRampPalette(col)(number)
  }
  
  # 开始画图
  
  DimPlot(data, pt.size = pt.size, label = label, repel = T, 
          raster = FALSE, label.size = 5, reduction = reduction,
          group.by = group.by) + 
    scale_color_manual(values = c(col)) + 
    
    theme_bw() +
    theme(panel.grid = element_blank(), # 删去网格线
          axis.ticks = element_blank(), # 删去刻度线
          axis.text = element_blank(), # 删去刻度标签
          axis.title = element_text(colour = "black", size = 15),
          legend.text = element_text(size = 15),
          panel.border = element_rect(fill = NA, color = "black", linewidth = 1)) +   
    
    labs(x = 'UMAP1',y= 'UMAP2',title = '') + 
    guides(colour = guide_legend(title = NULL,
                                 override.aes = list(size = 7.5)))
}


# featureplot ====================

featureplot_new <- function(data = datafilt,
                            reduction = "umap",
                            pt.size = 1, 
                            color = "parula",
                            features = select,
                            raster = NULL,
                            outlier.rm = F) {
  library(Seurat)
  
  # 设定颜色
  
  if (color == "parula") {
    col <- colorRampPalette(c("#352A87","#343EB1","#1558D9","#036CE0","#107AD9",
                              "#1387D3","#0997D1","#06A4C9","#0CADBB","#23B4A9",
                              "#43BB97","#6ABE83","#8FBF73","#AEBD66","#CBBB5B",
                              "#E6B94F","#FDBE3C","#FBCF2C","#F5E21E","#F9FB0E"))(100)
    
  } else if (color == "kovesi") {
    col <- colorRampPalette(c("#1B0084","#1B099A","#1C14AE","#1C20C0","#1F2DCE",
                              "#233DD6","#2950CE","#2E68AB","#377989","#3F876A",
                              "#46954D","#53A036","#65AB26","#7BB41A","#95BE16",
                              "#AFC61C","#C6CE26","#DAD636","#EAE04E","#F1EC74",
                              "#F8F7AF","#FFFFFF"))(100)
    
  } else if (color == "ocean.haline") {
    col <- colorRampPalette(c("#2A186C","#2E1B87","#2B229F","#1D35A1","#11459A",
                              "#0C5294","#115D8F","#19678C","#22718A","#2B7A89",
                              "#328388","#388D88","#3E9886","#44A284","#4CAC80",
                              "#55B67A","#62BF72","#73C869","#8AD060","#A4D75C",
                              "#BEDC62","#D5E171","#EAE784","#FDEF9A"))(100)
    
  } else if (color == "ocean.dense") {
    col <- colorRampPalette(c("#360E24","#5D1A58","#723692","#795CC3",
                              "#7487E0", "#7EB0E4","#AAD2E3","#E6F1F1"))(100)
    
  } else if (color == "magma") {
    col <- c(colorRampPalette(c(magma(323, begin = 0.15)[1]))(10),
             magma(323, begin = 0.18))
    
  } else if (color == "white2blue") {
    col <- colorRampPalette(c("#FBF4F8","#E5E0ED","#BFC6DD","#8CADCC",
                              "#4E92BA","#1871A8","#085889","#003758"))(100)
    
  } else if (color == "blue2red") {
    col <- colorRampPalette(c("#0070b2","#009bc7","#5ec7dd",
                              "#b8e3ea","#f3f3f1","#fccdb9",
                              "#f79676","#f15e4c","#da1735"))(100)
    
  } else if (color == "rainbow") {
    col <- colorRampPalette(c("#343391","#0064af","#0090cc","#00b6db","#01b7c2",
                              "#53c0a3","#8dcb8a","#bbd967","#fbd324","#f6bd25",
                              "#f4a02e","#ed6f32","#ea5c2e","#d5452f","#c02e2f",
                              "#8b2a21"))(100)
  }
  
  # 开始画图
  
  if (length(features) > 1) {
    
    lapply(features, function(i){
      
      if (outlier.rm == T) {
        input <- data@meta.data[,i]
        thres <- quantile(input, probs = c(0.05, 0.95))
        input[input < thres[1]] <- thres[1]
        input[input > thres[2]] <- thres[2]
        data@meta.data[,i] <- input}
      
      FeaturePlot(data, features = i, cols = col,
                  reduction = reduction, ncol = 1,
                  pt.size = pt.size, label = F, order = T, raster = raster) + 
        theme_bw() +
        theme(panel.grid = element_blank(), # 删去网格线
              axis.ticks = element_blank(), # 删去刻度线
              axis.text = element_blank(), # 删去刻度标签
              axis.title = element_text(colour = "black", size = 15),
              plot.title = element_text(size = 17),
              panel.border = element_rect(fill = NA, color = "black", linewidth = 1),
              legend.position = "none") +
        
        labs(x = 'UMAP1', y = 'UMAP2', title = i)
    })
    
  } else {
    
    if (outlier.rm == T) {
      input <- data@meta.data[,features]
      thres <- quantile(input, probs = c(0.05, 0.95))
      input[input < thres[1]] <- thres[1]
      input[input > thres[2]] <- thres[2]
      data@meta.data[,features] <- input}
    
    FeaturePlot(data, features = features, cols = col,
                reduction = reduction, ncol = 1,
                pt.size = pt.size, label = F, order = T, raster = raster) + 
      theme_bw() +
      theme(panel.grid = element_blank(), # 删去网格线
            axis.ticks = element_blank(), # 删去刻度线
            axis.text = element_blank(), # 删去刻度标签
            axis.title = element_text(colour = "black", size = 15),
            plot.title = element_text(size = 17),
            panel.border = element_rect(fill = NA, color = "black", linewidth = 1),
            legend.position = "none") +
      
      labs(x = 'UMAP1', y = 'UMAP2')
  }
}


# 导dimplot中的figure ====================

export_dimplot <- function(all_plots = all_plots,
                               ncol = 3, dpi = 300,
                               output = name) {
  
  library(cowplot)
  
  if (ncol == 2) {
    
    height = round(length(all_plots)/2 + 0.3, 0) * 5
    all_plots <- plot_grid(plotlist = all_plots, ncol = 2)
    
    ggsave(output, all_plots, dpi = dpi,
           width = 12, height = height, limitsize = FALSE)
    
  } else if (ncol == 3) {
    
    height = round(length(all_plots)/3 + 0.3, 0) * 5
    all_plots <- plot_grid(plotlist = all_plots, ncol = 3)
    
    ggsave(output, all_plots, dpi = dpi,
           width = 17.5, height = height, limitsize = FALSE)
    
  } else if (ncol == 5) {
    
    height = round(length(all_plots)/5 + 0.3, 0) * 5
    all_plots <- plot_grid(plotlist = all_plots, ncol = 5)
    
    ggsave(output, all_plots, dpi = dpi,
           width = 27.5, height = height, limitsize = FALSE)
  }
}


# 导出featureplot中的figure ====================

export_featureplot <- function(all_plots = all_plots,
                               ncol = 3, dpi = 300,
                               output = name) {
  
  library(cowplot)
  
  if (ncol == 2) {
    
    height = round(length(all_plots)/2 + 0.35, 0) * 5
    all_plots <- plot_grid(plotlist = all_plots, ncol = 2)
    
    ggsave(output, all_plots, dpi = dpi,
           width = 10, height = height, limitsize = FALSE)
    
  } else if (ncol == 3) {
    
    height = round(length(all_plots)/3 + 0.35, 0) * 5
    all_plots <- plot_grid(plotlist = all_plots, ncol = 3)
    
    ggsave(output, all_plots, dpi = dpi,
           width = 15, height = height, limitsize = FALSE)
    
  } else if (ncol == 5) {
    
    height = round(length(all_plots)/5 + 0.35, 0) * 5
    all_plots <- plot_grid(plotlist = all_plots, ncol = 5)
    
    ggsave(output, all_plots, dpi = dpi,
           width = 25, height = height, limitsize = FALSE)
  }
}



# 质控函数 =====================================================================
# ==============================================================================

# 表达数据画质控图 ====================

qc_plot <- function(data = data) {
  
  counts <- GetAssayData(object = data, slot = "counts")
  
  # 计算线粒体基因reads的比例
  
  mt.genes <- grep(pattern = "^MT-", x = rownames(data), value = TRUE)
  data$percent_mito <- colSums(counts[mt.genes,])/Matrix::colSums(counts)*100
  
  #计算核糖体基因reads的比例
  
  rb.genes <- grep(pattern = "^RP([0-9]+-|[LS])", x = rownames(data), value = TRUE)
  data$percent_ribo <- colSums(counts[rb.genes,])/Matrix::colSums(counts)*100
  
  # 结果可视化
  
  par(mfrow=c(2,2))
  
  hist(data$nFeature_RNA,breaks=100,prob=TRUE)
  hist(data$nCount_RNA,breaks=100,prob=TRUE)
  
  hist(data$percent_mito,breaks=100,prob=TRUE)
  hist(data$percent_ribo,breaks=100,prob=TRUE)
}


# 过滤函数 ====================

qc_filter <- function(data = data, 
                      nFeature_dn = 500,
                      nFeature_up = 5000,
                      nCount_dn = 5000,
                      nCount_up = 50000,
                      mito_up = 20,
                      ribo_dn = 5,
                      ribo_up = 50,
                      gene_filter = 3,
                      species = "human") {
  library(Seurat)
  counts <- GetAssayData(object = data, slot = "counts")
  
  # 计算线粒体和核糖体比例
  
  if (species == "human") {
    
    mt.genes <- grep(pattern = "^MT-", x = rownames(data), value = TRUE)
    rb.genes <- grep(pattern = "^RP[SL]", x = rownames(data), value = TRUE)
    
  } else if (species == "mouse") {
    
    mt.genes <- grep(pattern = "^mt-", x = rownames(data), value = TRUE)
    rb.genes <- grep(pattern = "^Rp[sl]", x = rownames(data), value = TRUE)
    
  }
  
  data$percent_mito <- colSums(counts[mt.genes,])/Matrix::colSums(counts)*100
  data$percent_ribo <- colSums(counts[rb.genes,])/Matrix::colSums(counts)*100
  
  # 排除表达基因的数量少于500或大于5000的细胞
  
  filter_cell <- colnames(data)[data$nFeature_RNA > nFeature_dn &
                                  data$nFeature_RNA < nFeature_up &
                                  data$nCount_RNA > nCount_dn &
                                  data$nCount_RNA < nCount_up &
                                  data$percent_mito < mito_up &
                                  data$percent_ribo > ribo_dn &
                                  data$percent_ribo < ribo_up]
  
  # 排除在少于等于3个细胞中表达的基因
  
  filter_gene <- rownames(data)[rowSums(counts != 0) > gene_filter]
  
  # 得到过滤后数据
  
  data[filter_gene, filter_cell]
}


# 蛋白分布质控图 ====================

protein_distribution <- function(data = data,
                                 dsb.norm = FALSE,
                                 thres = 3.5) {
  
  # 标准化数据
  
  if (dsb.norm == FALSE) {
    data <- NormalizeData(data, margin = 2,
                          normalization.method = "CLR")}
  
  # 提取数据
  
  input <- t(as.matrix(GetAssayData(data, slot = "data", assay = "RNA")))
  input <- input[,order(colnames(input))]
  
  # 开始画图
  
  all_plots <- lapply(colnames(input), function(i){
    
    dense <- data.frame(density(input[,i], n = 500)[c('x','y')])
    dense$type <- NA
    dense$type[dense$x <= thres] <- "L"
    dense$type[dense$x > thres] <- "H"
    
    ggplot(dense, aes(x = x, y = y)) +
      geom_bar(aes(fill = type), stat = 'identity') + 
      scale_fill_manual(values=c("L" = "grey90",
                                 "H" = "#0070b2")) + 
      theme_bw() + 
      theme(panel.grid = element_blank(),
            axis.text = element_text(colour = "black", size = 15),
            axis.title = element_blank(),
            panel.border = element_rect(fill = NA, color = "black", linewidth = 1),
            legend.position = "none") + 
      geom_vline(aes(xintercept = thres), linetype = "solid") + 
      xlim(0, 20) + ggtitle(i)
  })
}



# 去除doublets =================================================================
# ==============================================================================

# 前置函数 ====================

autocluster <- function(datafilt, nfeatures = 1000, ndim = 15,
                        neigh = 20, dist = 0.5, res = 0.5){
  
  library(Seurat)
  
  # 测序深度标准化
  
  datafilt <- NormalizeData(datafilt, scale.factor = 10000,
                            normalization.method = "LogNormalize")
  
  # 寻找变异度高的基因
  
  datafilt <- FindVariableFeatures(datafilt, nfeatures = nfeatures, 
                                   selection.method = "vst")
  
  # scale标准化
  
  datafilt <- ScaleData(datafilt, features = VariableFeatures(datafilt))
  
  # PCA分析
  
  datafilt <- RunPCA(datafilt, assay = 'RNA', slot = 'scale.data')
  
  
  # 细胞分群 ------------------------------
  
  datafilt <- FindNeighbors(datafilt, k.param = neigh,
                            dims = 1:ndim, reduction = "pca")
  
  datafilt <- FindClusters(datafilt, resolution = res, n.iter = 50)
  
  
  # 重新降维 ----------
  
  # min.dist这个值对聚类形状影响很大 (大一点形状更好看)
  
  datafilt <- RunUMAP(datafilt, dims = 1:ndim,
                      n.neighbors = neigh, min.dist = dist, 
                      reduction = "pca", reduction.name = "umap")
  
  return(datafilt)
}


# 正式运行函数 ====================

doublet_rm <- function(datafilt = datafilt,
                       prop_doublet = 0.075) {
  
  library(DoubletFinder)
  library(Seurat)
  library(dplyr)
  
  datafilt <- autocluster(datafilt, nfeatures = 2000, ndim = 15,
                          neigh = 20, dist = 0.5, res = 0.5)
  
  # 寻找最优pK值
  
  sweep.res.list <- paramSweep_v3(datafilt, PCs = 1:20)
  sweep.stats <- summarizeSweep(sweep.res.list, GT = FALSE)  
  bcmvn <- find.pK(sweep.stats)
  
  pK_bcmvn <- bcmvn$pK[which.max(bcmvn$BCmetric)] %>%
    as.character() %>% as.numeric()
  
  # 排除不能检出的同源doublets，优化期望的doublets数量
  
  homotypic.prop <- modelHomotypic(datafilt$seurat_clusters)
  
  nExp_poi <- round(prop_doublet*ncol(datafilt)) 
  nExp_poi.adj <- round(nExp_poi*(1-homotypic.prop))
  
  # 使用确定好的参数鉴定doublets
  
  datafilt <- doubletFinder_v3(datafilt, PCs = 1:20, pN = 0.25,
                               pK = pK_bcmvn, reuse.pANN = F,
                               nExp = nExp_poi.adj)
  
  names(datafilt@meta.data) <- gsub("DF.classifications.*",
                                    "DF.classifications",
                                    colnames(datafilt@meta.data))
  
  infodata <- data.frame(id = rownames(datafilt@meta.data),
                         DFclass = datafilt@meta.data[["DF.classifications"]])
  
  # 将结果整合到seurat对象
  
  rownames(infodata) <- NULL
  infodata <- column_to_rownames(infodata, var = "id")
  datafilt <- AddMetaData(datafilt, infodata)
  
  # 排除doublet
  
  datafilt <- datafilt[,datafilt$DFclass == "Singlet"]
}



# 自动聚类函数 =================================================================
# ==============================================================================

# 表达数据聚类 ====================

autocluster_exp <- function(datafilt, nfeatures = 1000, ndim = 15,
                            neigh = 20, dist = 0.5, res = 0.5){
  
  # 测序深度标准化
  
  datafilt <- NormalizeData(datafilt, scale.factor = 10000,
                            normalization.method = "LogNormalize")
  
  # 寻找变异度高的基因
  
  datafilt <- FindVariableFeatures(datafilt, nfeatures = nfeatures, 
                                   selection.method = "vst")
  
  # scale标准化
  
  datafilt <- ScaleData(datafilt, features = VariableFeatures(datafilt))
  
  # PCA分析
  
  datafilt <- RunPCA(datafilt, assay = 'RNA', slot = 'scale.data')
  
  
  # 细胞分群 ------------------------------
  
  datafilt <- FindNeighbors(datafilt, k.param = neigh,
                            dims = 1:ndim, reduction = "pca")
  
  datafilt <- FindClusters(datafilt, resolution = res, n.iter = 50)
  
  
  # 重新降维 ----------
  
  # min.dist这个值对聚类形状影响很大 (大一点形状更好看)
  
  datafilt <- RunUMAP(datafilt, dims = 1:ndim,
                      n.neighbors = neigh, min.dist = dist, 
                      reduction = "pca", reduction.name = "umap")
  
  return(datafilt)
}


# 蛋白数据聚类 ====================

autocluster_pro <- function(datafilt, ndim = 5, features = select,
                            neigh = 20, dist = 0.5, res = 0.5,
                            dsb.norm = TRUE){
  
  # 测序深度标准化
  
  if (dsb.norm == FALSE) {
    datafilt <- NormalizeData(datafilt, margin = 2,
                              normalization.method = "CLR")}
  
  # scale标准化
  
  datafilt <- ScaleData(datafilt, features = features)
  
  # PCA分析
  
  datafilt <- RunPCA(datafilt, features = features,
                     assay = 'RNA', slot = 'scale.data')
  
  # 细胞分群
  
  datafilt <- FindNeighbors(datafilt, k.param = neigh,
                            dims = 1:ndim, reduction = "pca")
  
  datafilt <- FindClusters(datafilt, resolution = res, n.iter = 50)
  
  # 重新降维
  
  datafilt <- RunUMAP(datafilt, dims = 1:ndim,
                      n.neighbors = neigh, min.dist = dist, 
                      reduction = "pca", reduction.name = "umap")
  
  return(datafilt)
}



# 矩阵二分类化函数 =============================================================
# ==============================================================================

# datafilt是一个seurat对象 ====================

exp_dicho <- function(datafilt, select = select){
  
  # 提取数据
  
  subfilt <- datafilt[select,]
  exp <- t(as.matrix(GetAssayData(subfilt, slot = "data", assay = "RNA")))
  exp <- as.matrix(exp)
  
  # 开始循环
  
  dicho <- do.call(cbind, lapply(1:ncol(exp), function(q){
    
    # 计算密度
    
    den <- density(exp[,q])
    den_diff <- diff(den$y, bw = 0.05)
    
    # 确定阈值
    
    thres <- which(den_diff[-1] * den_diff[-length(den_diff)] < 0) + 1
    thres <- den$x[thres[2]]
    
    data.frame(ifelse(exp[,q] > thres, 1, 0))
  }))
  
  # 整理结果
  
  colnames(dicho) <- colnames(exp)
  
  # 将NA设为0
  
  dicho[is.na(dicho)] <- 0
  return(dicho)
}


# 输入数据是矩阵的函数 ====================

common_dicho <- function(data = data, select = select){
  
  # 开始循环
  
  dicho <- do.call(cbind, lapply(1:ncol(data), function(q){
    
    # 计算密度
    
    den <- density(data[,q])
    den_diff <- diff(den$y, bw = 0.05)
    
    # 确定阈值
    
    thres <- which(den_diff[-1] * den_diff[-length(den_diff)] < 0) + 1
    thres <- den$x[thres[2]]
    
    data.frame(ifelse(data[,q] > thres, 1, 0))
  }))
  
  # 整理结果
  
  colnames(dicho) <- colnames(data)
  
  # 将NA设为0
  
  dicho[is.na(dicho)] <- 0
  return(dicho)
}



# 计算亚型特异性feature ========================================================
# ==============================================================================

# 基于RSS计算 ====================

rss_protein <- function(datafilt = datafilt,
                        group.by = "cluster_wnn",
                        select.gene = select) {
  
  library(philentropy)
  library(pbapply)
  library(caret)
  
  # 预处理亚群数据
  
  info <- datafilt@meta.data
  cl_mat <- data.frame(id = rownames(info),
                       value = 1, cluster = info[,group.by])
  
  cl_mat <- acast(cl_mat, id ~ cluster,
                  value.var = "value", fun.aggregate = mean)
  cl_mat[cl_mat == "NaN"] <- 0
  
  # 预处理signature分数
  
  sig_mat <- t(as.matrix(GetAssayData(datafilt, slot = "data", assay = "RNA")))
  sig_mat <- sig_mat[,select.gene]
  
  preprocess <- preProcess(sig_mat, method=c("range"))
  sig_mat <- predict(preprocess, sig_mat)
  
  # 计算JSD
  
  jsd <- pblapply(colnames(sig_mat), function(i) {
    sapply(colnames(cl_mat), function(j) {
      
      1 - JSD(rbind(sig_mat[,i], cl_mat[,j]),
              unit = 'log2', est.prob = "empirical")
    })
  })
  
  jsd <- do.call(rbind, jsd)
  rownames(jsd) <- colnames(sig_mat)
  colnames(jsd) <- colnames(cl_mat)
  jsd
}


# 基于logFC计算 ====================

# 前置函数 ----------

diffanalysis_yc <- function(data = data, info = info,
                            group1 = "R", group2 = "NR",
                            ncore = 10){
  
  # 计算差异基因
  
  diff <- do.call(rbind, lapply(1:nrow(data), function(i){
    
    input <- data.frame(id = colnames(data), value = data[i,])
    input <- merge(input, info, by = "id")
    input <- na.omit(input)
    
    com <- wilcox.test(value ~ type, data = input)
    statp <- com$p.value
    
    fcvalue <- mean(input$value[input$type == group1]) - 
      mean(input$value[input$type == group2])
    
    data.frame(id = rownames(data)[i],
               logfc = fcvalue, pvalue = statp)
    
  }))
  
  # 矫正P值
  
  diff$FDR <- p.adjust(diff$pvalue, method = "fdr")
  return(diff)
}


# 正式函数 ----------

logfc_protein <- function(datafilt = datafilt,
                          group.by = "cluster_wnn",
                          select.gene = select) {
  library(reshape2)
  library(gtools)
  
  # 预处理亚群数据
  
  info <- datafilt@meta.data
  info <- data.frame(id = rownames(info),
                     type = info[,group.by])
  info$type <- as.character(info$type)
  
  # 预处理signature分数
  
  sig_mat <- as.matrix(GetAssayData(datafilt, slot = "data", assay = "RNA"))
  sig_mat <- sig_mat[select.gene,]
  
  # 计算差异基因
  
  all_diff <- do.call(rbind, lapply(unique(info$type), function(i){
    
    # 整理数据
    
    subinfo <- info
    subinfo$type <- ifelse(subinfo$type == i, "H", "L")
    
    # 差异分析
    
    result <- diffanalysis_yc(data = sig_mat, info = subinfo,
                              group1 = "H", group2 = "L")
    result$cluster <- i
    result
  }))
  
  matfc <- acast(all_diff, id ~ cluster, value.var = "logfc",
                 fun.aggregate = mean, na.rm = TRUE)
  matfc <- matfc[,mixedsort(colnames(matfc))]
  matfc
}



# 热图可视化 ===================================================================
# ==============================================================================

# 可视化相关性分析结果 ====================

heatmap_text <- function(input = input,
                         color = "blue2red",
                         order_name = T,
                         cutoff = 0.2,
                         col_rot = 45,
                         cluster_row = T,
                         cluster_col = T,
                         outlier.rm = T) {
  
  library(ComplexHeatmap)
  library(circlize)
  library(gtools)
  
  # 确保输入的是矩阵
  
  input <- as.matrix(input)
  
  # 设定颜色
  
  if (color == "parula") {
    col <- colorRampPalette(c("#352A87","#343EB1","#1558D9","#036CE0","#107AD9",
                              "#1387D3","#0997D1","#06A4C9","#0CADBB","#23B4A9",
                              "#43BB97","#6ABE83","#8FBF73","#AEBD66","#CBBB5B",
                              "#E6B94F","#FDBE3C","#FBCF2C","#F5E21E","#F9FB0E"))(100)
    
  } else if (color == "kovesi") {
    col <- colorRampPalette(c("#1B0084","#1B099A","#1C14AE","#1C20C0","#1F2DCE",
                              "#233DD6","#2950CE","#2E68AB","#377989","#3F876A",
                              "#46954D","#53A036","#65AB26","#7BB41A","#95BE16",
                              "#AFC61C","#C6CE26","#DAD636","#EAE04E","#F1EC74",
                              "#F8F7AF","#FFFFFF"))(100)
    
  } else if (color == "ocean.haline") {
    col <- colorRampPalette(c("#2A186C","#2E1B87","#2B229F","#1D35A1","#11459A",
                              "#0C5294","#115D8F","#19678C","#22718A","#2B7A89",
                              "#328388","#388D88","#3E9886","#44A284","#4CAC80",
                              "#55B67A","#62BF72","#73C869","#8AD060","#A4D75C",
                              "#BEDC62","#D5E171","#EAE784","#FDEF9A"))(100)
    
  } else if (color == "ocean.dense") {
    col <- colorRampPalette(c("#360E24","#5D1A58","#723692","#795CC3",
                              "#7487E0", "#7EB0E4","#AAD2E3","#E6F1F1"))(100)
    
  } else if (color == "magma") {
    col <- c(colorRampPalette(c(magma(323, begin = 0.15)[1]))(10),
             magma(323, begin = 0.18))
    
  } else if (color == "white2blue") {
    col <- colorRampPalette(c("#FBF4F8","#E5E0ED","#BFC6DD","#8CADCC",
                              "#4E92BA","#1871A8","#085889","#003758"))(100)
    
  } else if (color == "blue2red") {
    col <- colorRampPalette(c("#0070b2","#009bc7","#5ec7dd",
                              "#b8e3ea","#f3f3f1","#fccdb9",
                              "#f79676","#f15e4c","#da1735"))(100)
    
  } else if (color == "rainbow") {
    col <- colorRampPalette(c("#343391","#0064af","#0090cc","#00b6db","#01b7c2",
                              "#53c0a3","#8dcb8a","#bbd967","#fbd324","#f6bd25",
                              "#f4a02e","#ed6f32","#ea5c2e","#d5452f","#c02e2f",
                              "#8b2a21"))(100)
  }
  
  # 计算四分位值从而确定颜色范围
  
  if (outlier.rm == T) {
    all_value <- reshape2::melt(input)
    thres <- quantile(all_value$value, probs = c(0.01, 0.99))
    col <- colorRamp2(seq(from = thres[1], to = thres[2],
                          length.out = length(col)), col)}
  
  # 排序处理
  
  if (order_name == T) {
    input <- input[mixedsort(rownames(input)),]
    input <- input[,mixedsort(colnames(input))]
  } else {
    input <- input
  }
  
  # 画热图
  
  draw(Heatmap(input, col = col, 
               name = "Z-score", 
               show_row_names = T, 
               show_column_names = T, 
               column_names_rot = col_rot, 
               
               cluster_rows = cluster_row, show_row_dend = F,
               cluster_columns = cluster_col, show_column_dend = F, 
               rect_gp = gpar(col = "white", lwd = 0.75), 
               
               cell_fun = function(j, i, x, y, width, height, fill) {
                 if(input[i, j] > cutoff)
                   grid.text(round(input, 2)[i, j], x, y, gp = gpar(fontsize = 10))
               },
               heatmap_legend_param = list(
                 legend_direction = "horizontal", 
                 legend_width = unit(6, "cm"))),
       heatmap_legend_side = "bottom")
}


# 可视化相关性分析结果2 ====================

heatmap_text.perb <- function(input = input,
                              order_name = T,
                              color = "blue2red",
                              cutoff = 0.2,
                              col_rot = 45,
                              cluster_row = T,
                              cluster_col = T,
                              outlier.rm = T) {
  
  library(ComplexHeatmap)
  library(circlize)
  library(gtools)
  
  # 确保输入的是矩阵
  
  input <- as.matrix(input)
  
  # 设定颜色
  
  if (color == "parula") {
    col <- colorRampPalette(c("#352A87","#343EB1","#1558D9","#036CE0","#107AD9",
                              "#1387D3","#0997D1","#06A4C9","#0CADBB","#23B4A9",
                              "#43BB97","#6ABE83","#8FBF73","#AEBD66","#CBBB5B",
                              "#E6B94F","#FDBE3C","#FBCF2C","#F5E21E","#F9FB0E"))(100)
    
  } else if (color == "kovesi") {
    col <- colorRampPalette(c("#1B0084","#1B099A","#1C14AE","#1C20C0","#1F2DCE",
                              "#233DD6","#2950CE","#2E68AB","#377989","#3F876A",
                              "#46954D","#53A036","#65AB26","#7BB41A","#95BE16",
                              "#AFC61C","#C6CE26","#DAD636","#EAE04E","#F1EC74",
                              "#F8F7AF","#FFFFFF"))(100)
    
  } else if (color == "ocean.haline") {
    col <- colorRampPalette(c("#2A186C","#2E1B87","#2B229F","#1D35A1","#11459A",
                              "#0C5294","#115D8F","#19678C","#22718A","#2B7A89",
                              "#328388","#388D88","#3E9886","#44A284","#4CAC80",
                              "#55B67A","#62BF72","#73C869","#8AD060","#A4D75C",
                              "#BEDC62","#D5E171","#EAE784","#FDEF9A"))(100)
    
  } else if (color == "ocean.dense") {
    col <- colorRampPalette(c("#360E24","#5D1A58","#723692","#795CC3",
                              "#7487E0", "#7EB0E4","#AAD2E3","#E6F1F1"))(100)
    
  } else if (color == "magma") {
    col <- c(colorRampPalette(c(magma(323, begin = 0.15)[1]))(10),
             magma(323, begin = 0.18))
    
  } else if (color == "white2blue") {
    col <- colorRampPalette(c("#FBF4F8","#E5E0ED","#BFC6DD","#8CADCC",
                              "#4E92BA","#1871A8","#085889","#003758"))(100)
    
  } else if (color == "blue2red") {
    col <- colorRampPalette(c("#0070b2","#009bc7","#5ec7dd",
                              "#b8e3ea","#f3f3f1","#fccdb9",
                              "#f79676","#f15e4c","#da1735"))(100)
    
  } else if (color == "rainbow") {
    col <- colorRampPalette(c("#343391","#0064af","#0090cc","#00b6db","#01b7c2",
                              "#53c0a3","#8dcb8a","#bbd967","#fbd324","#f6bd25",
                              "#f4a02e","#ed6f32","#ea5c2e","#d5452f","#c02e2f",
                              "#8b2a21"))(100)
  }
  
  # 计算四分位值从而确定颜色范围
  
  if (outlier.rm == T) {
    all_value <- reshape2::melt(input)
    thres <- quantile(all_value$value, na.rm = T, probs = c(0.05, 0.95))
    col <- colorRamp2(seq(from = thres[1], to = thres[2],
                          length.out = length(col)), col)}
  
  # 排序处理
  
  if (order_name == T) {
    input <- input[mixedsort(rownames(input)),]
    input <- input[,mixedsort(colnames(input))]
  } else {
    input <- input
  }
  
  # 画热图
  
  draw(Heatmap(input, col = col, 
               name = "Z-score",
               show_row_names = T, 
               show_column_names = T, 
               column_names_rot = col_rot,
               
               cluster_rows = cluster_row, show_row_dend = F,
               cluster_columns = cluster_col, show_column_dend = F, 
               
               cell_fun = function(j, i, x, y, width, height, fill) {
                 if(input[i, j] > cutoff)
                   grid.text(round(input, 2)[i, j], x, y, gp = gpar(fontsize = 10))
               },
               heatmap_legend_param = list(
                 legend_direction = "horizontal", 
                 legend_width = unit(6, "cm"))),
       heatmap_legend_side = "bottom")
}


# 分组可视化相关性分析结果 ====================

heatmap_group <- function(input = input,
                          type = type,
                          color = "blue2red",
                          cutoff = 0.2,
                          font.size = 10,
                          outlier.rm = T) {
  
  library(ComplexHeatmap)
  library(circlize)
  
  # 确保输入的是矩阵
  
  input <- as.matrix(input)
  
  # 设定颜色
  
  if (color == "parula") {
    col <- colorRampPalette(c("#352A87","#343EB1","#1558D9","#036CE0","#107AD9",
                              "#1387D3","#0997D1","#06A4C9","#0CADBB","#23B4A9",
                              "#43BB97","#6ABE83","#8FBF73","#AEBD66","#CBBB5B",
                              "#E6B94F","#FDBE3C","#FBCF2C","#F5E21E","#F9FB0E"))(100)
    
  } else if (color == "kovesi") {
    col <- colorRampPalette(c("#1B0084","#1B099A","#1C14AE","#1C20C0","#1F2DCE",
                              "#233DD6","#2950CE","#2E68AB","#377989","#3F876A",
                              "#46954D","#53A036","#65AB26","#7BB41A","#95BE16",
                              "#AFC61C","#C6CE26","#DAD636","#EAE04E","#F1EC74",
                              "#F8F7AF","#FFFFFF"))(100)
    
  } else if (color == "ocean.haline") {
    col <- colorRampPalette(c("#2A186C","#2E1B87","#2B229F","#1D35A1","#11459A",
                              "#0C5294","#115D8F","#19678C","#22718A","#2B7A89",
                              "#328388","#388D88","#3E9886","#44A284","#4CAC80",
                              "#55B67A","#62BF72","#73C869","#8AD060","#A4D75C",
                              "#BEDC62","#D5E171","#EAE784","#FDEF9A"))(100)
    
  } else if (color == "ocean.dense") {
    col <- c(colorRampPalette(c("white",
                                "#E6F1F1"))(35),
             colorRampPalette(rev(c("#360E24","#360E24", "#360E24",
                                    "#5D1A58","#723692","#795CC3",
                                    "#7487E0", "#7EB0E4","#AAD2E3")))(65))
    
  } else if (color == "magma") {
    col <- c(colorRampPalette(c(magma(323, begin = 0.15)[1]))(10),
             magma(323, begin = 0.18))
    
  } else if (color == "white2blue") {
    col <- colorRampPalette(c("#FBF4F8","#E5E0ED","#BFC6DD","#8CADCC",
                              "#4E92BA","#1871A8","#085889","#003758"))(100)
    
  } else if (color == "blue2red") {
    col <- colorRampPalette(c("#0070b2","#009bc7","#5ec7dd",
                              "#b8e3ea","#f3f3f1","#fccdb9",
                              "#f79676","#f15e4c","#da1735"))(100)
    
  } else if (color == "rainbow") {
    col <- colorRampPalette(c("#343391","#0064af","#0090cc","#00b6db","#01b7c2",
                              "#53c0a3","#8dcb8a","#bbd967","#fbd324","#f6bd25",
                              "#f4a02e","#ed6f32","#ea5c2e","#d5452f","#c02e2f",
                              "#8b2a21"))(100)
  }
  
  # 计算四分位值从而确定颜色范围
  
  if (outlier.rm == T) {
    all_value <- reshape2::melt(input)
    thres <- quantile(all_value$value, probs = c(0.05, 0.95), na.rm = T)
    col <- colorRamp2(seq(from = thres[1], to = thres[2],
                          length.out = length(col)), col)}
  
  # 处理注释信息
  
  common <- intersect(type$id, colnames(input))
  type <- type[type$id %in% common,]
  type <- type[order(type$type, decreasing = T),]
  input <- input[type$id,type$id]
  
  # 开始画图
  
  ha <- HeatmapAnnotation(df = data.frame(type$type), 
                          which = "column", show_annotation_name = F,
                          show_legend = FALSE)
  
  ha_row <- HeatmapAnnotation(df = data.frame(type$type),
                              which = "row", show_annotation_name = F)
  
  draw(Heatmap(input, col = col,
               name = "Z-score",
               top_annotation = ha,
               left_annotation = ha_row,
               column_gap = unit(0, "mm"),
               row_gap = unit(0, "mm"),
               border = "#404040",  
               show_row_names = T, 
               show_column_names = T,
               column_names_rot = 90, 
               row_names_gp = gpar(fontsize = font.size),
               column_split = type$type, 
               row_split = type$type,
               cluster_rows = T, show_row_dend = F,
               cluster_columns = T, show_column_dend = F,
               cell_fun = function(j, i, x, y, width, height, fill) {
                 if(input[i, j] > cutoff)
                   grid.text(round(input, 2)[i, j], x, y, gp = gpar(fontsize = 10))
               },
               heatmap_legend_param = list(
                 legend_direction = "horizontal", 
                 legend_width = unit(6, "cm"))),
       heatmap_legend_side = "bottom")
}


# 差异分析结果热图可视化 ====================

heatmap_group2 <- function(input = input,
                           type.col = type.col,
                           type.row = type.row,
                           color = "blue2red",
                           font.size = 10,
                           cluster = TRUE,
                           normalize = TRUE,
                           outlier.rm = T) {
  
  library(ComplexHeatmap)
  library(circlize)
  
  # 数据标准化
  
  if (normalize == TRUE) {
    input <- t(scale(t(input)))}
  input <- as.matrix(input)
  
  # 设定颜色
  
  if (color == "parula") {
    col <- colorRampPalette(c("#352A87","#343EB1","#1558D9","#036CE0","#107AD9",
                              "#1387D3","#0997D1","#06A4C9","#0CADBB","#23B4A9",
                              "#43BB97","#6ABE83","#8FBF73","#AEBD66","#CBBB5B",
                              "#E6B94F","#FDBE3C","#FBCF2C","#F5E21E","#F9FB0E"))(100)
    
  } else if (color == "kovesi") {
    col <- colorRampPalette(c("#1B0084","#1B099A","#1C14AE","#1C20C0","#1F2DCE",
                              "#233DD6","#2950CE","#2E68AB","#377989","#3F876A",
                              "#46954D","#53A036","#65AB26","#7BB41A","#95BE16",
                              "#AFC61C","#C6CE26","#DAD636","#EAE04E","#F1EC74",
                              "#F8F7AF","#FFFFFF"))(100)
    
  } else if (color == "ocean.haline") {
    col <- colorRampPalette(c("#2A186C","#2E1B87","#2B229F","#1D35A1","#11459A",
                              "#0C5294","#115D8F","#19678C","#22718A","#2B7A89",
                              "#328388","#388D88","#3E9886","#44A284","#4CAC80",
                              "#55B67A","#62BF72","#73C869","#8AD060","#A4D75C",
                              "#BEDC62","#D5E171","#EAE784","#FDEF9A"))(100)
    
  } else if (color == "ocean.dense") {
    col <- colorRampPalette(c("#360E24","#5D1A58","#723692","#795CC3",
                              "#7487E0", "#7EB0E4","#AAD2E3","#E6F1F1"))(100)
    
  } else if (color == "magma") {
    col <- c(colorRampPalette(c(magma(323, begin = 0.15)[1]))(10),
             magma(323, begin = 0.18))
    
  } else if (color == "white2blue") {
    col <- colorRampPalette(c("#FBF4F8","#E5E0ED","#BFC6DD","#8CADCC",
                              "#4E92BA","#1871A8","#085889","#003758"))(100)
    
  } else if (color == "blue2red") {
    col <- colorRampPalette(c("#0070b2","#009bc7","#5ec7dd",
                              "#b8e3ea","#f3f3f1","#fccdb9",
                              "#f79676","#f15e4c","#da1735"))(100)
    
  } else if (color == "rainbow") {
    col <- colorRampPalette(c("#343391","#0064af","#0090cc","#00b6db","#01b7c2",
                              "#53c0a3","#8dcb8a","#bbd967","#fbd324","#f6bd25",
                              "#f4a02e","#ed6f32","#ea5c2e","#d5452f","#c02e2f",
                              "#8b2a21"))(100)
  }
  
  # 处理注释信息
  
  common <- intersect(type.col$id, colnames(input))
  type.col <- type.col[type.col$id %in% common,]
  type.col <- type.col[order(type.col$type, decreasing = T),]
  input <- input[,type.col$id]
  
  common <- intersect(type.row$id, rownames(input))
  type.row <- type.row[type.row$id %in% common,]
  type.row <- type.row[order(type.row$type, decreasing = T),]
  input <- input[type.row$id,]
  
  # 计算四分位值从而确定颜色范围
  
  if (outlier.rm == T) {
    all_value <- reshape2::melt(input)
    thres <- quantile(all_value$value, probs = c(0.05, 0.95), na.rm = T)
    col <- colorRamp2(seq(from = thres[1], to = thres[2],
                          length.out = length(col)), col)}
  
  # 开始画图
  
  ha <- HeatmapAnnotation(df = data.frame(type.col$type), 
                          which = "column", show_annotation_name = F,
                          show_legend = FALSE)
  
  ha_row <- HeatmapAnnotation(df = data.frame(type.row$type),
                              which = "row", show_annotation_name = F)
  
  draw(Heatmap(input, col = col,
               name = "Z-score",
               top_annotation = ha,
               left_annotation = ha_row,
               column_gap = unit(1, "mm"),
               row_gap = unit(1, "mm"),
               border = "#404040",  
               show_row_names = T, 
               show_column_names = T,
               column_names_rot = 45, 
               row_names_gp = gpar(fontsize = font.size),
               column_split = type.col$type, 
               row_split = type.row$type,
               cluster_rows = cluster, show_row_dend = F,
               cluster_columns = cluster, show_column_dend = F,
               heatmap_legend_param = list(
                 legend_direction = "horizontal", 
                 legend_width = unit(6, "cm"))),
       heatmap_legend_side = "bottom")
}


# 可视化差异分析结果 ====================

heatmap_diff <- function(diffdata = diffdata,
                         expdata = expdata,
                         clustinfo = cluster,
                         color = "blue2red",
                         topn = 10,
                         col_rot = 0,
                         label = TRUE,
                         font.size = 9) {
  
  library(ComplexHeatmap)
  library(gtools)
  
  # 设定颜色
  
  if (color == "parula") {
    col <- colorRampPalette(c("#352A87","#343EB1","#1558D9","#036CE0","#107AD9",
                              "#1387D3","#0997D1","#06A4C9","#0CADBB","#23B4A9",
                              "#43BB97","#6ABE83","#8FBF73","#AEBD66","#CBBB5B",
                              "#E6B94F","#FDBE3C","#FBCF2C","#F5E21E","#F9FB0E"))(100)
    
  } else if (color == "kovesi") {
    col <- colorRampPalette(c("#1B0084","#1B099A","#1C14AE","#1C20C0","#1F2DCE",
                              "#233DD6","#2950CE","#2E68AB","#377989","#3F876A",
                              "#46954D","#53A036","#65AB26","#7BB41A","#95BE16",
                              "#AFC61C","#C6CE26","#DAD636","#EAE04E","#F1EC74",
                              "#F8F7AF","#FFFFFF"))(100)
    
  } else if (color == "ocean.haline") {
    col <- colorRampPalette(c("#2A186C","#2E1B87","#2B229F","#1D35A1","#11459A",
                              "#0C5294","#115D8F","#19678C","#22718A","#2B7A89",
                              "#328388","#388D88","#3E9886","#44A284","#4CAC80",
                              "#55B67A","#62BF72","#73C869","#8AD060","#A4D75C",
                              "#BEDC62","#D5E171","#EAE784","#FDEF9A"))(100)
    
  } else if (color == "ocean.dense") {
    col <- colorRampPalette(c("#360E24","#5D1A58","#723692","#795CC3",
                              "#7487E0", "#7EB0E4","#AAD2E3","#E6F1F1"))(100)
    
  } else if (color == "magma") {
    col <- c(colorRampPalette(c(magma(323, begin = 0.15)[1]))(10),
             magma(323, begin = 0.18))
    
  } else if (color == "white2blue") {
    col <- colorRampPalette(c("#FBF4F8","#E5E0ED","#BFC6DD","#8CADCC",
                              "#4E92BA","#1871A8","#085889","#003758"))(100)
    
  } else if (color == "blue2red") {
    col <- colorRampPalette(c("#0070b2","#009bc7","#5ec7dd",
                              "#b8e3ea","#f3f3f1","#fccdb9",
                              "#f79676","#f15e4c","#da1735"))(100)
    
  } else if (color == "rainbow") {
    col <- colorRampPalette(c("#343391","#0064af","#0090cc","#00b6db","#01b7c2",
                              "#53c0a3","#8dcb8a","#bbd967","#fbd324","#f6bd25",
                              "#f4a02e","#ed6f32","#ea5c2e","#d5452f","#c02e2f",
                              "#8b2a21"))(100)
  }
  
  # 过滤p > 0.05的结果
  
  diffdata <- diffdata[diffdata$pvalue < 0.01 &
                       diffdata$logfc > 0.5,]
  
  # 选择top的genesets
  
  select <- mixedsort(as.character(unique(diffdata$cluster)))
  
  diffdata <- do.call(rbind, lapply(select, function(i){
    subdata <- diffdata[diffdata$cluster == i,]
    subdata <- top_n(subdata, topn, -log10(pvalue))
    subdata[order(subdata$pvalue),]
  }))
  
  # 处理表达数据
  
  input <- lapply(as.character(unique(clustinfo$cluster)), function(i){
    select <- clustinfo$id[clustinfo$cluster == i]
    data.frame(rowMeans(expdata[,select]))
  })
  
  input <- do.call(cbind, input)
  colnames(input) <- as.character(unique(clustinfo$cluster))
  
  # 数据排序
  
  input <- input[,mixedsort(colnames(input))]
  input <- input[diffdata$id,]
  
  # 数据标准化
  
  input <- t(scale(t(input)))
  
  # 开始画图
  
  Heatmap(input, col = col, 
          show_row_names = label, 
          show_column_names = T, 
          column_names_rot = col_rot,
          cluster_rows = F, show_row_dend = F,
          cluster_columns = F, show_column_dend = F,
          row_names_gp = gpar(fontsize = font.size))
}


# 相关性热图1 ====================

heatmap_cor <- function(input = input,
                        color = "ocean.dense",
                        show.name = TRUE,
                        rev.col = TRUE,
                        cluster = TRUE) {
  
  library(ComplexHeatmap)
  library(circlize)
  library(gtools)
  
  # 设定颜色
  
  if (color == "parula") {
    col <- colorRampPalette(c("#352A87","#343EB1","#1558D9","#036CE0","#107AD9",
                              "#1387D3","#0997D1","#06A4C9","#0CADBB","#23B4A9",
                              "#43BB97","#6ABE83","#8FBF73","#AEBD66","#CBBB5B",
                              "#E6B94F","#FDBE3C","#FBCF2C","#F5E21E","#F9FB0E"))(100)
    
  } else if (color == "kovesi") {
    col <- colorRampPalette(c("#1B0084","#1B099A","#1C14AE","#1C20C0","#1F2DCE",
                              "#233DD6","#2950CE","#2E68AB","#377989","#3F876A",
                              "#46954D","#53A036","#65AB26","#7BB41A","#95BE16",
                              "#AFC61C","#C6CE26","#DAD636","#EAE04E","#F1EC74",
                              "#F8F7AF","#FFFFFF"))(100)
    
  } else if (color == "ocean.deep") {
    col <- colorRampPalette(c("#281A2C","#352A4A","#3F396D","#404C8B","#3E6495",
                              "#427999","#488E9E","#50A3A2","#5DBAA4","#78CEA3",
                              "#A3DEA6","#D1EDB4","#FDFECC"))(100)
    
  } else if (color == "ocean.dense") {
    col <- colorRampPalette(c("#360E24","#5D1A58","#723692","#795CC3",
                              "#7487E0", "#7EB0E4","#AAD2E3","#E6F1F1"))(100)
    
  } else if (color == "magma") {
    col <- c(colorRampPalette(c(magma(323, begin = 0.15)[1]))(10),
             magma(323, begin = 0.18))
    
  } else if (color == "white2blue") {
    col <- colorRampPalette(c("#FBF4F8","#E5E0ED","#BFC6DD","#8CADCC",
                              "#4E92BA","#1871A8","#085889","#003758"))(100)
    
  } else if (color == "blue2red") {
    col <- colorRampPalette(c("#0070b2","#009bc7","#5ec7dd",
                              "#b8e3ea","#f3f3f1","#fccdb9",
                              "#f79676","#f15e4c","#da1735"))(100)
    
  } else if (color == "rainbow") {
    col <- colorRampPalette(c("#343391","#0064af","#0090cc","#00b6db","#01b7c2",
                              "#53c0a3","#8dcb8a","#bbd967","#fbd324","#f6bd25",
                              "#f4a02e","#ed6f32","#ea5c2e","#d5452f","#c02e2f",
                              "#8b2a21"))(100)
  }
  
  
  # 颜色反转 ----------
  
  if (rev.col == TRUE) {
    col <- rev(col)
  }
  
  
  # 计算四分位值从而确定颜色范围 ----------
  
  all_value <- melt(input, id.vars = c("value"))
  all_value <- all_value[!(all_value$value %in% 1),]
  
  thres <- quantile(all_value$value, probs = c(0.01, 0.99))
  col <- colorRamp2(seq(from = thres[1], to = thres[2],
                        length.out = length(col)), col)
  
  
  # 开始画图 ----------
  
  Heatmap(input, col = col, 
          show_row_names = show.name, 
          show_column_names = show.name, 
          cluster_rows = cluster, show_row_dend = F,
          cluster_columns = cluster, show_column_dend = F,
          row_names_gp = gpar(fontsize = 10),
          column_names_gp = gpar(fontsize = 10))
}


# 相似性热图2 ====================

simi_metaprogram_plot2 <- function(input = input,
                                   cutoff.i = 0.05,
                                   cutoff.n = 1,
                                   col.lim = c(0, 1),
                                   color = "ocean.dense",
                                   rev.col = TRUE) {
  library(corrplot)
  
  # 设定颜色
  
  if (color == "parula") {
    col <- colorRampPalette(c("#352A87","#343EB1","#1558D9","#036CE0","#107AD9",
                              "#1387D3","#0997D1","#06A4C9","#0CADBB","#23B4A9",
                              "#43BB97","#6ABE83","#8FBF73","#AEBD66","#CBBB5B",
                              "#E6B94F","#FDBE3C","#FBCF2C","#F5E21E","#F9FB0E"))(100)
    
  } else if (color == "kovesi") {
    col <- colorRampPalette(c("#1B0084","#1B099A","#1C14AE","#1C20C0","#1F2DCE",
                              "#233DD6","#2950CE","#2E68AB","#377989","#3F876A",
                              "#46954D","#53A036","#65AB26","#7BB41A","#95BE16",
                              "#AFC61C","#C6CE26","#DAD636","#EAE04E","#F1EC74",
                              "#F8F7AF","#FFFFFF"))(100)
    
  } else if (color == "ocean.haline") {
    col <- colorRampPalette(c("#2A186C","#2E1B87","#2B229F","#1D35A1","#11459A",
                              "#0C5294","#115D8F","#19678C","#22718A","#2B7A89",
                              "#328388","#388D88","#3E9886","#44A284","#4CAC80",
                              "#55B67A","#62BF72","#73C869","#8AD060","#A4D75C",
                              "#BEDC62","#D5E171","#EAE784","#FDEF9A"))(100)
    
  } else if (color == "ocean.dense") {
    col <- colorRampPalette(c("#360E24","#5D1A58","#723692","#795CC3",
                              "#7487E0", "#7EB0E4","#AAD2E3","#E6F1F1"))(100)
    
  } else if (color == "magma") {
    col <- c(colorRampPalette(c(magma(323, begin = 0.15)[1]))(10),
             magma(323, begin = 0.18))
    
  } else if (color == "white2blue") {
    col <- colorRampPalette(c("#FBF4F8","#E5E0ED","#BFC6DD","#8CADCC",
                              "#4E92BA","#1871A8","#085889","#003758"))(100)
    
  } else if (color == "blue2red") {
    col <- colorRampPalette(c("#0070b2","#009bc7","#5ec7dd",
                              "#b8e3ea","#f3f3f1","#fccdb9",
                              "#f79676","#f15e4c","#da1735"))(100)
    
  } else if (color == "rainbow") {
    col <- colorRampPalette(c("#343391","#0064af","#0090cc","#00b6db","#01b7c2",
                              "#53c0a3","#8dcb8a","#bbd967","#fbd324","#f6bd25",
                              "#f4a02e","#ed6f32","#ea5c2e","#d5452f","#c02e2f",
                              "#8b2a21"))(100)
  }
  
  
  # 颜色反转 ----------
  
  if (rev.col == TRUE) {
    col <- rev(col)
  }
  
  
  # 对program进行聚类 ----------
  
  input_b <- ifelse(input > cutoff.i, 1, 0)
  
  # 进行层次聚类
  
  dist <- as.dist(1-input_b)
  hc <- hclust(d = dist, method = "average")
  
  # 得到cluster
  
  cluster <- data.frame(cluster = cutree(hc, h = 0.1), check.names = F)
  cluster <- rownames_to_column(cluster, var = "id")
  
  
  # 筛选重复出现的program ----------
  
  number <- data.frame(table(cluster$cluster), check.names = F)
  number$Var1 <- as.character(number$Var1)
  
  select <- number$Var1[number$Freq > cutoff.n]
  cluster_flt <- cluster[cluster$cluster %in% select,]
  
  
  # 提取重复出现的program ----------
  
  cor_flt <- input[cluster_flt$id, cluster_flt$id]
  knumber <- length(unique(cluster_flt$cluster))
  
  
  # 热图可视化 ----------
  
  corrplot(as.matrix(cor_flt),
           method = "color", 
           order = "hclust",
           is.corr = FALSE,
           hclust.method = "ward.D2",
           col.lim = col.lim, tl.col = "black",
           addrect = knumber, col = col)
}


# 得到meta program ====================

simi_metaprogram <- function(input = input,
                             cutoff.i = 0.05,
                             cutoff.n = 1) {
  
  # 对program进行聚类
  
  input_b <- ifelse(input > cutoff.i, 1, 0)
  
  # 进行层次聚类
  
  dist <- as.dist(1-input_b)
  hc <- hclust(d = dist, method = "average")
  
  # 得到cluster
  
  cluster <- data.frame(cluster = cutree(hc, h = 0.1), check.names = F)
  cluster <- rownames_to_column(cluster, var = "id")
  
  # 筛选重复出现的program
  
  number <- data.frame(table(cluster$cluster), check.names = F)
  number$Var1 <- as.character(number$Var1)
  
  select <- number$Var1[number$Freq > cutoff.n]
  data <- cluster[cluster$cluster %in% select,]
  
  # 根据metaprogram包含的program数量进行排序
  
  number <- data.frame(table(data$cluster))
  number <- number$Var1[order(number$Freq, decreasing = T)]
  
  data$cluster <- factor(data$cluster, levels = c(number))
  data[order(data$cluster),]
}


# 相似性热图3 ====================

simi_metaprogram_plot1 <- function(input = input,
                                   show.name = TRUE,
                                   cluster = TRUE) {
  
  library(ComplexHeatmap)
  library(circlize)
  library(gtools)
  library(pals)
  library(viridis)
  
  # 设定颜色
  
  col <- c(colorRampPalette(c("white",
                              "#E6F1F1"))(10),
           colorRampPalette(rev(c("#360E24","#5D1A58","#723692","#795CC3",
                                  "#7487E0", "#7EB0E4","#AAD2E3")))(90))
  
  # 计算四分位值从而确定颜色范围 ----------
  
  all_value <- melt(input, id.vars = c("value"))
  all_value <- all_value[!(all_value$value %in% 1),]
  
  thres <- quantile(all_value$value, probs = c(0.01, 0.99))
  col <- colorRamp2(seq(from = thres[1], to = thres[2],
                        length.out = length(col)), col)
  
  # 开始画图 ----------
  
  Heatmap(input, col = col, 
          show_row_names = show.name, 
          show_column_names = show.name, 
          cluster_rows = cluster, show_row_dend = F,
          cluster_columns = cluster, show_column_dend = F,
          row_names_gp = gpar(fontsize = 10),
          column_names_gp = gpar(fontsize = 10))
}



# 箱线图 =======================================================================
# ==============================================================================

boxplot_rss <- function(input = input,
                        output = name,
                        width = 3.5, height = 5) {
  
  library(ggbeeswarm)
  library(ggplot2)
  library(ggpubr)
  
  input <- input
  
  # 整理输入数据
  
  value1 = quantile(input$value, probs = c(0.005), na.rm = T)
  value2 = quantile(input$value, probs = c(0.98), na.rm = T)
  
  # 设定颜色
  
  col <- c("#0070B2", "#5CB3DA", "#B8E3EA", "#DA1735", "#F15E4C", "#FF9F99",
           "#A231A1", "#A37CB7", "#F2D7EE", "#B91372", "#E93B8C", "#ECB2C8",
           "#FF7149", "#F7AE24", "#FBDD7E", "#679436", "#8BBE53", "#CDE391",
           "#067D69", "#00A385", "#98D4C6", "#114B5F", "#028090", "#B2DBBF",
           "#A23E48", "#CD6981", "#FBD0C0", "#788585", "#9CAEA9", "#CCDAD1")
  
  # 开始画图
  
  plot <- ggplot(input, aes(x = type, y = value, fill = type)) +
    stat_boxplot(geom = "errorbar", width = 0, color = "black") +
    geom_boxplot(alpha = 1, outlier.shape = NA, size = 0.7, width = 0.7) + 
    
    geom_quasirandom(width = 0, size = 3, alpha = 1) + 
    scale_fill_manual(values=c("#FBD324", "#A37CB7", sample(col))) + 
    
    theme_bw() + 
    theme(panel.grid = element_blank(),
          legend.position = "none", # 去除图例
          axis.text = element_text(colour = "black", size = 15), 
          axis.title = element_text(colour = "black", size = 15),
          panel.border = element_rect(fill = NA, color = "black", linewidth = 1)) + 
    labs(x = '', y= 'Specificity score',title = '') + ylim(0, 1.5)
  
  ggsave(output, plot, width = width, height = height)
}



# 柱状图 =======================================================================
# ==============================================================================

common_bar_box_plot <- function(input = input,
                           rotate = 45,
                           order = TRUE,
                           output = name, 
                           width = 7, height = 5) {
  
  library(ggbeeswarm)
  library(ggplot2)
  library(ggpubr)
  
  # 设置颜色
  
  col <- c("#A6D719", "#176EBF", "#AEE0E8", "#FBD324", "#F28A24", "#A37CB7",
           "#0070B2", "#5CB3DA", "#B8E3EA", "#DA1735", "#F15E4C", "#FF9F99",
           "#A231A1", "#A37CB7", "#F2D7EE", "#B91372", "#E93B8C", "#ECB2C8",
           "#FF7149", "#F7AE24", "#FBDD7E", "#679436", "#8BBE53", "#CDE391",
           "#067D69", "#00A385", "#98D4C6", "#114B5F", "#028090", "#B2DBBF",
           "#A23E48", "#CD6981", "#FBD0C0", "#788585", "#9CAEA9", "#CCDAD1")
  
  # 均值标准差计算
  
  aggdata1 <- aggregate(input$value, by = list(input$type),FUN = mean)
  aggdata2 <- aggregate(input$value, by = list(input$type),FUN = sd)
  
  new_data <- data.frame(aggdata1, sd = aggdata2[,2])
  names(new_data)[1:2] <- c("id", "mean_value")
  
  # 数据排序
  
  if (order == TRUE) {
    levels <- new_data$id[order(new_data$mean_value, decreasing = TRUE)]
    new_data$id <- factor(new_data$id, levels = levels)
    input$type <- factor(input$type, levels = levels)
  }
  
  # 开始画error plot
  
  plot1 <- ggplot(new_data, aes(x = id, y = mean_value)) + 
    
    geom_errorbar(aes(ymin = mean_value-sd, ymax = mean_value+sd), width = 0.2) + 
    stat_summary(fun = median, 
                 geom = "crossbar", 
                 width = 0.5, linewidth = 0.5) + 
    geom_dotplot(data = input, aes(x = type, y = value, fill = sample),
                 binaxis = 'y', stackdir = 'center', 
                 stackratio = 1.5, binwidth = 0.1,
                 binpositions = "all", dotsize = 0.6, alpha = 1) + 
    
    scale_fill_manual(values = c(col)) + 
    
    theme_bw() + 
    theme(panel.grid = element_blank(),
          legend.key.size = unit(0.75,'cm'),
          legend.text = element_text(size = 15),
          legend.title = element_blank(),
          axis.text = element_text(colour = "black", size = 15), 
          axis.title = element_text(colour = "black", size = 15),
          panel.border = element_rect(fill = NA, color = "black", linewidth = 1)) + 
    labs(x = '', y= 'Score',title = '') + ylim(-0.5, 1.5) + 
    geom_hline(aes(yintercept = 0), linetype = "dashed") + 
    rotate_x_text(rotate)
  
  
  # 开始画boxplot
  
  input$type2 <- "All_points"
  plot2 <- ggplot(input, aes(x = type2, y = value)) +
    stat_boxplot(geom = "errorbar", width = 0, color = "black") +
    geom_boxplot(alpha = 1, outlier.shape = NA,
                 size = 0.7, width = 0.7, fill = "#FBD324") + 
    theme_bw() + 
    theme(panel.grid = element_blank(),
          legend.key.size = unit(0.75,'cm'),
          legend.text = element_text(size = 15),
          legend.title = element_blank(),
          axis.text = element_text(colour = "black", size = 15), 
          axis.title = element_text(colour = "black", size = 15),
          panel.border = element_rect(fill = NA, color = "black", linewidth = 1)) +   
    labs(x = '',y= '',title = '') + ylim(-0.5, 1.5)
  
  # 整合图形
  
  library(aplot)
  allplots <- plot1 %>% 
    insert_right(plot2, width=.15)
  
  # 保存结果
  
  ggsave(output, allplots, width = width, height = height)
}


# Error bar plot ====================

common_barplot <- function(input = input,
                           rotate = 45,
                           order = TRUE,
                           output = name, 
                           width = 7, height = 5) {
  
  library(ggbeeswarm)
  library(ggplot2)
  library(ggpubr)
  
  # 设置颜色
  
  col <- c("#A6D719", "#176EBF", "#AEE0E8", "#FBD324", "#F28A24", "#A37CB7",
           "#0070B2", "#5CB3DA", "#B8E3EA", "#DA1735", "#F15E4C", "#FF9F99",
           "#A231A1", "#A37CB7", "#F2D7EE", "#B91372", "#E93B8C", "#ECB2C8",
           "#FF7149", "#F7AE24", "#FBDD7E", "#679436", "#8BBE53", "#CDE391",
           "#067D69", "#00A385", "#98D4C6", "#114B5F", "#028090", "#B2DBBF",
           "#A23E48", "#CD6981", "#FBD0C0", "#788585", "#9CAEA9", "#CCDAD1")
  
  # 均值标准差计算
  
  aggdata1 <- aggregate(input$value, by = list(input$type),FUN = mean)
  aggdata2 <- aggregate(input$value, by = list(input$type),FUN = sd)
  
  new_data <- data.frame(aggdata1, sd = aggdata2[,2])
  names(new_data)[1:2] <- c("id", "mean_value")
  
  # 数据排序
  
  if (order == TRUE) {
    levels <- new_data$id[order(new_data$mean_value, decreasing = TRUE)]
    new_data$id <- factor(new_data$id, levels = levels)
    input$type <- factor(input$type, levels = levels)
  }
  
  # 开始画图
  
  plot <- ggplot(new_data, aes(x = id, y = mean_value)) + 
    
    geom_errorbar(aes(ymin = mean_value-sd, ymax = mean_value+sd), width = 0.2) + 
    stat_summary(fun = median, 
                 geom = "crossbar", 
                 width = 0.5, linewidth = 0.5) + 
    geom_point(data = input, aes(x = type, y = value,
                                 fill = sample, color = sample),
               size = 3, alpha = 1) + 
    
    scale_color_manual(values = c(col)) + 
    
    theme_bw() + 
    theme(panel.grid = element_blank(),
          legend.key.size = unit(0.75,'cm'),
          legend.text = element_text(size = 15),
          legend.title = element_blank(),
          legend.position = "bottom",
          axis.text = element_text(colour = "black", size = 15), 
          axis.title = element_text(colour = "black", size = 15),
          panel.border = element_rect(fill = NA, color = "black", linewidth = 1)) + 
    labs(x = '', y= 'Score',title = '') + 
    rotate_x_text(rotate)
  
  # 保存结果
  
  ggsave(output, plot, width = width, height = height)
}


# 简单柱状图 ====================

simple_barplot <- function(input = input,
                           order = TRUE,
                           decreasing = TRUE,
                           coord.flip = TRUE) {
  
  library(ggplot2)
  library(forcats)
  library(ggpubr)
  
  if (order == TRUE) {
    input <- input[order(input$value, decreasing = decreasing),]
    input$id <- fct_inorder(input$id)}
  
  if (coord.flip == TRUE) {
    
    ggplot(input, aes(x = id, y = value))+
      geom_bar(stat = 'identity', width = 0.75) + 
      theme_bw() + 
      theme(panel.grid = element_blank(),
            axis.text = element_text(colour = "black", size = 15),
            axis.title = element_text(colour = "black", size = 15),
            panel.border = element_rect(fill = NA, color = "black", linewidth = 1)) + 
      labs(x = '', y= 'Value',title = '') + coord_flip() + 
      theme(plot.margin = unit(c(1, 3, 1, 3), "lines"))
    
  } else {
    
    ggplot(input, aes(x = id, y = value))+
      geom_bar(stat = 'identity', width = 0.75) + 
      theme_bw() + 
      theme(panel.grid = element_blank(),
            axis.text = element_text(colour = "black", size = 15),
            axis.title = element_text(colour = "black", size = 15),
            panel.border = element_rect(fill = NA, color = "black", linewidth = 1)) + 
      labs(x = '', y= 'Value',title = '') + rotate_x_text(45)
  }
}




# jitter boxplot ====================

jitter_boxplot <- function(input = input,
                           start.point = 0,
                           name.coord = "Value",
                           order = TRUE, decreasing = T,
                           output = name,
                           width = 5, height = 7) {
  
  library(ggplot2)
  
  # 设置颜色
  
  col <- c("#A6D719", "#176EBF", "#AEE0E8", "#FBD324", "#F28A24", "#A37CB7",
           "#0070B2", "#5CB3DA", "#B8E3EA", "#DA1735", "#F15E4C", "#FF9F99",
           "#A231A1", "#A37CB7", "#F2D7EE", "#B91372", "#E93B8C", "#ECB2C8",
           "#FF7149", "#F7AE24", "#FBDD7E", "#679436", "#8BBE53", "#CDE391",
           "#067D69", "#00A385", "#98D4C6", "#114B5F", "#028090", "#B2DBBF",
           "#A23E48", "#CD6981", "#FBD0C0", "#788585", "#9CAEA9", "#CCDAD1")
  
  # 数据排序
  
  mean_data <- aggregate(input$value, by = list(input$type), FUN = mean)
  names(mean_data)[1:2] <- c("id", "mean_value")
  
  if (order == TRUE) {
    levels <- mean_data$id[order(mean_data$mean_value, decreasing = decreasing)]
    input$type <- factor(input$type, levels = levels)
  }
  
  # 计算中位值
  
  stat <- aggregate(.~type, input, mean)
  
  # 开始画图
  
  plot <- ggplot(input, aes(x = type, y = value,
                            fill = type, color = type)) +
    geom_segment(data = stat, 
                 aes(x = type, xend = type,
                     y = start.point, yend = value),
                 size = 0.75, color = "black") + 
    
    geom_jitter(size = 3, alpha = 0.25, width = 0.15) + 
    scale_color_manual(values = c(col)) + 
    
    stat_summary(fun = mean, geom = "point", size = 5.5, color = "black") + 
    geom_hline(aes(yintercept = start.point),
               linetype = "dashed", size = 0.75) + 
    
    theme_bw() + 
    theme(panel.grid = element_blank(),
          axis.text = element_text(colour = "black", size = 15),
          axis.title = element_text(colour = "black", size = 15),
          panel.border = element_rect(fill = NA, color = "black", linewidth = 1),
          legend.position = "none") + 
    
    coord_flip() +
    labs(x = NULL, y = name.coord)
  
  # 输出结果
  
  if (is.null(output)) {
    plot
  } else {
    ggsave(output, plot, width = width, height = height)
  }
}


# jitter boxplot2 ====================

jitter_boxplot2 <- function(input = input,
                            start.point = 0,
                            name.coord = "Value",
                            order = TRUE, decreasing = T,
                            color = "continuous", output = name,
                            width = 5, height = 7) {
  library(ggplot2)
  
  # 设置颜色
  
  if (length(color) == 1) {
    
    if (color == "discrete") {
      
      col <- c("#A6D719", "#176EBF", "#00A8DE",
               "#AEE0E8", "#00A9A3", "#FBD324",
               "#F28A24", "#A52828", "#A37CB7")
      
    } else if (color == "continuous") {
      
      col <- c("#f3bd2e","#e2720f","#e02f2c",
               "#861b20","#b51b7f","#7f137f","#622183")
      col <- colorRampPalette(col)(nrow(input))
      
    }
    
  } else {
    col <- color
  }
  
  # 数据排序
  
  mean_data <- aggregate(input$value, by = list(input$type), FUN = median)
  names(mean_data)[1:2] <- c("id", "mean_value")
  
  if (order == TRUE) {
    levels <- mean_data$id[order(mean_data$mean_value, decreasing = decreasing)]
    input$type <- factor(input$type, levels = levels)
  }
  
  # 计算中位值
  
  stat <- aggregate(input$value, by = list(input$type), FUN = median)
  names(stat) <- c("type", "value")
  
  # 开始画图
  
  plot <- ggplot(input, aes(x = type, y = value)) +
    geom_segment(data = stat, 
                 aes(x = type, xend = type,
                     y = start.point, yend = value),
                 size = 0.75, color = "black") + 
    
    geom_jitter(aes(fill = sample, color = sample),
                size = 3.5, alpha = 0.75, width = 0) + 
    scale_color_manual(values = c(col)) + 
    
    stat_summary(fun = median, geom = "point", size = 5, color = "black") + 
    geom_hline(aes(yintercept = start.point),
               linetype = "dashed", size = 0.75) + 
    
    theme_bw() + 
    theme(panel.grid = element_blank(),
          axis.text = element_text(colour = "black", size = 15),
          axis.title = element_text(colour = "black", size = 15),
          panel.border = element_rect(fill = NA, color = "black", linewidth = 1),
          legend.key.size = unit(0.75,'cm'),
          legend.text = element_text(size = 15),
          legend.title = element_blank(),
          legend.position = "right") + 
    
    coord_flip() +
    labs(x = NULL, y = name.coord)
  
  ggsave(output, plot, width = width, height = height)
}



# 基因集分组富集分析 ===========================================================
# ==============================================================================

# 基本富集分析 ====================

enrichr_cluster <- function(data = data,
                            source = path,
                            geneset = "KEGG",
                            cutoff_p = 0.05,
                            cutoff_adjustp = 1) {
  
  library(clusterProfiler)
  library(enrichplot)
  library(ggplot2)
  library(gridExtra)
  library(msigdbr)
  options(connectionObserver = NULL)
  
  # 准备基因注释文件
  
  all_genesets <- readRDS(source)
  genesets <- reshape2::melt(all_genesets[[geneset]])
  genesets <- data.frame(term = genesets[,2], gene = genesets[,1])
  
  # 循环富集分析
  
  results <- lapply(unique(data$type), function(i){
    input <- data$gene[data$type == i]
    kk <- enricher(input, TERM2GENE = genesets,
                   pvalueCutoff = 1, qvalueCutoff = 1)
    
    # 提取结果
    
    if (!is.null(kk)) {
      result <- kk@result
      result$type <- i
      result[order(result$pvalue),]
    } else {NA}
  })
  
  results <- results[!is.na(results)]
  results <- do.call(rbind, results)
  
  # 总结结果
  
  results <- data.frame(id = results$ID,
                        type = results$type,
                        pvalue = results$pvalue,
                        adjustp = results$p.adjust,
                        ratio = results$GeneRatio,
                        summary = results$geneID)
  
  # 结果过滤
  
  results <- results[results$pvalue < cutoff_p &
                       results$adjustp < cutoff_adjustp,]
}


# GSEA富集分析 ====================

gsea_cluster <- function(data = data,
                         source = path,
                         geneset = "msigdb_hallmark",
                         cutoff_es = 0,
                         cutoff_p = 0.05,
                         cutoff_adjustp = 1,
                         ncore = 5) {
  
  library(clusterProfiler)
  library(enrichplot)
  library(ggplot2)
  library(gridExtra)
  library(msigdbr)
  library(future.apply)
  options(connectionObserver = NULL)
  
  # 处理注释信息 ----------
  
  if (is.null(geneset)) {
    
    sig_list <- read.table(source, sep = ",", header = F,
                           row.names = 1, na.strings = "")
    
    sig_list <- lapply(rownames(sig_list), function(i){
      subdata <- t(sig_list[i,])[,1]
      subdata <- data.frame(term = i, gene = subdata)
    })
    
    sig_list <- do.call(rbind, sig_list)
    sig_list <- na.omit(sig_list)
    
  } else {
    
    all_genesets <- readRDS(source)
    genesets <- reshape2::melt(all_genesets[[geneset]])
    sig_list <- data.frame(term = genesets[,2], gene = genesets[,1])
    
  }
  
  # 循环富集分析 ----------
  
  plan(multisession, workers = ncore)
  options(future.globals.maxSize = 3000*1024^2)
  
  results <- future_lapply(colnames(data), function(i){
    input <- data.frame(id = rownames(data), value = data[,i])
    input <- input[order(input$value, decreasing = T),]
    
    id.fc <- input$value
    names(id.fc) <- input$id
    
    kk <- GSEA(id.fc, TERM2GENE = sig_list,
               pvalueCutoff = 1)
    
    # 提取结果
    
    if (!is.null(kk)) {
      result <- kk@result
      result$type <- i
      result[order(result$enrichmentScore, decreasing = T),]
    } else {NA}
    
  }, future.seed = TRUE)
  plan(sequential)
  
  results <- results[!is.na(results)]
  results <- do.call(rbind, results)
  
  # 总结结果 ----------
  
  results <- data.frame(id = results$ID,
                        type = results$type,
                        es = results$enrichmentScore,
                        NES = results$NES,
                        pvalue = results$pvalue,
                        adjustp = results$p.adjust)
  
  # 结果过滤 ----------
  
  results <- results[results$pvalue < cutoff_p &
                     results$adjustp < cutoff_adjustp &
                     results$es > cutoff_es,]
}


# 干性分组富集分析 ====================

stem_enrichr_cluster <- function(data = data,
                                 source = path,
                                 cutoff_p = 0.05,
                                 cutoff_adjustp = 1) {
  
  library(clusterProfiler)
  library(enrichplot)
  library(ggplot2)
  library(gridExtra)
  library(msigdbr)
  options(connectionObserver = NULL)
  
  # 准备基因注释文件
  
  sig_list <- read.table(source, sep = ",", header = F,
                         row.names = 1, na.strings = "")
  
  genesets <- lapply(rownames(sig_list), function(i){
    subdata <- t(sig_list[i,])[,1]
    subdata <- data.frame(term=i, gene=subdata)
  })
  
  genesets <- do.call(rbind, genesets)
  genesets <- na.omit(genesets)
  
  # 循环富集分析
  
  results <- lapply(unique(data$type), function(i){
    input <- data$gene[data$type == i]
    kk <- enricher(input, TERM2GENE = genesets,
                   pvalueCutoff = 1, qvalueCutoff = 1)
    
    # 提取结果
    
    if (!is.null(kk)) {
      result <- kk@result
      result$type <- i
      result[order(result$pvalue),]
    } else {NA}
  })
  
  results <- results[!is.na(results)]
  results <- do.call(rbind, results)
  
  # 总结结果
  
  results <- data.frame(id = results$ID,
                        type = results$type,
                        pvalue = results$pvalue,
                        adjustp = results$p.adjust,
                        ratio = results$GeneRatio,
                        summary = results$geneID)
  
  # 结果过滤
  
  results <- results[results$pvalue < cutoff_p &
                       results$adjustp < cutoff_adjustp,]
}


# 基因集分组富集分析 (可视化) ====================

enrichr_cluster_plot <- function(data = data,
                                 select = "pvalue",
                                 topN = 5,
                                 color = "col2",
                                 outlier.rm = T) {
  library(dplyr)
  library(reshape2)
  library(ComplexHeatmap)
  library(circlize)
  
  # 整理数据
  
  data[,select] <- -log10(data[,select])
  
  # 选择top的genesets
  
  data <- do.call(rbind, lapply(unique(data$type), function(i){
    subdata <- data[data$type == i,]
    top_n(subdata, topN, pvalue)
  }))
  
  # 确定排序
  
  order <- unique(data$id)
  
  # 长宽转换
  
  data <- acast(data, id ~ type, value.var = select,
                fun.aggregate = mean, na.rm = TRUE)
  
  data[data == "NaN"] <- 0
  data <- data[order,]
  
  # 设置颜色
  
  if (color == "col1") {
    col <- colorRampPalette(c("#1B0084","#1B099A","#1C14AE","#1C20C0","#1F2DCE",
                              "#233DD6","#2950CE","#2E68AB","#377989","#3F876A",
                              "#46954D","#53A036","#65AB26","#7BB41A","#95BE16",
                              "#AFC61C","#C6CE26","#DAD636","#EAE04E","#F1EC74",
                              "#F8F7AF","#FFFFFF"))(50)
    
  } else if (color == "col2") {
    col <- rev(colorRampPalette(c("#360E24","#5D1A58","#723692","#795CC3","#7487E0",
                                  "#7EB0E4","#AAD2E3","#E6F1F1"))(50))
    
  } else if (color == "col3") {
    col <- colorRampPalette(c("#352A87","#343EB1","#1558D9","#036CE0","#107AD9",
                              "#1387D3","#0997D1","#06A4C9","#0CADBB","#23B4A9",
                              "#43BB97","#6ABE83","#8FBF73","#AEBD66","#CBBB5B",
                              "#E6B94F","#FDBE3C","#FBCF2C","#F5E21E","#F9FB0E"))(50)
    
  } else if (color == "col4") {
    col <- colorRampPalette(c("white", "black"))(50)
  }
  
  # 计算四分位值从而确定颜色范围
  
  if (outlier.rm == T) {
    all_value <- reshape2::melt(data)
    thres <- quantile(all_value$value, probs = c(0.05, 0.95))
    col <- colorRamp2(seq(from = thres[1], to = thres[2],
                          length.out = length(col)), col)}
  
  # 热图可视化
  
  Heatmap(data, col = col, 
          show_row_names = T, 
          show_column_names = T,
          column_names_rot = 45,
          cluster_rows = F, show_row_dend = F,
          cluster_columns=F, show_column_dend = F, 
          rect_gp = gpar(col = "white", lwd = 0.75))
}



# 相关性分析 ===================================================================
# ==============================================================================

# 多对多相关性 ====================

cor_betweenAB_exact <- function(input1 = input1,
                                input2 = input2,
                                method = c("pearson"),
                                format = c("wide"),
                                ncore = 1) {
  
  library(reshape2)
  library(future.apply)
  
  input1 <- as.matrix(input1)
  input2 <- as.matrix(input2)
  
  # 确保行名一致
  
  common <- intersect(rownames(input1), rownames(input2))
  input1 <- input1[common,]
  input2 <- input2[common,]
  
  # 开始计算
  
  if (ncore == 1) {
    
    allresult <- do.call(rbind, lapply(colnames(input1), function(i){
      result <- do.call(rbind, lapply(colnames(input2), function(j){
        
        input <- data.frame(a = input1[,i], b = input2[,j])
        test <- corr.test(input, adjust = "none", method = method)
        data.frame(id1 = i, id2 = j,
                   cor = test$r[1,2],
                   pvalue = test$p[1,2])
      }))
    }))
    
  } else {
    
    plan(multisession, workers = ncore)
    options(future.globals.maxSize = 3000*1024^2)
    
    allresult <- do.call(rbind, future_lapply(colnames(input1), function(i){
      result <- do.call(rbind, lapply(colnames(input2), function(j){
        
        input <- data.frame(a = input1[,i], b = input2[,j])
        test <- corr.test(input, adjust = "none", method = method)
        data.frame(id1 = i, id2 = j,
                   cor = test$r[1,2],
                   pvalue = test$p[1,2])
      }))
      
    }, future.seed = TRUE))
    plan(sequential)
    
  }
  
  # 矫正P值
  
  allresult$FDR <- p.adjust(allresult$pvalue, method = "fdr")
  
  # 整理结果
  
  if (format == "wide") {
    
    cor <- acast(allresult, id2 ~ id1,
                 value.var = "cor", fun.aggregate = mean)
    cor <- cor[colnames(input2), colnames(input1)]
    cor
    
  } else if (format == "long") {
    allresult}
  
}


# 单对多相关性 ====================

cor_between_aB <- function(input1 = input1,
                           input2 = input2,
                           method = c("pearson")) {
  
  # 确保行名一致
  
  input2 <- input2[rownames(input1),]
  allresult = data.frame()
  
  # 开始循环
  
  for (j in colnames(input2)) {
    
    test <- cor.test(input1[,1], input2[,j], method = method)
    result <- data.frame(id = j,
                         cor = test$estimate,
                         pvalue = test$p.value)
    
    allresult <- rbind(allresult, result)
  }
  
  allresult
}



# 计算metacell =================================================================
# ==============================================================================

# 基于exp得到 metacell object ====================

metacell_object <- function(data = data,
                            resolution = 30,
                            cluster.name = "metacell") {
  library(Seurat)
  library(tibble)
  
  
  # 标准化 ----------
  
  data <- NormalizeData(data, scale.factor = 10000,
                        normalization.method = "LogNormalize")
  
  data <- FindVariableFeatures(data, nfeatures = 2000, 
                               selection.method = "vst")
  
  data <- ScaleData(data, features = VariableFeatures(data))
  
  
  # 进行聚类 ----------
  
  data <- RunPCA(data, assay = 'RNA', slot = 'scale.data')
  data <- FindNeighbors(data, dims = 1:20, k.param = 10, reduction = "pca")
  data <- FindClusters(data, resolution = resolution, n.iter = 10)
  
  # 重命名亚群名字 
  
  data$cluster <- paste0(cluster.name, "_", data$seurat_clusters)
  
  
  # 计算meta counts ----------
  
  info <- data.frame(id = colnames(data), metacell = data$cluster)
  counts <- GetAssayData(data, slot = "counts", assay = "RNA")
  
  metadata <- do.call(cbind, future_lapply(unique(info$metacell), function(i){
    cell <- info$id[info$metacell == i]
    metadata <- data.frame(rowSums(counts[,cell]))
    names(metadata) <- i
    metadata
  }, future.seed = TRUE))
  
  metadata <- as.matrix(metadata)
  metadata <- CreateSeuratObject(metadata)
  
  
  # 重新标准化并降维 ----------
  
  metadata <- NormalizeData(metadata, scale.factor = 10000,
                            normalization.method = "LogNormalize")
  
  metadata <- FindVariableFeatures(metadata, nfeatures = 2000, 
                                   selection.method = "vst")
  
  metadata <- ScaleData(metadata, features = VariableFeatures(data))
  
  # 进行聚类
  
  metadata <- RunPCA(metadata, assay = 'RNA', slot = 'scale.data',npcs = c(min(nrow(metadata), ncol(metadata)) - 1))
  metadata <- FindNeighbors(metadata, dims = 1:20, k.param = 20, reduction = "pca")
  metadata <- FindClusters(metadata, resolution = 0.5, n.iter = 10)
  
  # 重新降维
  
  metadata <- RunUMAP(metadata, dims = 1:20,
                      n.neighbors = 20, min.dist = 0.5, 
                      reduction = "pca", reduction.name = "umap")
  
  
  # 得到metacell与cell对应关系 ----------
  
  info <- data.frame(id = colnames(data), cluster = data$cluster)
  info <- do.call(rbind, lapply(unique(info$cluster), function(i){
    data.frame(cluster = i,
               cell_n = length(info$id[info$cluster == i]),
               cell_id = paste(info$id[info$cluster == i], collapse=","))
  }))
  
  info <- column_to_rownames(info, var = "cluster")
  
  
  # 整合metadata与注释 ----------
  
  metadata <- AddMetaData(metadata, info)
  metadata
}


# 整合exp - pro得到 metacell object ====================

metacell_multiomics <- function(data = data,
                                resolution = 50,
                                integ.method = "tvi", # tvi
                                cluster.name = "metacell") {
  library(Seurat)
  library(tibble)
  
  # 进行聚类 ----------
  
  # 运行之前确保已整合了wnn和totalvi的结果
  
  if (integ.method == "wnn") {
    
    data <- FindClusters(data, graph.name = "wsnn", n.iter = 50,
                         algorithm = 2, resolution = resolution)
    
  } else {
    
    data <- FindNeighbors(data, dims = 1:20, k.param = 10, reduction = "total")
    data <- FindClusters(data, algorithm = 2,
                         resolution = resolution, n.iter = 50)
    
  }
  
  # 重命名亚群名字 
  
  data$cluster <- paste0(cluster.name, "_", data$seurat_clusters)
  
  
  # 计算meta counts ----------
  
  info <- data.frame(id = colnames(data), metacell = data$cluster)
  counts <- GetAssayData(data, slot = "counts", assay = "RNA")
  
  metadata <- do.call(cbind, lapply(unique(info$metacell), function(i){
    cell <- info$id[info$metacell == i]
    metadata <- data.frame(rowSums(counts[,cell]))
    names(metadata) <- i
    metadata
  }))
  
  metadata <- as.matrix(metadata)
  metadata <- CreateSeuratObject(metadata)
  
  
  # 重新标准化并降维 ----------
  
  metadata <- NormalizeData(metadata, scale.factor = 10000,
                            normalization.method = "LogNormalize")
  
  metadata <- FindVariableFeatures(metadata, nfeatures = 2000, 
                                   selection.method = "vst")
  
  metadata <- ScaleData(metadata, features = VariableFeatures(data))
  
  # 进行聚类
  
  metadata <- RunPCA(metadata, assay = 'RNA', slot = 'scale.data')
  metadata <- FindNeighbors(metadata, dims = 1:20, k.param = 20, reduction = "pca")
  metadata <- FindClusters(metadata, resolution = 0.5, n.iter = 10)
  
  # 重新降维
  
  metadata <- RunUMAP(metadata, dims = 1:20,
                      n.neighbors = 20, min.dist = 0.5, 
                      reduction = "pca", reduction.name = "umap")
  
  
  # 得到metacell与cell对应关系 ----------
  
  info <- data.frame(id = colnames(data), cluster = data$cluster)
  info <- do.call(rbind, lapply(unique(info$cluster), function(i){
    data.frame(cluster = i,
               cell_n = length(info$id[info$cluster == i]),
               cell_id = paste(info$id[info$cluster == i], collapse=","))
  }))
  
  info <- column_to_rownames(info, var = "cluster")
  
  
  # 整合metadata与注释 ----------
  
  metadata <- AddMetaData(metadata, info)
  metadata
}



# 根据metacell object进行mapping ====================

metacell_object_pro <- function(metacell = metacell,
                                rawcell = rawcell) {
  
  # 提取metacell信息
  
  info <- metacell@meta.data
  info <- data.frame(metacell = rownames(info),
                     cell_id = info$cell_id)
  
  # 整理注释信息
  
  info <- do.call(rbind, lapply(info$metacell, function(i){
    cell_id <- unlist(strsplit(info$cell_id[info$metacell == i], ','))
    data.frame(id = cell_id, metacell = i)
  }))
  
  # 计算meta counts
  
  counts <- GetAssayData(rawcell, slot = "counts", assay = "RNA")
  metacount <- do.call(cbind, lapply(unique(info$metacell), function(i){
    cell <- info$id[info$metacell == i]
    counts <- data.frame(rowSums(counts[,cell])) # 求和
    names(counts) <- i
    counts
  }))
  
  # 计算meta data
  
  data <- GetAssayData(rawcell, slot = "data", assay = "RNA")
  metadata <- do.call(cbind, lapply(unique(info$metacell), function(i){
    cell <- info$id[info$metacell == i]
    data <- data.frame(rowMeans(data[,cell])) # 求平均
    names(data) <- i
    data
  }))
  
  # 构建seurat对象
  
  metacount <- as.matrix(metacount)
  metadata <- as.matrix(metadata)
  
  object <- CreateSeuratObject(metadata)
  object@assays[["RNA"]]@counts <- metacount
  object
}


# 返回一个过滤低表达基因的矩阵 ====================

metacell_aracne <- function(data = data,
                            resolution = 30,
                            cluster.name = "metacell",
                            filter.gene = TRUE){
  library(Seurat)
  library(tibble)
  
  # 标准化 ----------
  
  data <- NormalizeData(data, scale.factor = 10000,
                        normalization.method = "LogNormalize")
  
  data <- FindVariableFeatures(data, nfeatures = 2000, 
                               selection.method = "vst")
  
  data <- ScaleData(data, features = VariableFeatures(data))
  
  # 进行聚类 ----------
  
  data <- RunPCA(data, assay = 'RNA', slot = 'scale.data')
  data <- FindNeighbors(data, dims = 1:20, k.param = 10, reduction = "pca")
  data <- FindClusters(data, resolution = resolution, n.iter = 10)
  
  # 重命名亚群名字 
  
  data$cluster <- paste0(cluster.name, "_", data$seurat_clusters)
  
  # 计算bulk表达 ----------
  
  metadata <- AverageExpression(data, group.by = "cluster",
                                slot = "data", return.seurat = FALSE)[[1]]
  
  # 过滤低表达基因 ----------
  
  if (filter.gene == TRUE) {
    metadata[!((rowSums(metadata == 0) > 0.75*ncol(metadata))),]
  } else {
    metadata
  }
}



# NMF函数 ======================================================================
# ==============================================================================

# 得到nmf program ====================

consensus_nmf <- function(nmf_input = nmf_input,
                          ncore = length(nmf_input),
                          knumber = 5:10, topnumber = 100,
                          thres_freq = 2, thres_cor = 0.8) {
  
  library(data.table)
  library(reshape2)
  library(doParallel)
  library(foreach)
  
  cl <- makeCluster(ncore)      
  registerDoParallel(cl)
  getDoParWorkers()
  
  # 开始循环
  
  allnmf_integ <- foreach(j = names(nmf_input), 
                          .combine="c",
                          .packages = c("NMF", "plyr", "tibble")
  ) %dopar% {
    
    data <- nmf_input[[j]]
    
    
    # 开始进行NMF分析 ----------
    
    # NMF分析
    
    nmfdata <- lapply(knumber, function(i){
      nmfr <- nmf(data, rank = i, seed = 123, method = "snmf/r")
      
      program <- t(coef(nmfr))
      geneload <- basis(nmfr)
      
      colnames(program) <- paste0("A", i, "_", 1:i)
      colnames(geneload) <- paste0("A", i, "_", 1:i)
      c(cell = list(program), gene = list(geneload))
    })
    
    
    # 分别提取program和loading ----------
    
    cellp <- do.call(cbind, lapply(nmfdata, function(i){i$cell}))
    genel <- do.call(cbind, lapply(nmfdata, function(i){i$gene}))
    
    
    # 对program进行聚类 ----------
    
    cor <- cor(cellp)
    cor_b <- ifelse(cor > thres_cor, 1, 0)
    
    # 进行层次聚类
    
    dist <- as.dist(1-cor_b)
    hc <- hclust(d = dist, method = "average")
    
    # 得到cluster
    
    cluster <- data.frame(cluster = cutree(hc, h = 0.1), check.names = F)
    cluster <- rownames_to_column(cluster, var = "id")
    
    
    # 筛选重复出现的program ----------
    
    number <- data.frame(table(cluster$cluster), check.names = F)
    number$Var1 <- as.character(number$Var1)
    
    select <- number$Var1[number$Freq > thres_freq]
    cluster_flt <- cluster[cluster$cluster %in% select,]
    
    
    # 得到robust program ------------------------------
    
    # 重新mapping得到robust program的名字 ----------
    
    name1 <- unique(cluster_flt$cluster)
    name2 <- paste0("R", 1:length(name1), "_", j)
    
    cluster_flt <- cluster_flt[order(cluster_flt$cluster),]
    cluster_flt$cluster <- mapvalues(cluster_flt$cluster, name1, name2)
    
    # cellp的转换 ----------
    
    cellp <- t(scale(cellp))
    cellp <- data.frame(cellp, check.names = F)
    
    cellp <- rownames_to_column(cellp, var = "id")
    cellp <- merge(cluster_flt, cellp, by = "id")
    
    cellp <- cellp[,-1]
    cellp <- aggregate(cellp[,-1], by = list(cellp$cluster), FUN = mean)
    cellp <- column_to_rownames(cellp, var = "Group.1")
    cellp <- t(cellp) %>% data.frame(check.names = F)
    
    # genel的转换 ----------
    
    genel <- t(scale(genel))
    genel <- data.frame(genel, check.names = F)
    
    genel <- rownames_to_column(genel, var = "id")
    genel <- merge(cluster_flt, genel, by = "id")
    
    genel <- genel[,-1]
    genel <- aggregate(genel[,-1], by = list(genel$cluster), FUN = mean)
    genel <- column_to_rownames(genel, var = "Group.1")
    genel <- t(genel) %>% data.frame(check.names = F)
    
    
    # 结果可视化 ------------------------------
    
    # input <- cor[cluster_flt$id, cluster_flt$id]
    
    # Heatmap(input, col = col2, 
    #        show_row_names = F, show_column_names = F, 
    #        cluster_rows = T, show_row_dend = T,
    #        cluster_columns=T, show_column_dend = T)
    
    
    # 提取top基因 ------------------------------
    
    top_genes <- do.call(cbind, lapply(colnames(genel), function(i){
      
      data <- data.frame(gene = rownames(genel),
                         score = genel[,i], check.names = F)
      
      data <- data[order(data$score, decreasing = T),]
      data.frame(data$gene[1:topnumber], check.names = F)
    }))
    
    colnames(top_genes) <- colnames(genel)
    
    # 输出结果
    
    list(c(cell = list(cellp),
           gene = list(genel),
           topgene = list(t(top_genes))))
  }
  
  stopCluster(cl)
  names(allnmf_integ) <- names(nmf_input)
  allnmf_integ
}


# nmf结果多分类化 ====================

nmf_multi_cluster <- function(sigscore = sigscore,
                              thres = 0.75) {
  library(tibble)
  
  # signature基础表达水平
  
  sigscore_dich <- do.call(cbind, lapply(colnames(sigscore), function(i){
    thres <- quantile(sigscore[,i], probs = c(thres))
    ifelse(sigscore[,i] > thres, 1, 0)
  }))
  
  colnames(sigscore_dich) <- colnames(sigscore)
  rownames(sigscore_dich) <- rownames(sigscore)
  
  # 矩阵rank转换
  
  sigscore <- data.frame(sigscore)
  sigscore <- do.call(cbind, lapply(sigscore, rank, ties.method = "min"))
  colnames(sigscore) <- colnames(sigscore_dich)
  rownames(sigscore) <- rownames(sigscore_dich)
  
  # 开始注释
  
  anno_mp <- do.call(rbind, lapply(colnames(sigscore), function(i){
    
    cell1 <- rownames(sigscore_dich)[sigscore_dich[,i] == 1]
    cell2 <- rownames(sigscore)[do.call(c, lapply(rownames(sigscore), function(j){
      sigscore[j,i] - max(sigscore[j,!(colnames(sigscore)==i)]) > 0}))]
    data.frame(nmfclass = i, id = intersect(cell1, cell2))
  }))
  
  # 得到所有细胞
  
  allcell <- data.frame(id = rownames(sigscore))
  anno_mp <- merge(anno_mp, allcell, by = "id", all = T)
  anno_mp$nmfclass[is.na(anno_mp$nmfclass)] <- "none"
  
  anno_mp <- column_to_rownames(anno_mp, var = "id")
  anno_mp
}


# nmf结果二分类化 ====================

nmf_dicho_cluster <- function(sigscore = sigscore,
                              stem.select = select,
                              cluster.name = "stem",
                              thres = 0.75) {
  library(tibble)
  
  select <- intersect(stem.select, colnames(sigscore))
  remain.name <- paste0("non_", cluster.name)
  
  # signature基础表达水平
  
  thres <- quantile(sigscore[,select], probs = c(thres))
  cell1 <- rownames(sigscore)[sigscore[,select] > thres]
  
  # 矩阵rank转换
  
  row.name <- rownames(sigscore)
  sigscore <- data.frame(sigscore)
  sigscore <- do.call(cbind, lapply(sigscore, rank, ties.method = "min"))
  rownames(sigscore) <- row.name
  
  # 开始注释
  
  cell2 <- rownames(sigscore)[do.call(c, lapply(rownames(sigscore), function(j){
    sigscore[j,select] - max(sigscore[j,!(colnames(sigscore) == select)]) > 0}))]
  anno_mp <- data.frame(nmfclass = cluster.name, id = intersect(cell1, cell2))
  
  # 得到所有细胞
  
  allcell <- data.frame(id = rownames(sigscore))
  anno_mp <- merge(anno_mp, allcell, by = "id", all = T)
  anno_mp$nmfclass[is.na(anno_mp$nmfclass)] <- remain.name
  
  anno_mp <- column_to_rownames(anno_mp, var = "id")
  anno_mp
}



# signature分数计算 ============================================================
# ==============================================================================

# 计算普通情况的seurat分数 ====================

seurat_score <- function(data = data,
                         source = path,
                         geneset = "msigdb_hallmark",
                         min.sz = 10) {
  
  library(Seurat)
  library(tibble)
  
  # 处理注释信息 ----------
  
  if (is.null(geneset)) {
    
    sig_list <- read.table(source, sep = ",", header = F,
                           row.names = 1, na.strings = "")
    # 长宽转换
    
    sig_list <- lapply(rownames(sig_list), function(i){
      subdata <- t(sig_list[i,])[,1]
      subdata <- data.frame(term = i, gene = subdata)
    })
    
    sig_list <- do.call(rbind, sig_list)
    sig_list <- na.omit(sig_list)
    
    # 列表转换
    
    sig_list <- split(sig_list$gene, sig_list$term)
    
  } else {
    
    all_genesets <- readRDS(source)
    genesets <- reshape2::melt(all_genesets[[geneset]])
    sig_list <- split(genesets$value, genesets$L1)
    
  }
  
  # sig list过滤 ----------
  
  sig_list <- lapply(sig_list, function(i){
                     if (length(i) > min.sz) {i} else {NA}})
  
  sig_list <- sig_list[!is.na(sig_list)]
  
  # signature分数计算 ----------
  
  data <- AddModuleScore(data, sig_list, nbin = 30, 
                         ctrl = 100, name = names(sig_list))
  
  # 注释名字修改 ----------
  
  name <- colnames(data@meta.data)
  position <- length(name)-length(names(sig_list)) + 1
  colnames(data@meta.data)[position:length(name)] <- names(sig_list)
  
  # 提取signature分数 ----------
  
  sig <- data@meta.data
  sig <- sig[,position:length(name)]
}


# 计算metacell的seurat分数 ====================

metacell_score <- function(metacell = metacell,
                           rawcell = rawcell,
                           source = path,
                           geneset = "msigdb_hallmark",
                           min.sz = 2,
                           rownames = T) {
  
  library(Seurat)
  library(tibble)
  
  # 处理注释信息 ----------
  
  if (is.null(geneset)) {
    
    sig_list <- read.table(source, sep = ",", header = F,
                           row.names = 1, na.strings = "")
    # 长宽转换
    
    sig_list <- lapply(rownames(sig_list), function(i){
      subdata <- t(sig_list[i,])[,1]
      subdata <- data.frame(term = i, gene = subdata)
    })
    
    sig_list <- do.call(rbind, sig_list)
    sig_list <- na.omit(sig_list)
    
    # 列表转换
    
    sig_list <- split(sig_list$gene, sig_list$term)
    
  } else {
    
    all_genesets <- readRDS(source)
    genesets <- reshape2::melt(all_genesets[[geneset]])
    sig_list <- split(genesets$value, genesets$L1)
    
  }
  
  # sig list过滤 ----------
  
  sig_list <- lapply(sig_list, function(i){
                     if (length(i) > min.sz) {i} else {NA}})
  
  sig_list <- sig_list[!is.na(sig_list)]
  
  # 提取metacell信息 ----------
  
  info <- metacell@meta.data
  info <- data.frame(metacell = rownames(info),
                     cell_id = info$cell_id)
  # 整理注释信息
  
  info <- do.call(rbind, lapply(info$metacell, function(i){
    cell_id <- unlist(strsplit(info$cell_id[info$metacell == i], ','))
    data.frame(id = cell_id, metacell = i)
  }))
  
  # signature分数计算 ----------
  
  data <- AddModuleScore(rawcell, sig_list, nbin = 30, 
                         ctrl = 100, name = names(sig_list))
  # 注释名字修改
  
  name <- colnames(data@meta.data)
  position <- length(name)-length(names(sig_list)) + 1
  colnames(data@meta.data)[position:length(name)] <- names(sig_list)
  
  # 提取signature分数
  
  sig <- data@meta.data
  sig <- sig[,position:length(name)]
  sig <- rownames_to_column(sig, var = "id")
  
  # 整合数据 ----------
  
  score <- merge(sig, info, by = "id")
  score <- score[,-1]
  score <- aggregate(.~metacell, score, mean)
  
  # 结果整理
  
  if (rownames == T) {
    score <- column_to_rownames(score, var = "metacell")
  } else {names(score)[1] <- "id"}
  
  score
}



# NMF gene loading可视化 =======================================================
# ==============================================================================

# 只做单个图 ====================

loading_plot <- function(input = input,
                         topn = 15,
                         color = "#560047") {
  
  library(ggplot2)
  library(grid)
  library(dplyr)
  
  # 预处理输入数据
  
  input <- input[order(input$value),]
  input$number <- 1:nrow(input)
  input$number <- input$number / nrow(input)
  input <- input[order(input$value, decreasing = T),]
  
  # 选择注释基因
  
  select <- top_n(input, topn, value)
  y_min <- min(input$value)
  y_max <- max(input$value)
  top_genes <- select$id
  
  # 开始画图
  
  ggplot(input, aes(x = number, y = value)) + 
    geom_point(size = 1.5, colour = "grey90") + 
    geom_point(data = select, size = 3, color = color) + 
    
    annotate("text", x = 1.1, y = seq(
      y_max, y_min, length.out = topn)[1:length(top_genes)], 
      label = top_genes, hjust = 0, col = color, size = 4.5) + 
    coord_cartesian(xlim = c(0, 1), clip = "off") + 
    
    theme_bw() + 
    theme(panel.grid.major.x=element_blank(),
          panel.grid.minor.x=element_blank(),
          axis.text = element_text(colour = "black", size = 15),
          axis.text.x = element_blank(),
          axis.ticks.x = element_blank(),
          axis.title = element_text(colour = "black", size = 15),
          plot.margin = unit(c(1, 5, 1, 1), "lines"),
          panel.border = element_rect(fill = NA, color = "black", linewidth = 0.5)) + 
    labs(x = 'Genes', y= 'Gene loadings',title = '')
}


# 做所有图 ====================

loading_allplot <- function(data = data,
                            topn = 15,
                            color = "#560047") {
  
  library(ggplot2)
  library(grid)
  library(dplyr)
  
  lapply(colnames(data), function(i){
    input <- data.frame(id = rownames(data),
                        value = data[,i])
    
    # 预处理输入数据
    
    input <- input[order(input$value),]
    input$number <- 1:nrow(input)
    input$number <- input$number / nrow(input)
    input <- input[order(input$value, decreasing = T),]
    
    # 选择注释基因
    
    select <- top_n(input, topn, value)
    y_min <- min(input$value)
    y_max <- max(input$value)
    top_genes <- select$id
    
    # 开始画图
    
    ggplot(input, aes(x = number, y = value)) + 
      geom_point(size = 1.5, colour = "grey90") + 
      geom_point(data = select, size = 3, color = color) + 
      
      annotate("text", x = 1.1, y = seq(
        y_max, y_min, length.out = topn)[1:length(top_genes)], 
        label = top_genes, hjust = 0, col = color, size = 4.5) + 
      coord_cartesian(xlim = c(0, 1), clip = "off") + 
      
      theme_bw() + 
      theme(panel.grid.major.x=element_blank(),
            panel.grid.minor.x=element_blank(),
            axis.text = element_text(colour = "black", size = 15),
            axis.text.x = element_blank(),
            axis.ticks.x = element_blank(),
            axis.title = element_text(colour = "black", size = 15),
            plot.margin = unit(c(1, 5, 1, 1), "lines"),
            panel.border = element_rect(fill = NA, color = "black", linewidth = 0.5)) + 
      labs(x = 'Genes', y= 'Gene loadings',title = i)
  })
}


# 导出 gene loading 中的figure ====================

export_loadingplot <- function(all_plots = all_plots,
                               ncol = 5, 
                               output = name) {
  
  library(cowplot)
  
  if (ncol == 2) {
    
    height = round(length(all_plots)/2 + 0.35, 0) * 5
    all_plots <- plot_grid(plotlist = all_plots, ncol = 2)
    
    ggsave(output, all_plots, 
           width = 9, height = height, limitsize = FALSE)
    
  } else if (ncol == 3) {
    
    height = round(length(all_plots)/3 + 0.35, 0) * 5
    all_plots <- plot_grid(plotlist = all_plots, ncol = 3)
    
    ggsave(output, all_plots, 
           width = 12, height = height, limitsize = FALSE)
    
  } else if (ncol == 5) {
    
    height = round(length(all_plots)/5 + 0.35, 0) * 5
    all_plots <- plot_grid(plotlist = all_plots, ncol = 5)
    
    ggsave(output, all_plots, 
           width = 20, height = height, limitsize = FALSE)
  }
}



# loading plot2 ====================

loading_plot2 <- function(input = input,
                          color = "#560047",
                          topn = NULL,
                          marker = NULL,
                          label.size = 3,
                          decreasing = T,
                          output = NULL) {
  
  library(ggplot2)
  library(grid)
  library(dplyr)
  library(ggrepel)
  
  # 排除NA
  
  input <- na.omit(input)
  
  # 预处理输入数据
  
  input <- input[order(input$value, decreasing = decreasing),]
  input$number <- 1:nrow(input)
  input$number <- input$number / nrow(input)
  input <- input[order(input$value),]
  
  # 开始画图
  
  plot <- ggplot(input, aes(x = number, y = value)) + 
    geom_point(colour = "grey90") + 
    
    theme_bw() + 
    theme(panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          axis.text = element_text(colour = "black", size = 15),
          axis.text.x = element_blank(),
          axis.ticks.x = element_blank(),
          axis.title = element_text(colour = "black", size = 15),
          plot.margin = unit(c(1, 5, 1, 1), "lines"),
          panel.border = element_rect(fill = NA, color = "black",
                                      linewidth = 0.5)) + 
    labs(x = 'Genes', y= 'Gene loadings',title = '')
  
  # 加上marker基因
  
  if (!is.null(marker)) {
    
    select_gene <- input[input$id %in% marker,]
    plot <- plot + geom_point(data = select_gene,
                              size = 3,
                              alpha = 1,
                              colour = color) + 
      geom_text_repel(data = select_gene,
                      aes(number, value, label=id), size = label.size)
  }
  
  # 加上top基因
  
  if (!is.null(topn)) {
    
    topgene <- top_n(input, topn, value)
    
    plot <- plot + 
      geom_text_repel(data = topgene,
                      aes(number, value, label = id), size = label.size)
  }
  
  # 输出结果
  
  if (is.null(output)) {
    plot
  } else {
    ggsave(output, plot, dpi = 600, width = width, height = height)
  }
}



# Upset plot ===================================================================
# ==============================================================================

upset_plot <- function(input = input) {
  
  library(UpSetR)
  
  #setting colors
  #this can also be done with hexadecimal
  main_bar_col <- c("violetred4")
  sets_bar_col <- c("turquoise4")
  matrix_col <- c("slateblue4")
  shade_col <- c("wheat4")
  
  input <- data.frame(input)
  input <- lapply(input, function(i){na.omit(i)})
  
  upset(fromList(input),
        order.by = "freq",
        text.scale = 2,
        point.size = 3.5, 
        line.size = 1,
        main.bar.color = main_bar_col,
        sets.bar.color = sets_bar_col,
        matrix.color = matrix_col,
        shade.color = shade_col)
}



# scatter plot with highlight ==================================================
# ==============================================================================

# 标签散点图1 ====================

scatter_highlight <- function(input = input,
                              topn = 10,
                              color = "#560047") {
  
  library(ggplot2)
  library(ggrepel)
  
  # 保留原始xy轴名字
  
  names <- colnames(input)[2:3]
  
  # 预处理数据
  
  colnames(input)[1:3] <- c("id", "x", "y")
  input$score <- input$x * input$y
  select <- top_n(input, topn, score)
  
  median_x <- median(input$x)
  median_y <- median(input$y)
  
  # 开始画图
  
  ggplot(input, aes(x, y)) + 
    geom_point(size = 2, colour = "grey90") + 
    geom_point(data = select, size = 3, shape = 17, color = color) + 
    geom_text_repel(data = select, aes(label=id), 
                    segment.colour = "black", size = 4.5,
                    force = 1.2,  min.segment.length = 100) + 
    
    geom_vline(xintercept = median_x, color = "black", linetype = "dashed", lwd = 0.75) + 
    geom_hline(yintercept = median_y, color = "black", linetype = "dashed", lwd = 0.75) + 
    
    theme_bw() + 
    theme(panel.grid = element_blank(),
          axis.text = element_text(colour = "black", size = 15),
          axis.title = element_text(colour = "black", size = 15),
          panel.border = element_rect(fill = NA, color = "black", linewidth = 1)) + 
    labs(x = names[1], y= names[2], title = '')
}


# 标签散点图2 ====================

scatter_label <- function(input = input,
                          size.p = 3,
                          size.l = 5) {
  
  library(ggplot2)
  library(ggrepel)
  library(RColorBrewer)
  
  # 设定颜色
  
  if (nrow(input) < 30) {
    
    col <- c("#B8E3EA", "#5CB3DA", "#0070B2", "#FBDD7E", "#F7AE24", "#FF7149", 
             "#F2D7EE", "#A37CB7", "#A231A1", "#ECB2C8", "#E93B8C", "#B91372", 
             "#FF9F99", "#F15E4C", "#DA1735", "#CDE391", "#8BBE53", "#679436", 
             "#98D4C6", "#00A385", "#067D69", "#B2DBBF", "#028090", "#114B5F", 
             "#FBD0C0", "#CD6981", "#A23E48", "#CCDAD1", "#9CAEA9", "#788585")
  } else {
    
    col <- c("#343391","#0064af","#0090cc","#00b6db","#01b7c2",
             "#53c0a3","#8dcb8a","#bbd967","#fbd324","#f6bd25",
             "#f4a02e","#ed6f32","#ea5c2e","#d5452f","#c02e2f", "#8b2a21")
    
    col <- colorRampPalette(col)(nrow(input))
  }
  
  input$color <- col[1:nrow(input)]
  
  # 开始画图
  
  ggplot(input, aes(input[,2], input[,3])) + 
    geom_point(size = size.p, colour = input$color) + 
    geom_text_repel(aes(label = id),
                    force = 1.2, size = size.l,
                    min.segment.length = 100) + 
    
    theme_bw() + 
    theme(panel.grid = element_blank(),
          axis.text = element_text(colour = "black", size = 15),
          axis.title = element_text(colour = "black", size = 15),
          panel.border = element_rect(fill = NA, color = "black", linewidth = 1)) + 
    labs(x = names(input)[2], y= names(input)[3], title = '')
}



# 干性分数计算 =================================================================
# ==============================================================================

# 计算cytotrace ====================

cytotrace_sep <- function(datafilt = datafilt,
                          group.by = "cohort") {
  library(tibble)
  library(CytoTRACE)
  library(future.apply)
  
  # 分割数据
  
  datafilt <- SplitObject(datafilt, split.by = group.by)
  
  # 开始循环
  
  allscore <- lapply(names(datafilt), function(i){
    subfilt <- datafilt[[i]]
    
    if (ncol(subfilt) > 50000) {
      
      subfilt$group <- 1:ncol(subfilt)
      subfilt$group <- ntile(subfilt$group, n = 10)
      datafilt_split <- SplitObject(subfilt, split.by = "group")
      input <- do.call(cbind, lapply(datafilt_split, function(i){
        as.matrix(GetAssayData(i, slot = "counts", assay = "RNA"))}))
      
    } else {
      
      input <- GetAssayData(subfilt, slot = "counts",
                            assay = "RNA") %>% as.matrix()
    }
    
    # cytotrace计算
    
    score <- CytoTRACE(input, enableFast = TRUE, ncores = 20)
    score <- data.frame(id = names(score[["CytoTRACE"]]),
                        cytotrace = unname(score[["CytoTRACE"]]))
  })
  
  allscore <- do.call(rbind, allscore)
  allscore <- column_to_rownames(allscore, var = "id")
  allscore
}


# 计算metacell的cytotrace ====================

cytotrace_metacell <- function(metacell = metacell,
                               rawcell = rawcell) {
  
  library(CytoTRACE)
  library(tibble)
  
  input <- GetAssayData(rawcell, slot = "counts",
                        assay = "RNA") %>% as.matrix()
  
  # cytotrace计算
  
  score <- CytoTRACE(input, enableFast = FALSE)
  score <- data.frame(id = names(score[["CytoTRACE"]]),
                      cytotrace = unname(score[["CytoTRACE"]]))
  
  # 提取注释信息
  
  info <- metacell@meta.data
  info <- data.frame(metacell = rownames(info),
                     cell_id = info$cell_id)
  # 整理注释信息
  
  info <- do.call(rbind, lapply(info$metacell, function(i){
    cell_id <- unlist(strsplit(info$cell_id[info$metacell == i], ','))
    data.frame(id = cell_id, metacell = i)
  }))
  
  # 整合数据
  
  score <- merge(score, info, by = "id")
  score <- aggregate(score$cytotrace,
                     by = list(score$metacell), FUN = mean)
  
  names(score)[1:2] <- c("id", "cytotrace")
  score <- column_to_rownames(score, var = "id")
  score
}


# 计算mRNAsi ====================

mrnasi_score <- function(data = data,
                         path = path) {
  
  # 读入参考文件
  
  coef <- read.delim(path, header = FALSE, row.names = 1 ) %>%
    as.matrix() %>% drop()
  
  # 整合数据
  
  common <- intersect(rownames(data), names(coef))
  data <- data[common,]
  coef <- coef[rownames(data)]
  
  # 开始计算
  
  score <- apply(data, 2, function(z){cor(z, coef,
                                      method="sp", use="complete.obs")})
  score <- score - min(score)
  score <- score / max(score)
  data.frame(mRNAsi = score)
}


# 计算metacell的Cell entropy ====================

entropy_metacell <- function(metacell = metacell,
                             rawcell = rawcell) {
  
  library(vegan)
  library(tibble)
  
  input <- GetAssayData(rawcell, slot = "counts",
                        assay = "RNA") %>% as.matrix()
  
  # entropy计算
  
  score <- do.call(rbind, lapply(colnames(input), function(i){
    data <- input[,i]
    equ <- diversity(data)
    data.frame(id = i, entropy = equ)
  }))
  
  # 提取注释信息
  
  info <- metacell@meta.data
  info <- data.frame(metacell = rownames(info),
                     cell_id = info$cell_id)
  # 整理注释信息
  
  info <- do.call(rbind, lapply(info$metacell, function(i){
    cell_id <- unlist(strsplit(info$cell_id[info$metacell == i], ','))
    data.frame(id = cell_id, metacell = i)
  }))
  
  # 整合数据
  
  score <- merge(score, info, by = "id")
  score <- aggregate(score$entropy,
                     by = list(score$metacell), FUN = mean)
  
  names(score)[1:2] <- c("id", "entropy")
  score <- column_to_rownames(score, var = "id")
  score
}



# Diffusion map ================================================================
# ==============================================================================

# 降维并计算pseudotime ====================

diffusion_map <- function(datafilt = datafilt,
                          cluster = "cluster_wnn",
                          ref = "cytotrace", k = 100) {
  
  # 这段代码如果出现奇怪的报错请重启Rstudio后重新跑
  # Matrix v1.5.3没有问题，不需要重装
  
  library(Seurat)
  library(destiny)
  
  # 差异分析
  
  datafilt <- SetIdent(datafilt, value = cluster)
  diff <- FindAllMarkers(datafilt, test.use = 'LR',assay = "RNA",
                         slot = 'data', min.pct = 0.15)
  
  diff_flt <- diff[(diff$avg_log2FC > 0.25 & diff$p_val_adj < 0.05),]
  
  # 降维分析
  
  datafilt <- ScaleData(datafilt, features = unique(diff_flt$gene))
  datafilt <- RunPCA(datafilt, assay = 'RNA', slot = 'scale.data')
  
  # 提取表达数据 
  
  data <- Embeddings(datafilt, "pca")[,c(1:20)]
  
  # DiffusionMap降维
  
  sigmas <- find_sigmas(data, verbose = FALSE)
  dm <- DiffusionMap(data, sigma = optimal_sigma(sigmas),
                     rotate = TRUE, k = k, verbose = TRUE)
  
  # 判断起始细胞位置
  
  datafilt$pseudo_dm <- rank(eigenvectors(dm)[,1])
  
  # 计算DPT
  
  info <- datafilt@meta.data
  cor <- cor.test(info[,ref], info[,"pseudo_dm"])$estimate
  
  if (cor < 0) {
    
    dpt <- DPT(dm, tips = which(unname(datafilt$pseudo_dm == 1)))
    datafilt$dpt <- (rank(dpt$dpt)/length(dpt$dpt))
    
  } else {
    
    dpt <- DPT(dm, tips = which(unname(datafilt$pseudo_dm == 1)))
    datafilt$dpt <- 1-(rank(dpt$dpt)/length(dpt$dpt))
    
  }
  
  # 结果可视化
  
  dm1 <- eigenvectors(dm)[,c(1:2)]
  dm2 <- eigenvectors(dm)[,c(1:20)]
  datafilt[["dm"]] <- CreateDimReducObject(embeddings = dm1, key = "dm")
  datafilt[["dm_all"]] <- CreateDimReducObject(embeddings = dm2, key = "dm")
  datafilt
}


# feature trajectory ====================

feature_trajectory <- function(data = datafilt,
                               reduction = "umap",
                               pt.size = 1, 
                               color = "parula",
                               features = select) {
  
  library(Seurat)
  
  # 设定颜色
  
  if (color == "parula") {
    col <- colorRampPalette(c("#352A87","#343EB1","#1558D9","#036CE0","#107AD9",
                              "#1387D3","#0997D1","#06A4C9","#0CADBB","#23B4A9",
                              "#43BB97","#6ABE83","#8FBF73","#AEBD66","#CBBB5B",
                              "#E6B94F","#FDBE3C","#FBCF2C","#F5E21E","#F9FB0E"))(100)
    
  } else if (color == "kovesi") {
    col <- colorRampPalette(c("#1B0084","#1B099A","#1C14AE","#1C20C0","#1F2DCE",
                              "#233DD6","#2950CE","#2E68AB","#377989","#3F876A",
                              "#46954D","#53A036","#65AB26","#7BB41A","#95BE16",
                              "#AFC61C","#C6CE26","#DAD636","#EAE04E","#F1EC74",
                              "#F8F7AF","#FFFFFF"))(100)
    
  } else if (color == "ocean.haline") {
    col <- colorRampPalette(c("#2A186C","#2E1B87","#2B229F","#1D35A1","#11459A",
                              "#0C5294","#115D8F","#19678C","#22718A","#2B7A89",
                              "#328388","#388D88","#3E9886","#44A284","#4CAC80",
                              "#55B67A","#62BF72","#73C869","#8AD060","#A4D75C",
                              "#BEDC62","#D5E171","#EAE784","#FDEF9A"))(100)
    
  } else if (color == "ocean.dense") {
    col <- colorRampPalette(c("#360E24","#5D1A58","#723692","#795CC3",
                              "#7487E0", "#7EB0E4","#AAD2E3","#E6F1F1"))(100)
    
  } else if (color == "magma") {
    col <- c(colorRampPalette(c(magma(323, begin = 0.15)[1]))(10),
             magma(323, begin = 0.18))
    
  } else if (color == "white2blue") {
    col <- colorRampPalette(c("#FBF4F8","#E5E0ED","#BFC6DD","#8CADCC",
                              "#4E92BA","#1871A8","#085889","#003758"))(100)
    
  } else if (color == "blue2red") {
    col <- colorRampPalette(c("#0070b2","#009bc7","#5ec7dd",
                              "#b8e3ea","#f3f3f1","#fccdb9",
                              "#f79676","#f15e4c","#da1735"))(100)
    
  } else if (color == "rainbow") {
    col <- colorRampPalette(c("#343391","#0064af","#0090cc","#00b6db","#01b7c2",
                              "#53c0a3","#8dcb8a","#bbd967","#fbd324","#f6bd25",
                              "#f4a02e","#ed6f32","#ea5c2e","#d5452f","#c02e2f",
                              "#8b2a21"))(100)
  }
  
  value <- Embeddings(data, reduction)
  
  x_l = quantile(value[,1], probs = c(0.005), na.rm = T)
  x_h = quantile(value[,1], probs = c(0.995), na.rm = T)
  
  y_l = quantile(value[,2], probs = c(0.005), na.rm = T)
  y_h = quantile(value[,2], probs = c(0.995), na.rm = T)
  
  # 开始画图
  
  FeaturePlot(data, features = features, cols = col,
              reduction = reduction, ncol = 1,
              pt.size = pt.size, label = F, order = T) + 
    theme_bw() + 
    theme(panel.grid =element_blank(),
          axis.text = element_blank(),
          axis.title = element_blank(),
          axis.ticks = element_blank(),
          panel.border = element_blank()) + 
    
    scale_x_continuous(expand = c(0.01, 0.01)) +
    scale_y_continuous(expand = c(0.01, 0.01)) + 
    
    labs(x = 'UMAP1', y = 'UMAP2') + 
    xlim(x_l, x_h) + ylim(y_l, y_h)
}


# cluster trajectory ====================

cluster_trajectory <- function(data = datafilt,
                               reduction = "umap",
                               group.by = "nmfclass",
                               order = c("stem", "non_stem"),
                               pt.size = 1, label = F, 
                               features = select) {
  
  library(Seurat)
  
  value <- Embeddings(data, reduction)
  
  x_l = quantile(value[,1], probs = c(0.005), na.rm = T)
  x_h = quantile(value[,1], probs = c(0.995), na.rm = T)
  
  y_l = quantile(value[,2], probs = c(0.005), na.rm = T)
  y_h = quantile(value[,2], probs = c(0.995), na.rm = T)
  
  # 开始画图
  
  DimPlot(data, pt.size = pt.size, label = label, repel = T, 
          raster = FALSE, label.size = 5, reduction = reduction,
          order = order, cols = c("grey90", "#0070b2"),
          group.by = group.by) + 
    
    theme_bw() + 
    theme(panel.grid =element_blank(),
          axis.text = element_blank(),
          axis.title = element_blank(),
          axis.ticks = element_blank(),
          panel.border = element_blank(),
          legend.key.size = unit(1,'cm'),
          legend.text = element_text(size = 12),
          legend.title = element_blank()) + 
    
    scale_x_continuous(expand = c(0.01, 0.01)) +
    scale_y_continuous(expand = c(0.01, 0.01)) + 
    
    labs(x = 'UMAP1', y = 'UMAP2') + 
    xlim(x_l, x_h) + ylim(y_l, y_h) + 
    
    guides(colour = guide_legend(override.aes = list(size = 7.5)))
}




# 计算pseudotime相关基因 ====================

pseudotime_gene <- function(datafilt = datafilt,
                            slot = "scale.data",
                            varname = "dpt") {
  
  library(gam)
  
  subdata <- as.matrix(GetAssayData(datafilt,
                       slot = slot, assay = "RNA"))
  
  # 开始并行计算
  
  dpt_gene <- lapply(rownames(subdata), function(i){
    
    data <- data.frame(gene = subdata[i,],
                       dpt = datafilt@meta.data[,varname])
    
    tmp <- gam(gene ~ lo(dpt), data = data)
    data.frame(id = i,
               cor = cor.test(data$gene, data$dpt)$estimate,
               pvalue = summary(tmp)[4][[1]][1,5])
  })
  
  dpt_gene <- do.call(rbind, dpt_gene)
  dpt_gene <- na.omit(dpt_gene)
  
  # 矫正p值
  
  dpt_gene$FDR <- p.adjust(dpt_gene$pvalue, method = "fdr")
  dpt_gene
}


# trajectory 散点图 ====================

lineplot_trajectory <- function(datafilt = datafilt,
                                select = select,
                                varname = "dpt",
                                line.color = "#176EBF",
                                slot = "scale.data") {
  
  library(Seurat)
  library(ggplot2)
  
  # 提取表达数据
  
  data <- GetAssayData(datafilt, slot = slot, assay = "RNA")
  data <- t(as.matrix(data))
  select <- intersect(select, colnames(data))
  
  # 开始画图
  
  if (length(select) == 1) {
    
    # 整理数据
    
    input <- data.frame(gene = data[,select],
                        dpt = datafilt@meta.data[,varname])
    # 计算相关性系数
    
    cor <- round(cor.test(input$gene, input$dpt)$estimate, 2)
    
    # 开始画图
    
    ggplot(input, mapping = aes(x = dpt, y = gene)) + 
      geom_jitter(size = 3.5, alpha = 1, color = "grey90") + 
      geom_smooth(method = 'loess', se = F, span = 1,
                  color = line.color, linewidth = 1.5) + 
      
      theme_bw() + 
      theme(panel.grid = element_blank(),
            axis.text = element_text(colour = "black", size = 15),
            axis.title = element_text(colour = "black", size = 15),
            panel.border = element_rect(fill = NA, color = "black", linewidth = 1)) + 
      labs(x = 'DPT', y= 'Expression',title = '') + 
      
      scale_x_continuous(expand = c(0,0)) + # 不留边框
      scale_y_continuous(expand = c(0,0)) + 
      
      annotate(geom = "text", x = -Inf, y = Inf,
               hjust = -0.2, vjust = 3, size = 5,
               label = paste0("Coefficient: ", cor))
    
  } else {
    
    lapply(select, function(j){
      
      # 整理数据
      
      input <- data.frame(gene = data[,j],
                          dpt = datafilt@meta.data[,varname])
      # 计算相关性系数
      
      cor <- round(cor.test(input$gene, input$dpt)$estimate, 2)
      
      # 开始画图
      
      ggplot(input, mapping = aes(x = dpt, y = gene)) + 
        geom_jitter(size = 3.5, alpha = 1, color = "grey90") + 
        geom_smooth(method = 'loess', se = F, span = 1,
                    color = line.color, linewidth = 1.5) + 
        
        theme_bw() + 
        theme(panel.grid = element_blank(),
              axis.text = element_text(colour = "black", size = 15),
              axis.title = element_text(colour = "black", size = 15),
              panel.border = element_rect(fill = NA, color = "black", linewidth = 1)) + 
        labs(x = 'DPT', y= 'Expression',title = j) + 
        
        scale_x_continuous(expand = c(0,0)) + # 不留边框
        scale_y_continuous(expand = c(0,0)) + 
        
        annotate(geom = "text", x = -Inf, y = Inf,
                 hjust = -0.2, vjust = 3, size = 5,
                 label = paste0("Coefficient: ", cor))
    })
  }
}


# trajectory 热图 ====================

heatmap_trajectory <- function(input = input,
                               pdtime = pdtime,
                               pdtime.gene = pdtime.gene,
                               select.gene = select,
                               nbin = 50,
                               rownames = F) {
  library(ComplexHeatmap)
  library(dplyr)
  library(forcats)
  library(circlize)
  
  # 对基因进行排序
  
  pdtime.gene <- pdtime.gene[order(pdtime.gene$cor),]
  
  # 对细胞进行排序
  
  pdtime <- pdtime[order(pdtime$dpt),]
  
  # 提取热图矩阵
  
  inputdata <- input[pdtime.gene$id, pdtime$cell]
  
  # 矩阵划分成bins
  
  bin_anno <- data.frame(id = colnames(inputdata),
                         number = 1:ncol(inputdata))
  
  bin_number <- round(length(bin_anno$id)/nbin, 0)
  bin_anno <- bin_anno %>% mutate(bin = ntile(number, n = bin_number))
  
  inputdata <- data.frame(bin = bin_anno$bin, t(inputdata))
  inputdata <- aggregate(.~bin, inputdata, mean)
  inputdata <- t(inputdata[,-1])
  
  # 添加基因注释
  
  anno <- data.frame(id = pdtime.gene$id, type = pdtime.gene$cor)
  anno$type[anno$type > 0] <- "High"
  anno$type[anno$type < 0] <- "Low"
  anno$type <- fct_inorder(anno$type)
  
  ha_row <- HeatmapAnnotation(df = data.frame(anno[,2]),
                              show_legend = FALSE,
                              which = "row", show_annotation_name = F)
  
  # 添加pseudotime注释
  
  col <- rev(c("#360E24","#5D1A58","#723692","#795CC3",
               "#7487E0", "#7EB0E4","#AAD2E3","#E6F1F1"))
  
  col = colorRamp2(seq(from = 0, to = 100,
                       length.out = length(col)), col)
  
  ha_time = HeatmapAnnotation(time = seq(from = 0, to = 100,
                                         length.out = ncol(inputdata)),
                              col = list(time = col),
                              show_legend = FALSE)
  
  # 注释marker gene
  
  common <- intersect(rownames(inputdata), select.gene)
  mark_at <- which(rownames(inputdata) %in% common)
  ha_gene <- rowAnnotation(foo = anno_mark(at = mark_at, labels = common))
  
  # 标准化数据
  
  inputdata <- t(scale(t(inputdata)))
  
  # 颜色预处理
  
  all_value <- melt(inputdata, id.vars = c("value"))
  thres <- quantile(all_value$value, probs = c(0.01, 0.99))
  
  col <- colorRamp2(seq(from = thres[1], to = thres[2], length.out = 16),
                    c("#343391","#0064af","#0090cc","#00b6db",
                      "#01b7c2","#53c0a3","#8dcb8a","#bbd967",
                      "#fbd324","#f6bd25","#f4a02e","#ed6f32",
                      "#ea5c2e","#d5452f","#c02e2f","#8b2a21"))
  # 开始画热图
  
  if (rownames == T) {
    
    draw(Heatmap(inputdata, col = col, 
                 name = "Z-score", 
                 left_annotation = ha_row, 
                 top_annotation = ha_time,
                 use_raster = TRUE, raster_quality = 0.01,
                 column_gap = unit(0, "mm"), row_gap = unit(0, "mm"),
                 border = "#404040",  
                 show_row_names = rownames, 
                 show_column_names = F, column_names_rot = 0, 
                 row_split = anno$type,
                 cluster_rows = F, show_row_dend = F,
                 cluster_columns = F, show_column_dend = F,
                 heatmap_legend_param = list(
                   legend_direction = "horizontal", 
                   legend_width = unit(6, "cm"))),
         heatmap_legend_side = "bottom")
    
  } else {
    
    draw(Heatmap(inputdata, col = col, 
                 name = "Z-score", 
                 left_annotation = ha_row, 
                 right_annotation = ha_gene, 
                 top_annotation = ha_time,
                 use_raster = TRUE, raster_quality = 0.01,
                 column_gap = unit(0, "mm"), row_gap = unit(0, "mm"),
                 border = "#404040",  
                 show_row_names = rownames, 
                 show_column_names = F, column_names_rot = 0, 
                 row_split = anno$type,
                 cluster_rows = F, show_row_dend = F,
                 cluster_columns = F, show_column_dend = F,
                 heatmap_legend_param = list(
                   legend_direction = "horizontal", 
                   legend_width = unit(6, "cm"))),
         heatmap_legend_side = "bottom")
    
  }
}


# GSVA分析 ====================

GSVA_seurat <- function(datafilt = datafilt,
                        source = path,
                        geneset = "msigdb_hallmark",
                        method = "gsva") {
  
  library(GSVA)
  
  # 准备基因注释文件
  
  all_genesets <- readRDS(source)
  genesets <- reshape2::melt(all_genesets[[geneset]])
  genesets <- split(genesets$value, genesets$L1)
  
  # 提取表达数据
  
  data <- GetAssayData(datafilt, slot = "data", assay = "RNA")
  data <- as.matrix(data)
  
  # 开始计算分数
  
  scores <- gsva(data, genesets, 
                 min.sz = 2, max.sz = 500, 
                 method = method, parallel.sz = 16,
                 verbose = TRUE)
  
  CreateSeuratObject(scores)
}



# Cell cycle ===================================================================
# ==============================================================================

# 计算cellcycle ====================

cellcycle_seurat <- function(datafilt = datafilt) {
  
  library(Seurat)
  library(sceasy)
  library(tricycle)
  library(tibble)
  
  # seurat注释cellcycle ----------
  
  datafilt <- CellCycleScoring(datafilt,
                               s.features = cc.genes$s.genes,
                               g2m.features = cc.genes$g2m.genes,
                               set.ident = TRUE)
  
  datafilt$cyc_seu <- ifelse(datafilt$Phase == "G1",
                             "non-cycling", "cycling")
  
  cyc_seu <- data.frame(id = colnames(datafilt),
                        G2M_score = datafilt$G2M.Score,
                        S_score = datafilt$S.Score,
                        cyc_seu = datafilt$cyc_seu)
  
  # tricycle注释cellcycle ----------
  
  scedata <- convertFormat(datafilt, from = "seurat", to = "sce")
  
  # 开始计算
  
  scedata <- project_cycle_space(scedata,
             gname.type = c("SYMBOL"), species = c( "human"))
  scedata <- estimate_cycle_position(scedata)
  
  # 结果整理
  
  tricycle <- data.frame(id = colnames(scedata),
                         tricycle = scedata$tricyclePosition / 3.1415926)
  
  tricycle$cyc_tri <- ifelse(tricycle$tricycle > 1.5 |
                      tricycle$tricycle < 0.5, "non-cycling", "cycling")
  tricycle <- tricycle[,-2]
  
  # 结果总结 ----------
  
  cycle <- merge(cyc_seu, tricycle, by = "id")
  cycle <- column_to_rownames(cycle, var = "id")
  cycle
}


# 计算prolif分数 ====================

prolif_seurat <- function(datafilt = datafilt) {
  
  library(Seurat)
  library(tibble)
  
  # 处理注释信息 ----------
  
  select <- c("ZWINT", "E2F1", "FEN1", "FOXM1", "H2AFZ", "HMGB2",
              "MCM2", "MCM3", "MCM4", "MCM5", "MCM6", "MKI67",
              "MYBL2", "PCNA", "PLK1", "CCND1", "AURKA", "BUB1",
              "TOP2A", "TYMS", "DEK", "CCNB1", "CCNE1")
  
  sig_list <- list(prolif_score = c(select))
  
  # signature分数计算 ----------
  
  data <- AddModuleScore(datafilt, sig_list, nbin = 30, 
                         ctrl = 100, name = names(sig_list))
  
  # 提取signature分数
  
  sig <- data@meta.data
  sig <- data.frame(id = rownames(sig), prolif_score = sig$prolif_score1)
  
  # 整合数据
  
  sig <- column_to_rownames(sig, var = "id")
  sig
}


# 计算metacell的prolif分数 ====================

prolif_metacell <- function(metacell = metacell,
                            rawcell = rawcell) {
  library(Seurat)
  library(tibble)
  
  # 处理注释信息 ----------
  
  select <- c("ZWINT", "E2F1", "FEN1", "FOXM1", "H2AFZ", "HMGB2",
              "MCM2", "MCM3", "MCM4", "MCM5", "MCM6", "MKI67",
              "MYBL2", "PCNA", "PLK1", "CCND1", "AURKA", "BUB1",
              "TOP2A", "TYMS", "DEK", "CCNB1", "CCNE1")
  
  sig_list <- list(prolif_score = c(select))
  
  # 提取metacell信息 ----------
  
  info <- metacell@meta.data
  info <- data.frame(metacell = rownames(info),
                     cell_id = info$cell_id)
  # 整理注释信息
  
  info <- do.call(rbind, lapply(info$metacell, function(i){
    cell_id <- unlist(strsplit(info$cell_id[info$metacell == i], ','))
    data.frame(id = cell_id, metacell = i)
  }))
  
  # signature分数计算 ----------
  
  data <- AddModuleScore(rawcell, sig_list, nbin = 30, 
                         ctrl = 100, name = names(sig_list))
  
  # 提取signature分数
  
  sig <- data@meta.data
  sig <- data.frame(id = rownames(sig), prolif_score = sig$prolif_score1)
  
  # 整合数据 ----------
  
  score <- merge(sig, info, by = "id")
  score <- score[,-1]
  score <- aggregate(.~metacell, score, mean)
  
  score <- column_to_rownames(score, var = "metacell")
  score
}


# 计算正常情况的prolif分数 ====================

prolif_score <- function(datafilt = datafilt) {
  
  library(Seurat)
  library(tibble)
  
  # 处理注释信息 ----------
  
  select <- c("ZWINT", "E2F1", "FEN1", "FOXM1", "H2AFZ", "HMGB2",
              "MCM2", "MCM3", "MCM4", "MCM5", "MCM6", "MKI67",
              "MYBL2", "PCNA", "PLK1", "CCND1", "AURKA", "BUB1",
              "TOP2A", "TYMS", "DEK", "CCNB1", "CCNE1")
  
  sig_list <- list(prolif_score = c(select))
  
  # signature分数计算 ----------
  
  datafilt <- AddModuleScore(datafilt, sig_list, nbin = 30, 
                             ctrl = 100, name = names(sig_list))
  
  # 提取signature分数
  
  sig <- datafilt@meta.data
  data.frame(id = rownames(sig), prolif_score = sig$prolif_score1)
}



# 密度图 =======================================================================
# ==============================================================================

# 密度流式图 ====================

dense_cytometry <- function(input = input,
                            pt.size = 0.75,
                            color = "rainbow",
                            median.thres = T,
                            density.bin = 30,
                            density.h = 0.7,
                            xcutoff = 0.5, ycutoff = 0.75) {
  library(ggplot2)
  
  input <- input
  
  # 设定颜色
  
  if (color == "parula") {
    col <- colorRampPalette(c("#352A87","#343EB1","#1558D9","#036CE0","#107AD9",
                              "#1387D3","#0997D1","#06A4C9","#0CADBB","#23B4A9",
                              "#43BB97","#6ABE83","#8FBF73","#AEBD66","#CBBB5B",
                              "#E6B94F","#FDBE3C","#FBCF2C","#F5E21E","#F9FB0E"))(100)
    
  } else if (color == "kovesi") {
    col <- colorRampPalette(c("#1B0084","#1B099A","#1C14AE","#1C20C0","#1F2DCE",
                              "#233DD6","#2950CE","#2E68AB","#377989","#3F876A",
                              "#46954D","#53A036","#65AB26","#7BB41A","#95BE16",
                              "#AFC61C","#C6CE26","#DAD636","#EAE04E","#F1EC74",
                              "#F8F7AF","#FFFFFF"))(100)
    
  } else if (color == "ocean.haline") {
    col <- colorRampPalette(c("#2A186C","#2E1B87","#2B229F","#1D35A1","#11459A",
                              "#0C5294","#115D8F","#19678C","#22718A","#2B7A89",
                              "#328388","#388D88","#3E9886","#44A284","#4CAC80",
                              "#55B67A","#62BF72","#73C869","#8AD060","#A4D75C",
                              "#BEDC62","#D5E171","#EAE784","#FDEF9A"))(100)
    
  } else if (color == "ocean.dense") {
    col <- colorRampPalette(c("#360E24","#5D1A58","#723692","#795CC3",
                              "#7487E0", "#7EB0E4","#AAD2E3","#E6F1F1"))(100)
    
  } else if (color == "magma") {
    col <- c(colorRampPalette(c(magma(323, begin = 0.15)[1]))(10),
             magma(323, begin = 0.18))
    
  } else if (color == "white2blue") {
    col <- colorRampPalette(c("#FBF4F8","#E5E0ED","#BFC6DD","#8CADCC",
                              "#4E92BA","#1871A8","#085889","#003758"))(100)
    
  } else if (color == "blue2red") {
    col <- colorRampPalette(c("#0070b2","#009bc7","#5ec7dd",
                              "#b8e3ea","#f3f3f1","#fccdb9",
                              "#f79676","#f15e4c","#da1735"))(100)
    
  } else if (color == "rainbow") {
    col <- colorRampPalette(c("#343391","#0064af","#0090cc","#00b6db","#01b7c2",
                              "#53c0a3","#8dcb8a","#bbd967","#fbd324","#f6bd25",
                              "#f4a02e","#ed6f32","#ea5c2e","#d5452f","#c02e2f",
                              "#8b2a21"))(100)
  }
  
  
  # 密度散点图可视化 ----------
  
  get_density <- function(x, y, ...) {
    dens <- MASS::kde2d(x, y, ...)
    ix <- findInterval(x, dens$x)
    iy <- findInterval(y, dens$y)
    ii <- cbind(ix, iy)
    return(dens$z[ii])
  }
  
  # 计算每个点密度
  
  input$dens <- get_density(input[,1], input[,2], n = 1000)
  input$dens <- input$dens / max(input$dens)
  
  
  # 计算占比 ----------
  
  if (median.thres == T) {
    xcutoff <- median(input[,1])
    ycutoff <- median(input[,2])
  }
  
  L_up <- round(sum(input[,1] < xcutoff & input[,2] > ycutoff) * 100 / nrow(input), 2)
  L_dn <- round(sum(input[,1] < xcutoff & input[,2] < ycutoff) * 100 / nrow(input), 2)
  R_up <- round(sum(input[,1] > xcutoff & input[,2] > ycutoff) * 100 / nrow(input), 2)
  R_dn <- round(sum(input[,1] > xcutoff & input[,2] < ycutoff) * 100 / nrow(input), 2)
  
  
  # 开始画图 ----------
  
  ggplot(input, aes(input[,1], input[,2])) +
    
    geom_density2d(size = 0.35, alpha = 0.1,
                   colour = "black", bins = density.bin, h = density.h) + 
    geom_point(aes(color = dens), size = pt.size) + 
    
    # 整体风格
    
    theme_bw() + 
    theme(panel.grid = element_blank(),
          axis.text = element_text(colour = "black", size = 15),
          axis.title = element_text(colour = "black", size = 15),
          panel.border = element_rect(fill = NA, color = "black", linewidth = 1)) + 
    labs(x = colnames(input)[1], y = colnames(input)[2], title = '') + 
    scale_color_gradientn(colors = col) + 
    
    scale_x_continuous(expand = c(0,0)) + # 不留边框
    scale_y_continuous(expand = c(0,0)) + 
    
    # 添加分割线
    
    geom_vline(xintercept = xcutoff, color = "black", linetype = "dashed", lwd = 0.75) + 
    geom_hline(yintercept = ycutoff, color = "black", linetype = "dashed", lwd = 0.75) + 

    # 添加标签
    
    annotate(geom = "text", x = -Inf, y = Inf, size = 5,
             hjust = -0.2, vjust = 2, label = paste0("L up: ", L_up, "%")) + 
    annotate(geom = "text", x = -Inf, y = -Inf, size = 5, 
             hjust = -0.2, vjust = -2, label = paste0("L dn: ", L_dn, "%")) + 
    annotate(geom = "text", x = Inf, y = Inf, size = 5, 
             hjust = 1.2, vjust = 2, label = paste0("R up: ", R_up, "%")) + 
    annotate(geom = "text", x = Inf, y = -Inf, size = 5, 
             hjust = 1.2, vjust = -2, label = paste0("R dn: ", R_dn, "%")) + 
    guides(col = guide_none())
}


# 密度流式图2 ====================

dense_cytometry2 <- function(input = input,
                             pt.size = 0.75,
                             median.thres = T,
                             density.bin = 30,
                             density.h = 0.7) {
  library(ggplot2)
  
  input <- input
  
  # 开始画图 ----------
  
  ggplot(input, aes(input[,1], input[,2])) +
    
    geom_density2d(size = 0.35, alpha = 0.1,
                   colour = "black", bins = density.bin, h = density.h) + 
    geom_point(size = pt.size) + 
    
    # 整体风格
    
    theme_bw() + 
    theme(panel.grid = element_blank(),
          axis.text = element_text(colour = "black", size = 15),
          axis.title = element_text(colour = "black", size = 15),
          panel.border = element_rect(fill = NA, color = "black", linewidth = 1)) + 
    labs(x = colnames(input)[1], y = colnames(input)[2], title = '') + 
    scale_color_gradientn(colors = col) + 
    
    scale_x_continuous(expand = c(0,0)) + # 不留边框
    scale_y_continuous(expand = c(0,0)) + 
    guides(col = guide_none())
}


# 密度流式图3 ====================

dense_cytometry3 <- function(input = input,
                             pt.size = 0.75,
                             median.thres = T,
                             density.bin = 30,
                             density.h = 0.7,
                             xcutoff = 0.5, ycutoff = 0.75) {
  library(ggplot2)
  input <- input
  
  
  # 计算占比 ----------
  
  if (median.thres == T) {
    xcutoff <- median(input[,1])
    ycutoff <- median(input[,2])
  }
  
  L_up <- round(sum(input[,1] < xcutoff & input[,2] > ycutoff) * 100 / nrow(input), 2)
  L_dn <- round(sum(input[,1] < xcutoff & input[,2] < ycutoff) * 100 / nrow(input), 2)
  R_up <- round(sum(input[,1] > xcutoff & input[,2] > ycutoff) * 100 / nrow(input), 2)
  R_dn <- round(sum(input[,1] > xcutoff & input[,2] < ycutoff) * 100 / nrow(input), 2)
  
  
  # 开始画图 ----------
  
  ggplot(input, aes(input[,1], input[,2])) +
    
    stat_density2d(aes(alpha = ..level.., fill = ..level..),
                   contour_var = "ndensity",
                   bins = 50, h = density.h, geom = "polygon") + 
    
    geom_density2d(size = 0.1, colour = "black", alpha = 0.7,
                   contour_var = "ndensity",
                   bins = density.bin,
                   h = density.h) + 
    
    scale_fill_gradientn(colours = rev(c("#360E24","#5D1A58","#723692","#795CC3",
                                         "#7487E0", "#7EB0E4","#AAD2E3","#E6F1F1"))) +
    
    # 整体风格
    
    theme_bw() + 
    theme(panel.grid = element_blank(),
          axis.text = element_text(colour = "black", size = 15),
          axis.title = element_text(colour = "black", size = 15),
          panel.border = element_rect(fill = NA, color = "black", linewidth = 1)) + 
    labs(x = colnames(input)[1], y = colnames(input)[2], title = '') + 
    scale_color_gradientn(colors = col) + 
    
    scale_x_continuous(expand = c(0,0)) + # 不留边框
    scale_y_continuous(expand = c(0,0)) + 
    
    # 添加分割线
    
    geom_vline(xintercept = xcutoff, color = "black", linetype = "dashed", lwd = 0.75) + 
    geom_hline(yintercept = ycutoff, color = "black", linetype = "dashed", lwd = 0.75) + 
    
    # 添加标签
    
    annotate(geom = "text", x = -Inf, y = Inf, size = 5,
             hjust = -0.2, vjust = 2, label = paste0("L up: ", L_up, "%")) + 
    annotate(geom = "text", x = -Inf, y = -Inf, size = 5, 
             hjust = -0.2, vjust = -2, label = paste0("L dn: ", L_dn, "%")) + 
    annotate(geom = "text", x = Inf, y = Inf, size = 5, 
             hjust = 1.2, vjust = 2, label = paste0("R up: ", R_up, "%")) + 
    annotate(geom = "text", x = Inf, y = -Inf, size = 5, 
             hjust = 1.2, vjust = -2, label = paste0("R dn: ", R_dn, "%")) + 
    guides(col = guide_none())
}


# 密度分类图 ====================

dense_cluster <- function(input = input,
                          pt.size = 0.75,
                          cluster = "nmfclass",
                          median.thres = T,
                          density.bin = 30,
                          density.h = 0.7,
                          xcutoff = 0.5, ycutoff = 0.75) {
  library(ggplot2)
  
  input <- input
  names(input)[names(input) == cluster] <- "cluster"
  
  
  # 设定颜色 ----------
  
  mycol <- c("#0070B2", "#5CB3DA", "#B8E3EA", "#DA1735", "#F15E4C", "#FF9F99",
             "#A231A1", "#A37CB7", "#F2D7EE", "#B91372", "#E93B8C", "#ECB2C8",
             "#FF7149", "#F7AE24", "#FBDD7E", "#679436", "#8BBE53", "#CDE391",
             "#067D69", "#00A385", "#98D4C6", "#114B5F", "#028090", "#B2DBBF",
             "#A23E48", "#CD6981", "#FBD0C0", "#788585", "#9CAEA9", "#CCDAD1")
  
  
  # 计算占比 ----------
  
  if (median.thres == T) {
    xcutoff <- median(input[,1])
    ycutoff <- median(input[,2])
  }
  
  L_up <- round(sum(input[,1] < xcutoff & input[,2] > ycutoff) * 100 / nrow(input), 2)
  L_dn <- round(sum(input[,1] < xcutoff & input[,2] < ycutoff) * 100 / nrow(input), 2)
  R_up <- round(sum(input[,1] > xcutoff & input[,2] > ycutoff) * 100 / nrow(input), 2)
  R_dn <- round(sum(input[,1] > xcutoff & input[,2] < ycutoff) * 100 / nrow(input), 2)
  
  
  # 开始画图 ----------
  
  ggplot(input, aes(input[,1], input[,2])) +
    
    geom_density2d(size = 0.35, alpha = 0.1,
                   colour = "black", bins = density.bin, h = density.h) + 
    geom_point(aes(color = cluster), size = pt.size) + 
    
    # 整体风格
    
    theme_bw() + 
    theme(panel.grid = element_blank(),
          axis.text = element_text(colour = "black", size = 15),
          axis.title = element_text(colour = "black", size = 15),
          panel.border = element_rect(fill = NA, color = "black", linewidth = 1)) + 
    labs(x = colnames(input)[1], y = colnames(input)[2], title = '') + 
    scale_color_manual(values = c(sample(mycol))) + 
    
    scale_x_continuous(expand = c(0,0)) + # 不留边框
    scale_y_continuous(expand = c(0,0)) + 
    
    # 添加分割线
    
    geom_vline(xintercept = xcutoff, color = "black", linetype = "dashed", lwd = 0.75) + 
    geom_hline(yintercept = ycutoff, color = "black", linetype = "dashed", lwd = 0.75) + 
    
    # 添加标签
    
    annotate(geom = "text", x = -Inf, y = Inf, size = 5,
             hjust = -0.2, vjust = 2, label = paste0("L up: ", L_up, "%")) + 
    annotate(geom = "text", x = -Inf, y = -Inf, size = 5, 
             hjust = -0.2, vjust = -2, label = paste0("L dn: ", L_dn, "%")) + 
    annotate(geom = "text", x = Inf, y = Inf, size = 5, 
             hjust = 1.2, vjust = 2, label = paste0("R up: ", R_up, "%")) + 
    annotate(geom = "text", x = Inf, y = -Inf, size = 5, 
             hjust = 1.2, vjust = -2, label = paste0("R dn: ", R_dn, "%")) + 
    
    guides(colour = guide_legend(title = NULL,
                                 override.aes = list(size = 7.5)))
}



# 箱线图 =======================================================================
# ==============================================================================

# 箱线图做法1 ====================

common_boxplot <- function(input = input,
                           output = name,
                           show.point = TRUE,
                           method = "t.test",
                           width = 3.5, height = 5) {
  
  library(ggbeeswarm)
  library(ggplot2)
  library(ggpubr)
  
  input <- input
  
  # 整理输入数据
  
  value1 = quantile(input$value, probs = c(0.005), na.rm = T)
  value2 = quantile(input$value, probs = c(0.98), na.rm = T)
  
  # 设定颜色
  
  col <- c("#0070B2", "#5CB3DA", "#B8E3EA", "#DA1735", "#F15E4C", "#FF9F99",
           "#A231A1", "#A37CB7", "#F2D7EE", "#B91372", "#E93B8C", "#ECB2C8",
           "#FF7149", "#F7AE24", "#FBDD7E", "#679436", "#8BBE53", "#CDE391",
           "#067D69", "#00A385", "#98D4C6", "#114B5F", "#028090", "#B2DBBF",
           "#A23E48", "#CD6981", "#FBD0C0", "#788585", "#9CAEA9", "#CCDAD1")
  
  # 开始画图
  
  if (show.point == TRUE) {
    
    plot <- ggplot(input, aes(x = type, y = value, fill = type)) +
      stat_boxplot(geom = "errorbar", width = 0, color = "black") +
      geom_boxplot(alpha = 1, outlier.shape = NA, size = 0.7, width = 0.7) + 
      
      geom_quasirandom(width = 0.3, size = 2, alpha = 0.2) + 
      scale_fill_manual(values=c("#FBD324", "#A37CB7", sample(col))) + 
      
      stat_compare_means(method = method, size = 5,
                         label.x = 1.1, label.y = 0.99*max(input$value)) + 
      
      theme_bw() + 
      theme(panel.grid = element_blank(),
            legend.position = "none", # 去除图例
            axis.text = element_text(colour = "black", size = 15), 
            axis.title = element_text(colour = "black", size = 15),
            panel.border = element_rect(fill = NA, color = "black", linewidth = 1)) + 
      labs(x = '', y= 'Gene activity',title = '')
    
  } else {
    
    plot <- ggplot(input, aes(x = type, y = value, fill = type)) +
      stat_boxplot(geom = "errorbar", width = 0.1, color = "black") +
      geom_boxplot(alpha = 1, outlier.shape = NA, size = 0.7, width = 0.7) + 
      scale_fill_manual(values = c("#FBD324", "#A37CB7", sample(col))) + 
      
      stat_compare_means(method = method, size = 5,
                         label.x = 1.1, label.y = 0.99*value2) + 
      
      theme_bw() + 
      theme(panel.grid = element_blank(),
            legend.position = "none", # 去除图例
            axis.text = element_text(colour = "black", size = 15), 
            axis.title = element_text(colour = "black", size = 15),
            panel.border = element_rect(fill = NA, color = "black", linewidth = 1)) + 
      labs(x = '', y= 'Gene activity',title = '') + 
      coord_cartesian(ylim = c(value1, value2)) # 限制坐标轴高度
  }
  
  # 输出结果
  
  if (is.null(output)) {
    plot
  } else {
    ggsave(output, plot, width = width, height = height)
  }
  
}


# 箱线图改进做法 ====================

common_boxplot_v2 <- function(input = input,
                              output = name,
                              show.point = TRUE,
                              ylim = ylim,
                              width = 3.5, height = 5) {
  
  library(ggbeeswarm)
  library(ggplot2)
  library(ggpubr)
  
  input <- input
  
  # 设定颜色
  
  col <- c("#0070B2", "#5CB3DA", "#B8E3EA", "#DA1735", "#F15E4C", "#FF9F99",
           "#A231A1", "#A37CB7", "#F2D7EE", "#B91372", "#E93B8C", "#ECB2C8",
           "#FF7149", "#F7AE24", "#FBDD7E", "#679436", "#8BBE53", "#CDE391",
           "#067D69", "#00A385", "#98D4C6", "#114B5F", "#028090", "#B2DBBF",
           "#A23E48", "#CD6981", "#FBD0C0", "#788585", "#9CAEA9", "#CCDAD1")
  
  # 开始画图
  
  plot <- ggplot(input, aes(x = type, y = value, fill = type)) +
    stat_boxplot(geom = "errorbar", width = 0.1, color = "black") +
    geom_boxplot(alpha = 1, outlier.shape = NA, size = 0.7, width = 0.7) + 
    geom_quasirandom(width = 0.3, size = 2, alpha = 0.2) + 
    scale_fill_manual(values = c("grey85", "grey50", sample(col))) + 
    
    stat_compare_means(method = "t.test", size = 5,
                       label.x = 1.05, label.y = 0.9*ylim[2]) + 
    
    theme_bw() + 
    theme(panel.grid = element_blank(),
          legend.position = "none", # 去除图例
          axis.text = element_text(colour = "black", size = 15), 
          axis.title = element_text(colour = "black", size = 15),
          plot.title = element_text(size = 16),
          panel.border = element_rect(fill = NA, color = "black", linewidth = 1)) + 
    labs(x = '', y= 'Correlation',title = '') + 
    coord_cartesian(ylim = ylim) # 限制坐标轴高度
  
  # 输出结果
  
  if (is.null(output)) {
    plot
  } else {
    ggsave(output, plot, width = width, height = height)
  }
  
}



# 箱线图做法2 ====================

common_boxplot2 <- function(input = input,
                            output = name,
                            show.point = TRUE, order = TRUE,
                            decreasing = TRUE, rotate = 45,
                            width = 7, height = 5) {
  
  library(ggbeeswarm)
  library(ggplot2)
  library(ggpubr)
  
  input <- input
  
  # 整理输入数据
  
  value1 = quantile(input$value, probs = c(0.005), na.rm = T)
  value2 = quantile(input$value, probs = c(0.995), na.rm = T)
  
  # 设定颜色
  
  col <- c("#0070B2", "#5CB3DA", "#B8E3EA", "#DA1735", "#F15E4C", "#FF9F99",
           "#A231A1", "#A37CB7", "#F2D7EE", "#B91372", "#E93B8C", "#ECB2C8",
           "#FF7149", "#F7AE24", "#FBDD7E", "#679436", "#8BBE53", "#CDE391",
           "#067D69", "#00A385", "#98D4C6", "#114B5F", "#028090", "#B2DBBF",
           "#A23E48", "#CD6981", "#FBD0C0", "#788585", "#9CAEA9", "#CCDAD1")
  
  # 数据排序
  
  mean_data <- aggregate(input$value, by = list(input$type), FUN = median)
  names(mean_data)[1:2] <- c("id", "mean_value")
  
  if (order == TRUE) {
    levels <- mean_data$id[order(mean_data$mean_value, decreasing = decreasing)]
    input$type <- factor(input$type, levels = levels)
  }
  
  # 开始画图
  
  if (show.point == TRUE) {
    
    plot <- ggplot(input, aes(x = type, y = value, fill = type)) +
      stat_boxplot(geom = "errorbar", width = 0, color = "black") +
      geom_boxplot(alpha = 1, outlier.shape = NA, size = 0.7, width = 0.7) + 
      
      geom_quasirandom(width = 0.3, size = 2, alpha = 0.2) + 
      scale_fill_manual(values=c(sample(col))) + 
      
      theme_bw() + 
      theme(panel.grid = element_blank(),
            legend.position = "none", # 去除图例
            axis.text = element_text(colour = "black", size = 15), 
            axis.title = element_text(colour = "black", size = 15),
            panel.border = element_rect(fill = NA, color = "black", linewidth = 1)) + 
      labs(x = '', y= 'Gene activity',title = '') + 
      rotate_x_text(rotate)
    
  } else {
    
    plot <- ggplot(input, aes(x = type, y = value, fill = type)) +
      stat_boxplot(geom = "errorbar", width = 0.1, color = "black") +
      geom_boxplot(alpha = 1, outlier.shape = NA, size = 0.7, width = 0.7) + 
      scale_fill_manual(values = c(sample(col))) + 
      
      theme_bw() + 
      theme(panel.grid = element_blank(),
            legend.position = "none", # 去除图例
            axis.text = element_text(colour = "black", size = 15), 
            axis.title = element_text(colour = "black", size = 15),
            panel.border = element_rect(fill = NA, color = "black", linewidth = 1)) + 
      labs(x = '', y= 'Gene activity',title = '') + 
      rotate_x_text(rotate)
    
  }
  
  # 输出结果
  
  if (is.null(output)) {
    plot
  } else {
    ggsave(output, plot, width = width, height = height)
  }
}


# 箱线图做法3 ====================

common_boxplot3 <- function(input = input,
                            output = name, rotate = 45,
                            order = TRUE, decreasing = T,
                            width = 7, height = 5) {
  
  library(ggbeeswarm)
  library(ggplot2)
  library(ggpubr)
  
  input <- input
  
  # 设定颜色
  
  col <- c("#0070B2", "#5CB3DA", "#B8E3EA", "#DA1735", "#F15E4C", "#FF9F99",
           "#A231A1", "#A37CB7", "#F2D7EE", "#B91372", "#E93B8C", "#ECB2C8",
           "#FF7149", "#F7AE24", "#FBDD7E", "#679436", "#8BBE53", "#CDE391",
           "#067D69", "#00A385", "#98D4C6", "#114B5F", "#028090", "#B2DBBF",
           "#A23E48", "#CD6981", "#FBD0C0", "#788585", "#9CAEA9", "#CCDAD1")
  
  # 数据排序
  
  mean_data <- aggregate(input$value, by = list(input$type), FUN = mean)
  names(mean_data)[1:2] <- c("id", "mean_value")
  
  if (order == TRUE) {
    levels <- mean_data$id[order(mean_data$mean_value, decreasing = decreasing)]
    input$type <- factor(input$type, levels = levels)
    mean_data$id <- factor(mean_data$id, levels = levels)
  }
  
  # 开始画图
  
  if (length(unique(input$type)) < 36) {
    
    plot <- ggplot(mean_data, aes(x = id, y = mean_value)) +
      
      stat_summary(fun = median, 
                   geom = "crossbar", 
                   width = 0.5, linewidth = 0.5) + 
      
      geom_quasirandom(data = input, aes(x = type, y = value,
                                         fill = type, color = type),
                       width = 0, size = 3, alpha = 0.2) + 
      scale_color_manual(values=c(sample(col))) + 
      
      theme_bw() + 
      theme(panel.grid = element_blank(),
            legend.position = "none", # 去除图例
            axis.text = element_text(colour = "black", size = 15), 
            axis.title = element_text(colour = "black", size = 15),
            panel.border = element_rect(fill = NA, color = "black", linewidth = 1)) + 
      labs(x = '', y= 'Gene activity',title = '') + 
      rotate_x_text(rotate)
    
  } else {
    
    plot <- ggplot(mean_data, aes(x = id, y = mean_value)) +
      
      stat_summary(fun = median, 
                   geom = "crossbar", 
                   width = 0.5, linewidth = 0.5) + 
      
      geom_quasirandom(data = input, aes(x = type, y = value),
                       width = 0, size = 3, alpha = 0.2) + 
      
      theme_bw() + 
      theme(panel.grid = element_blank(),
            legend.position = "none", # 去除图例
            axis.text = element_text(colour = "black", size = 15), 
            axis.title = element_text(colour = "black", size = 15),
            panel.border = element_rect(fill = NA, color = "black", linewidth = 1)) + 
      labs(x = '', y= 'Gene activity',title = '') + 
      rotate_x_text(rotate)
    
  }
  
  # 输出结果
  
  if (is.null(output)) {
    plot
  } else {
    ggsave(output, plot, width = width, height = height)
  }
}


# 小提琴图 ====================

common_violin <- function(input = input,
                          output = name,
                          title = NULL,
                          rotate = 45,
                          width = 3.5, height = 5) {
  library(ggplot2)
  library(ggpubr)
  library(ggbeeswarm)
  
  # 开始画图
  
  plot <- ggplot(input, aes(x = type, y = value)) +
    geom_quasirandom(width = 0.3, size = 2, color = "grey90") + 
    geom_violin(trim = FALSE, alpha = 0) + 
    geom_boxplot(aes(fill = type), alpha = 1, outlier.shape = NA,
                 size = 0.7, width = 0.1) + 
    scale_fill_manual(values = c("#FBD324", "#A37CB7")) + 
    
    stat_compare_means(method = "t.test", size = 5,
                       label.x = 0.7, label.y = 1.5*max(input$value)) + 
    
    theme_bw() + 
    theme(panel.grid = element_blank(),
          legend.position = "none", # 去除图例
          axis.text = element_text(colour = "black", size = 15), 
          axis.title = element_text(colour = "black", size = 15),
          panel.border = element_rect(fill = NA, color = "black", linewidth = 1)) + 
    labs(x = NULL, y= 'Gene activity',title = title) + 
    rotate_x_text(rotate)
  
  # 输出结果
  
  if (is.null(output)) {
    plot
  } else {
    ggsave(output, plot, width = width, height = height)
  }
  
}



# 自动聚类热图 =================================================================
# ==============================================================================

heatmap_cluster <- function(clustdata = clustdata,
                            dicho.thres = 0.5,
                            color = "blue2red",
                            number.k = 5,
                            number.maxk = 6) {
  
  library(ComplexHeatmap)
  library(ConsensusClusterPlus)
  
  # 设定颜色
  
  if (color == "parula") {
    col <- colorRampPalette(c("#352A87","#343EB1","#1558D9","#036CE0","#107AD9",
                              "#1387D3","#0997D1","#06A4C9","#0CADBB","#23B4A9",
                              "#43BB97","#6ABE83","#8FBF73","#AEBD66","#CBBB5B",
                              "#E6B94F","#FDBE3C","#FBCF2C","#F5E21E","#F9FB0E"))(100)
    
  } else if (color == "kovesi") {
    col <- colorRampPalette(c("#1B0084","#1B099A","#1C14AE","#1C20C0","#1F2DCE",
                              "#233DD6","#2950CE","#2E68AB","#377989","#3F876A",
                              "#46954D","#53A036","#65AB26","#7BB41A","#95BE16",
                              "#AFC61C","#C6CE26","#DAD636","#EAE04E","#F1EC74",
                              "#F8F7AF","#FFFFFF"))(100)
    
  } else if (color == "ocean.haline") {
    col <- colorRampPalette(c("#2A186C","#2E1B87","#2B229F","#1D35A1","#11459A",
                              "#0C5294","#115D8F","#19678C","#22718A","#2B7A89",
                              "#328388","#388D88","#3E9886","#44A284","#4CAC80",
                              "#55B67A","#62BF72","#73C869","#8AD060","#A4D75C",
                              "#BEDC62","#D5E171","#EAE784","#FDEF9A"))(100)
    
  } else if (color == "ocean.dense") {
    col <- colorRampPalette(c("#360E24","#5D1A58","#723692","#795CC3",
                              "#7487E0", "#7EB0E4","#AAD2E3","#E6F1F1"))(100)
    
  } else if (color == "magma") {
    col <- c(colorRampPalette(c(magma(323, begin = 0.15)[1]))(10),
             magma(323, begin = 0.18))
    
  } else if (color == "white2blue") {
    col <- colorRampPalette(c("#FBF4F8","#E5E0ED","#BFC6DD","#8CADCC",
                              "#4E92BA","#1871A8","#085889","#003758"))(100)
    
  } else if (color == "blue2red") {
    col <- colorRampPalette(c("#0070b2","#009bc7","#5ec7dd",
                              "#b8e3ea","#f3f3f1","#fccdb9",
                              "#f79676","#f15e4c","#da1735"))(100)
    
  } else if (color == "rainbow") {
    col <- colorRampPalette(c("#343391","#0064af","#0090cc","#00b6db","#01b7c2",
                              "#53c0a3","#8dcb8a","#bbd967","#fbd324","#f6bd25",
                              "#f4a02e","#ed6f32","#ea5c2e","#d5452f","#c02e2f",
                              "#8b2a21"))(100)
  }
  
  # 进行阈值二分类
  
  dichodata <- ifelse(clustdata > dicho.thres, 1, 0)
  
  # 开始聚类
  
  kmean <- ConsensusClusterPlus(dichodata, maxK = number.maxk,
                                reps = 100, pItem = 0.8,
                                pFeature = 1, title = "example", clusterAlg = "km",
                                distance = "euclidean", seed = 123456, plot = "png")
  # 确定聚类个数
  
  km_number = number.k
  cluster_prog <- data.frame(kmean = kmean[[km_number]][["consensusClass"]])
  cluster_prog <- rownames_to_column(cluster_prog, var = "id")
  cluster_prog <- cluster_prog[order(cluster_prog$kmean),]
  cluster_prog$kmean <- paste0("K", cluster_prog$kmean)
  
  # 对矩阵进行排序
  
  clustdata <- clustdata[,cluster_prog$id]
  
  # 开始画热图
  
  ha <- HeatmapAnnotation(df = data.frame(cluster_prog$kmean), 
                          which = "column", show_annotation_name = F,
                          show_legend = FALSE)
  
  draw(Heatmap(clustdata, col = col,
               name = "Z-score",
               top_annotation = ha,
               column_gap = unit(0, "mm"),
               row_gap = unit(0, "mm"),
               border = "#404040",  
               show_row_names = T, 
               show_column_names = T,
               column_names_rot = 45, 
               row_names_gp = gpar(fontsize = 12),
               column_split = cluster_prog$kmean, km = 5, 
               cluster_rows = T, show_row_dend = T,
               cluster_columns = F, show_column_dend = F,
               heatmap_legend_param = list(
                 legend_direction = "horizontal", 
                 legend_width = unit(6, "cm"))),
       heatmap_legend_side = "bottom")
}



# 两组差异分析 =================================================================
# ==============================================================================

diffanalysis_yc <- function(data = data, info = info,
                            group1 = "R", group2 = "NR"){
  
  # 计算差异基因
  
  diff <- do.call(rbind, lapply(1:nrow(data), function(i){
    
    input <- data.frame(id = colnames(data), value = data[i,])
    input <- merge(input, info, by = "id")
    input <- na.omit(input)
    
    com <- wilcox.test(value ~ type, data = input)
    statp <- com$p.value
    
    fcvalue <- mean(input$value[input$type == group1]) - 
      mean(input$value[input$type == group2])
    
    data.frame(id = rownames(data)[i],
               logfc = fcvalue, pvalue = statp)
    
  }))
  
  # 矫正P值
  
  diff$FDR <- p.adjust(diff$pvalue, method = "fdr")
  return(diff)
}


# seurat 差异分析 ====================

seurat_diffall <- function(datafilt = datafilt,
                           group.by = "seurat_clusters",
                           min.pct = 0.25) {
  library(Seurat)
  library(future)
  
  # 设定差异分析的分组
  
  datafilt <- SetIdent(datafilt, value = group.by)
  
  # 并行运算
  
  plan(multisession, workers = 4)
  options(future.globals.maxSize = 3000*1024^2)
  
  diff <- FindAllMarkers(datafilt, test.use = 'LR',
                         assay = "RNA", slot = 'data', 
                         min.pct = min.pct)
  plan(sequential)
  
  # 整理结果
  
  rownames(diff) <- NULL
  data.frame(gene = diff$gene,
             cluster = diff$cluster,
             logfc = diff$avg_log2FC,
             pct.1 = diff$pct.1, pct.2 = diff$pct.2,
             pvalue = diff$p_val, adjp = diff$p_val_adj)
}



# 比例计算 =====================================================================
# ==============================================================================

class_prop <- function(input = input,
                       xcutoff = 0.5,
                       ycutoff = 0.5) {
  
  colnames(input)[3] <- "class"
  input$quadrant <- NA
  input$number <- 1
  
  input$quadrant[input[,1] < xcutoff & input[,2] >= ycutoff] <- "L_up"
  input$quadrant[input[,1] < xcutoff & input[,2] < ycutoff] <- "L_dn"
  input$quadrant[input[,1] >= xcutoff & input[,2] >= ycutoff] <- "R_up"
  input$quadrant[input[,1] >= xcutoff & input[,2] < ycutoff] <- "R_dn"
  
  prop <- acast(input, class ~ quadrant, value.var = "number",
                fun.aggregate = sum, na.rm = TRUE)
  
  data.frame(prop / rowSums(prop))
}


# heatmap的dotplot展示marker表达 ====================

heatmap_dotplot_marker <- function(datafilt = datafilt,
                                   group.by = "celltype_sig2",
                                   marker = gene_list,
                                   color = "blue2red",
                                   dot.scale = 100) {
  library(Seurat)
  library(ComplexHeatmap)
  library(circlize)
  library(viridis)
  
  # 设定颜色
  
  if (color == "parula") {
    col <- colorRampPalette(c("#352A87","#343EB1","#1558D9","#036CE0","#107AD9",
                              "#1387D3","#0997D1","#06A4C9","#0CADBB","#23B4A9",
                              "#43BB97","#6ABE83","#8FBF73","#AEBD66","#CBBB5B",
                              "#E6B94F","#FDBE3C","#FBCF2C","#F5E21E","#F9FB0E"))(100)
    
  } else if (color == "ocean.dense") {
    col <- colorRampPalette(c("#360E24","#5D1A58","#723692","#795CC3",
                              "#7487E0", "#7EB0E4","#AAD2E3","#E6F1F1"))(100)
    
  } else if (color == "ocean2") {
    col <- colorRampPalette(c("#7F256F","#7D4A97","#5284BF","#32B1C0",
                              "#7FC6B4","#C4DEB9","#F4F2D9"))(100)
    
  } else if (color == "blue2red") {
    col <- colorRampPalette(c("#0070b2","#009bc7","#5ec7dd",
                              "#b8e3ea","#f3f3f1","#fccdb9",
                              "#f79676","#f15e4c","#da1735"))(100)
    
  } else if (color == "rainbow") {
    col <- colorRampPalette(c("#343391","#0064af","#0090cc","#00b6db","#01b7c2",
                              "#53c0a3","#8dcb8a","#bbd967","#fbd324","#f6bd25",
                              "#f4a02e","#ed6f32","#ea5c2e","#d5452f","#c02e2f",
                              "#8b2a21"))(100)
  }
  
  # 计算平均表达
  
  bulk_exp <- AverageExpression(datafilt, group.by = group.by,
                                slot = "data", return.seurat = FALSE)[[1]]
  
  bulk_exp <- bulk_exp[rowMeans(bulk_exp) > 0,]
  bulk_exp <- t(scale(t(bulk_exp)))
  
  # 读入注释文件
  
  if (is.list(marker)) {
    
    feature <- stack(marker)
    colnames(feature) <- c("gene","term")
    feature <- data.frame(term = feature$term,
                          gene = feature$gene)
    
  } else {
    
    feature <- read.table(marker, sep = ",", header = T, 
                          check.names = F, quote = "", na.strings = "")
  }
  
  # 得到交集基因
  
  common <- intersect(feature$gene, rownames(bulk_exp))
  feature_exp <- bulk_exp[common,]
  
  feature <- feature[feature$gene %in% common,]
  feature$term <- fct_inorder(feature$term)
  
  # 注释信息预处理
  
  ha_row <- HeatmapAnnotation(df = data.frame(feature$term),
                              which = "row", show_annotation_name = F,
                              show_legend = FALSE)
  
  # 抽取dotplot中的数据
  
  dotplot <- DotPlot(datafilt,
                     group.by = group.by,
                     features = feature$gene)
  
  prop <- dotplot$data
  prop <- acast(prop, features.plot ~ id,
                value.var = "pct.exp", fun.aggregate = sum)
  
  cell_fun <- function(feature_exp, prop, col = "black"){
    function(j, i, x, y, width, height, fill){
      grid.circle(x = x, y = y, r = abs(prop[i,j])/dot.scale * min(unit.c(width, height)), 
                  gp = gpar(fill = NA, col = col))}}
  
  # 开始画热图
  
  draw(Heatmap(feature_exp, col = col, 
               name = "Z-score",
               cell_fun = cell_fun(feature_exp, prop),
               left_annotation = ha_row, 
               column_gap = unit(0, "mm"), row_gap = unit(0, "mm"),
               border = "#404040",
               row_split = feature$term, 
               show_row_names = T, 
               show_column_names = T,
               column_names_rot = 45, 
               cluster_rows = F, show_row_dend = T,
               cluster_columns = F, show_column_dend = T,
               heatmap_legend_param = list(
                 legend_direction = "horizontal", 
                 legend_width = unit(6, "cm"))),
       heatmap_legend_side = "bottom")
}


# 气泡热图 =====================================================================
# ==============================================================================

heatmap_dotplot <- function(input = input,
                            scale.norm = T,
                            invert = T) {
  
  library(ComplexHeatmap)
  library(circlize)
  
  # 设定颜色
  
  col <- c("#281A2C","#352A4A","#3F396D","#404C8B","#3E6495",
           "#427999","#488E9E","#50A3A2","#5DBAA4","#78CEA3",
           "#A3DEA6","#D1EDB4","#FDFECC")
  
  # 分组标准化
  
  if (scale.norm == T) {
    input <- do.call(rbind, lapply(unique(input$type), function(i){
      subdata <- input[input$type == i,]
      subdata <- subdata[,colnames(subdata) != "type"]
      subdata <- data.frame(scale(subdata, center = F))
      subdata$type <- i
      subdata
    }))
  }
  
  if (invert == T) {
    
    # 添加注释信息
    
    info <- input$type
    ha_row <- HeatmapAnnotation(df = data.frame(info),
                                which = "column", show_annotation_name = F,
                                show_legend = FALSE)
    # 设定颜色
    
    all_value <- melt(input, id.vars = c("type"))
    thres <- quantile(all_value$value, probs = c(0.01, 0.99))
    
    col_fun <- colorRamp2(seq(from = thres[1], to = thres[2],
                              length.out = length(col)), col)
    # 气泡图参数
    
    input <- t(input[,colnames(input) != "type"])
    cell_fun = function(j, i, x, y, w, h, fill, col = "black"){
      grid.rect(x = x, y = y, width = w, height = h, 
                gp = gpar(col = NA, fill = NA))
      grid.circle(x = x,y = y, r = input[i, j]/3 * min(unit.c(w, h)),
                  gp = gpar(fill = col_fun(input[i, j]), col = col))}
    # 开始画图
    
    draw(Heatmap(input, border = "#404040",  
                 rect_gp = gpar(type = "none"), # 去除热图里的内容
                 cell_fun = cell_fun, col = col_fun,
                 top_annotation = ha_row, 
                 column_gap = unit(0, "mm"), row_gap = unit(0, "mm"),
                 show_row_names = T, 
                 show_column_names = T, column_names_rot = 45, 
                 cluster_rows = F, show_row_dend = F,
                 cluster_columns = F, show_column_dend = F,
                 heatmap_legend_param = list(
                   legend_direction = "horizontal", 
                   legend_width = unit(6, "cm"))),
         heatmap_legend_side = "bottom")
    
  } else {
    
    # 添加注释信息
    
    info <- input$type
    ha_row <- HeatmapAnnotation(df = data.frame(info),
                                which = "row", show_annotation_name = F,
                                show_legend = FALSE)
    # 设定颜色
    
    all_value <- melt(input, id.vars = c("type"))
    thres <- quantile(all_value$value, probs = c(0.01, 0.99))
    
    col_fun <- colorRamp2(seq(from = thres[1], to = thres[2],
                              length.out = length(col)), col)
    # 气泡图参数
    
    input <- input[,colnames(input) != "type"]
    cell_fun = function(j, i, x, y, w, h, fill, col = "black"){
      grid.rect(x = x, y = y, width = w, height = h, 
                gp = gpar(col = NA, fill = NA))
      grid.circle(x = x,y = y, r = input[i, j]/3 * min(unit.c(w, h)),
                  gp = gpar(fill = col_fun(input[i, j]), col = col))}
    # 开始画图
    
    draw(Heatmap(input, border = "#404040",  
                 rect_gp = gpar(type = "none"), # 去除热图里的内容
                 cell_fun = cell_fun, col = col_fun,
                 left_annotation = ha_row, 
                 column_gap = unit(0, "mm"), row_gap = unit(0, "mm"),
                 show_row_names = T, 
                 show_column_names = T, column_names_rot = 0, 
                 cluster_rows = F, show_row_dend = F,
                 cluster_columns = F, show_column_dend = F,
                 heatmap_legend_param = list(
                   legend_direction = "horizontal", 
                   legend_width = unit(6, "cm"))),
         heatmap_legend_side = "bottom")
    
  }
}



# 输出cellrank输入数据 =========================================================
# ==============================================================================

metacell.cellrank.input <- function(loom.name = name,
                                    metacell.info = info,
                                    output.file = output.file) {
  library(loomR)
  library(data.table)
  
  # 读取loom文件
  
  data <- connect(filename = loom.name,
                  mode = "r+", skip.validate = TRUE)
  
  # 提取行列名
  
  gene.names <- data[["row_attrs/Gene"]][]
  cell.names <- data[['col_attrs/CellID']][]
  
  # 提取矩阵
  
  full.matrix <- data[['matrix']][,]
  splice <- data[['layers/spliced']][,]
  unsplice <- data[['layers/unspliced']][,]
  
  
  # 统一loom来源细胞名 (针对不同情况修改) --------------------
  
  info <- read.table(metacell.info, header = T, sep = '\t')
  
  # head(info$id)
  # head(cell.names)
  
  # info$id <- gsub('_',"-F:", info$id, fixed = T)
  info$id <- gsub('HC0',"HCC0", info$id, fixed = T)
  info$id <- gsub('_',"-F:", info$id, fixed = T)
  info$id <- gsub('-1',"x", info$id, fixed = T)
  
  
  # 处理基础矩阵 --------------------
  
  rownames(full.matrix) = cell.names
  colnames(full.matrix) = gene.names
  matrix <- full.matrix[info$id,]
  
  # 标准化数据
  
  sum <- apply(matrix, 1, sum)
  matrix_norml <- log(matrix/sum*10000+1)
  metacell <- unique(info$metacell)
  
  meta_matrix <- do.call(rbind, lapply(metacell,function(i){
    submat <- matrix_norml[info$id[info$metacell==i],]
    submat <- apply(submat, 2, mean)
    return(submat)
  }))
  
  rownames(meta_matrix) <- metacell
  colnames(meta_matrix) <- gene.names
  
  # 保存结果
  
  output = paste0(output.file, "/matrix.txt")
  fwrite(meta_matrix, output, sep = "\t", row.names = T)
  
  
  # 处理splice矩阵 --------------------
  
  rownames(splice) = cell.names
  colnames(splice) = gene.names
  matrix <- splice[info$id,]
  
  # 标准化数据
  
  sum <- apply(matrix, 1, sum)
  matrix_norml <- log(matrix/sum*10000+1)
  metacell <- unique(info$metacell)
  
  meta_matrix <- do.call(rbind, lapply(metacell, function(i){
    submat <- matrix_norml[info$id[info$metacell==i],]
    submat <- apply(submat, 2, mean)
    return(submat)
  }))
  
  rownames(meta_matrix) <- metacell
  colnames(meta_matrix) <- gene.names
  
  # 保存结果
  
  output = paste0(output.file, "/splice.txt")
  fwrite(meta_matrix, output, sep = "\t", row.names = T)
  
  
  # 处理unsplice矩阵 --------------------
  
  rownames(unsplice) = cell.names
  colnames(unsplice) = gene.names
  matrix <- unsplice[info$id,]
  
  # 标准化数据
  
  sum <- apply(matrix, 1, sum)
  matrix_norml <- log(matrix/sum*10000+1)
  metacell <- unique(info$metacell)
  
  meta_matrix <- do.call(rbind, lapply(metacell, function(i){
    submat <- matrix_norml[info$id[info$metacell==i],]
    submat <- apply(submat, 2, mean)
    return(submat)
  }))
  
  rownames(meta_matrix) <- metacell
  colnames(meta_matrix) <- gene.names
  
  # 保存结果
  
  output = paste0(output.file, "/unsplice.txt")
  fwrite(meta_matrix, output, sep = "\t", row.names = T)
  
  
  # 保存其他数据 --------------------
  
  cellname = paste0(output.file, "/cellname.txt")
  genename = paste0(output.file, "/genename.txt")
  
  write.table(metacell, cellname, row.names = F, sep = "\t")
  write.table(gene.names, genename, row.names = F, sep = "\t")
}



# HCC队列生存分析 ==============================================================
# ==============================================================================

# 针对基因表达的分析 ====================

survival_curve_gene <- function(input = input,
                                select = select,
                                group.by = "optimal",
                                name = "cohort") {
  library(survival)
  library(survminer)
  
  # 确定阈值
  
  if (group.by == "median") {
    
    thres <- median(input$value)
    input$type <- ifelse(input$value > thres, "H", "L")
    
  } else if (group.by == "quantile") {
    
    thres1 <- quantile(input$value, probs = c(0.75), na.rm = T)
    thres2 <- quantile(input$value, probs = c(0.25), na.rm = T)
    input$type <- NA
    input$type[input$value > thres1] <- "H"
    input$type[input$value < thres2] <- "L"
    input <- na.omit(input)
    
  } else if (group.by == "optimal") {
    
    thres <- surv_cutpoint(input, time = "time", minprop = 0.15,
                           event = "status", variables = "value")
    thres <- thres$cutpoint[[1]]
    input$type <- ifelse(input$value > thres, "H", "L")
    
  }
  
  # 计算p值
  
  my.surv <- Surv(input$time, input$status)
  data.survdiff <- survdiff(my.surv ~ input$type)
  p.val = 1 - pchisq(data.survdiff$chisq, length(data.survdiff$n) - 1)
  
  # 计算HR
  
  mycox <- coxph(Surv(time,status) ~ value, data = input)
  coxResult <- summary(mycox)
  
  HR = coxResult$coefficients[,"exp(coef)"]
  lower_95CI = coxResult$conf.int[,3]
  upper_95CI = coxResult$conf.int[,4]
  
  HR <- paste("Hazard Ratio = ", round(HR,2), sep = "")
  CI <- paste("95% CI: ", paste(round(lower_95CI, 2),
                                round(upper_95CI, 2), sep = " - "), sep = "")
  
  # 基本信息
  
  number_H <- paste("number H = ", sum(input$type == "H"), sep = "")
  number_L <- paste("number L = ", sum(input$type == "L"), sep = "")
  cutoff <- paste("cutoff = ", round(thres, 3), sep = "")
  
  # 开始画图
  
  if (group.by != "quantile") {
    
    fit <- survfit(Surv(time, status) ~ type, data = input)
    ggsurvplot(fit, data = input, size = 1, palette = c("#f63a4e","#0089c1"), 
               risk.table = F, conf.int = F,
               conf.int.style = "step", ncensor.plot = FALSE, censor = F,
               font.legend = 12, font.title = 12, font.x = 12, font.y = 12,
               pval = paste(pval = ifelse(p.val < 0.001, "p < 0.001", 
                                          paste("P = ",round(p.val,3), sep = "")),
                            HR, CI, number_H, number_L, cutoff, sep = "\n"),
               legend.title = name)
    
  } else {
    
    fit <- survfit(Surv(time, status) ~ type, data = input)
    ggsurvplot(fit, data = input, size = 1, palette = c("#f63a4e","#0089c1"), 
               risk.table = F, conf.int = F,
               conf.int.style = "step", ncensor.plot = FALSE, censor = F,
               font.legend = 12, font.title = 12, font.x = 12, font.y = 12,
               pval = paste(pval = ifelse(p.val < 0.001, "p < 0.001", 
                                          paste("P = ",round(p.val,3), sep = "")),
                            HR, CI, sep = "\n"),
               legend.title = name)
  }
}


# 针对分组的分析 ====================

survival_curve_class <- function(input = input,
                                 name = "cohort") {
  library(survival)
  library(survminer)
  
  # 计算p值
  
  my.surv <- Surv(input$time, input$status)
  data.survdiff <- survdiff(my.surv ~ input$type)
  p.val = 1 - pchisq(data.survdiff$chisq, length(data.survdiff$n) - 1)
  
  # 计算HR
  
  mycox <- coxph(Surv(time,status) ~ type, data = input)
  coxResult <- summary(mycox)
  
  HR = coxResult$coefficients[,"exp(coef)"]
  lower_95CI = coxResult$conf.int[,3]
  upper_95CI = coxResult$conf.int[,4]
  
  HR <- paste("Hazard Ratio = ", round(HR,2), sep = "")
  CI <- paste("95% CI: ", paste(round(lower_95CI, 2),
                                round(upper_95CI, 2), sep = " - "), sep = "")
  
  # 开始画图
  
  fit <- survfit(Surv(time, status) ~ type, data = input)
  ggsurvplot(fit, data = input, size = 1, palette = c("#f63a4e","#0089c1"), 
             risk.table = F, conf.int = F,
             conf.int.style = "step", ncensor.plot = FALSE, censor = F,
             font.legend = 12, font.title = 12, font.x = 12, font.y = 12,
             pval = paste(pval = ifelse(p.val < 0.001, "p < 0.001", 
                                        paste("P = ",round(p.val,3), sep = "")),
                          HR, CI, sep = "\n"),
             legend.title = name)
}



# circle correlation ===========================================================
# ==============================================================================

circle_corplot <- function(input = input,
                           thres = 0.2,
                           point.size = 5,
                           font.size = 5) {
  library(igraph)
  library(ggraph)
  
  # 设定颜色
  
  col <- rev(c("#352A87","#343EB1","#1558D9","#036CE0","#107AD9",
               "#1387D3","#0997D1","#06A4C9","#0CADBB","#23B4A9",
               "#43BB97","#6ABE83","#8FBF73","#AEBD66","#CBBB5B",
               "#E6B94F","#FDBE3C","#FBCF2C","#F5E21E","#F9FB0E"))
  
  # 数据预处理
  
  input[input < thres] <- 0
  graph <- graph.adjacency(input, weighted = TRUE)
  
  # 开始画图
  
  ggraph(graph, layout = 'linear', circular = TRUE) + 
    geom_edge_arc(aes(color = weight, edge_width = abs(weight))) + 
    geom_node_text(aes(label = name, angle = node_angle(x, y)),
                   hjust = -0.5, size = font.size) +
    geom_node_point(shape = 21, size = point.size, fill = "white") +
    theme_graph(fg_text_colour = 'white',
                base_family = 'Helvetica') +
    scale_edge_color_gradientn(colours = col) + 
    scale_edge_width(range = c(0.25, 3)) + 
    coord_fixed(xlim = c(-1.4, 1.4), ylim = c(-1.4, 1.4)) +
    guides(fill = guide_none())
}



# ACTIONet analysis ============================================================
# ==============================================================================

actionet.analysis <- function(datafilt = datafilt,
                              svd.dim = 50,
                              k.max = 30,
                              min.cells = 5) {
  
  library(ACTIONet)
  library(SingleCellExperiment)
  
  # 构建SCE对象
  
  data <- GetAssayData(datafilt, slot = "data", assay = "RNA")
  metainfo <- datafilt@meta.data
  
  sce <- SingleCellExperiment(list(logcounts = data),
                              colData = metainfo)
  
  # archetypal analysis
  
  sce <- reduce.ace(sce, reduced_dim = svd.dim)
  anet <- runACTIONet(sce, k_max = k.max, min_cells_per_arch = min.cells)
  
  # 提取分类结果
  
  info <- data.frame(colData(anet))
  info <- info[c("assigned_archetype", "node_centrality")]
  names(info) <- c("archetype", "archetype_quality")
  
  # 提取连续结果
  
  values <- colMaps(anet)@listData[["archetype_footprint"]]
  values <- data.frame(values)
  colnames(values) <- paste0("AA_", 1:ncol(values))
  
  # 提取降维数据
  
  coord <- colMaps(anet)@listData[["ACTIONet2D"]]
  coord <- as.matrix(coord)
  colnames(coord) <- paste0("AA_", 1:ncol(coord))
  
  # 提取gene specificity
  
  genes <- rowMaps(anet)@listData[["unified_feature_specificity"]]
  genes <- data.frame(genes)
  colnames(genes) <- paste0("AA_", 1:ncol(genes))
  
  # 整合seurat对象
  
  datafilt <- AddMetaData(datafilt, info)
  datafilt <- AddMetaData(datafilt, values)
  
  datafilt[["AA"]] <- CreateDimReducObject(coord, key = "AA")
  datafilt@assays[["RNA"]]@meta.features <- genes
  
  # 输出结果
  
  datafilt
}



# 平均值相关函数 ===============================================================
# ==============================================================================

# 排除离群值 --------------------

mean_rmout <- function(input = input) {
  
  remove_outliers <- function(x, na.rm = TRUE, ...) {
    qnt <- quantile(x, probs = c(.25, .75), na.rm = na.rm, ...)
    H <- 1.5 * IQR(x, na.rm = na.rm)
    y <- x
    y[x < (qnt[1] - H)] <- NA
    y[x > (qnt[2] + H)] <- NA
    y
  }
  
  input <- remove_outliers(input)
  mean(input, na.rm = TRUE)
}


# 计算pvalue的平均值 --------------------

metapvalue <- function(input = input) {
  
  library(metap)
  if (length(input) == 1) {
    input
    
  } else {
    pvalue <- sumz(input, log.p = FALSE)
    pvalue[["p"]][,1]
  }
}



# 循环差异分析 =================================================================
# ==============================================================================

# limma差异分析 ====================

difflimma <- function(data = data,
                      info = info,
                      group1 = "R",
                      group2 = "NR",
                      filter = FALSE) {
  
  # 默认情况都是group1 - group2
  
  library(limma)
  library(metaMA)
  library(statmod)
  
  # 初步筛选基因
  
  if (filter == TRUE) {
    data <- data[rowMeans(data)>0,]
  }
  
  # 确保排序一致
  
  common <- intersect(colnames(data), info$id)
  info <- info[info$id %in% common,]
  data <- data[,info$id]
  data <- as.matrix(data)
  
  # 构建矩阵
  
  grade <- factor(info[,2], levels = c(group2, group1))
  design <- model.matrix(~0 + grade)
  
  rownames(design) <- info$id
  colnames(design) <- gsub(pattern = "grade", replacement = "",
                           x = colnames(design))
  # 对比矩阵
  
  cont.matrix <- as.matrix(c(-1, 1))
  rownames(cont.matrix) <- c(group2, group1)
  colnames(cont.matrix) <- paste0(group1, " - ", group2)
  
  # 线性拟合
  
  fit <- lmFit(data, design)
  fit <- contrasts.fit(fit, cont.matrix)
  fit <- eBayes(fit, trend = TRUE, robust = TRUE)
  
  # 得到差异基因
  
  diff <- topTable(fit, adjust = 'fdr',
                   coef = 1, n = Inf)
  
  diff <- data.frame(id = rownames(diff),
                     logfc = diff$logFC,
                     t = diff$t,
                     pvalue = diff$P.Value,
                     FDR = diff$adj.P.Val)
  
  # 得到分组平均值
  
  group_mean <- do.call(rbind, lapply(1:nrow(data), function(i){
    
    input <- data.frame(id = colnames(data), value = data[i,])
    input <- merge(input, info, by = "id")
    input <- na.omit(input)
    
    cohen <- (mean(input$value[input$type == group1]) - 
                mean(input$value[input$type == group2])) / sd(input$value)
    
    data.frame(id = rownames(data)[i],
               mean_G1 = mean(input$value[input$type == group1]),
               mean_G2 = mean(input$value[input$type == group2]),
               cohen = cohen)
  }))
  
  colnames(group_mean)[2:3] <- c(group1, group2)
  
  # 整合平均值结果
  
  diff <- merge(group_mean, diff, by = "id")
  
  # 得到moderated effect size
  
  es <- effectsize(fit$t, nrow(info),
                   (fit$df.prior + fit$df.residual))
  
  es <- data.frame(es = es[,"dprime"],
                   es_var = es[,"vardprime"])
  # 结果总结
  
  es <- es[diff$id,]
  es <- cbind(diff, es)
  rownames(es) <- NULL
  es
}


# limma循环差异分析1 ====================

limma_betweenAB <- function(mat.value = input1,
                            mat.type = input2,
                            thres = 0.75,
                            value = "es",
                            format = "wide") {
  
  library(reshape2)
  library(future.apply)
  
  mat.value <- t(as.matrix(mat.value))
  mat.type <- data.frame(mat.type)
  
  # 二分类化分类矩阵 ----------
  
  mat.dich <- do.call(cbind, lapply(names(mat.type), function(i){
    
    value <- mat.type[,i]
    type <- rep("M", length(value))
    
    type[value > quantile(value, probs = thres)] <- "H"
    type[value < quantile(value, probs = 1 - thres)] <- "L"
    
    type <- data.frame(id = type); names(type) <- i
    type
  }))
  
  row.names(mat.dich) <- row.names(mat.type)
  
  # 定义差异分析函数 ----------
  
  difflimma <- function(data = data,
                        info = info,
                        group1 = "R",
                        group2 = "NR") {
    
    # 默认情况都是group1 - group2
    
    library(limma)
    library(metaMA)
    library(statmod)
    library(tibble)
    
    # 确保排序一致
    
    common <- intersect(colnames(data), info$id)
    info <- info[info$id %in% common,]
    data <- data[,info$id]
    data <- as.matrix(data)
    
    # 构建矩阵
    
    grade <- factor(info[,2], levels = c(group2, group1))
    design <- model.matrix(~0 + grade)
    
    rownames(design) <- info$id
    colnames(design) <- gsub(pattern = "grade", replacement = "",
                             x = colnames(design))
    # 对比矩阵
    
    cont.matrix <- as.matrix(c(-1, 1))
    rownames(cont.matrix) <- c(group2, group1)
    colnames(cont.matrix) <- paste0(group1, " - ", group2)
    
    # 线性拟合
    
    fit <- lmFit(data, design)
    fit <- contrasts.fit(fit, cont.matrix)
    fit <- eBayes(fit, trend = TRUE, robust = TRUE)
    
    # 得到差异基因
    
    diff <- topTable(fit, adjust = 'fdr',
                     coef = 1, n = Inf)
    
    diff <- data.frame(id = rownames(diff),
                       logfc = diff$logFC,
                       t = diff$t,
                       pvalue = diff$P.Value,
                       FDR = diff$adj.P.Val)
    
    # 得到分组平均值
    
    group_mean <- do.call(rbind, lapply(1:nrow(data), function(i){
      
      input <- data.frame(id = colnames(data), value = data[i,])
      input <- merge(input, info, by = "id")
      input <- na.omit(input)
      
      fcvalue <- mean(input$value[input$type == group1]) - 
        mean(input$value[input$type == group2])
      
      data.frame(id = rownames(data)[i],
                 mean_G1 = mean(input$value[input$type == group1]),
                 mean_G2 = mean(input$value[input$type == group2]))
    }))
    
    colnames(group_mean)[2:3] <- c(group1, group2)
    
    # 整合平均值结果
    
    diff <- merge(group_mean, diff, by = "id")
    
    # 得到moderated effect size
    
    es <- effectsize(fit$t, nrow(info),
                     (fit$df.prior + fit$df.residual))
    
    es <- data.frame(es = es[,"dprime"],
                     es_var = es[,"vardprime"])
    # 结果总结
    
    es <- es[diff$id,]
    es <- cbind(diff, es)
    rownames(es) <- NULL
    es
  }
  
  # 开始计算 ----------
  
  if (format == "wide") {
    
    allresult <- do.call(cbind, lapply(colnames(mat.dich), function(i){
      
      info <- data.frame(id = rownames(mat.dich), type = mat.dich[,i])
      info <- info[info$type %in% c("H", "L"),]
      
      diff <- difflimma(mat.value, info,
                        group1 = "H",
                        group2 = "L")
      
      diff <- data.frame(id = diff$id,
                         value = diff[,value])
      
      diff <- column_to_rownames(diff, var = "id")
      names(diff) <- i
      diff
      
    }))
    
  } else {
    
    allresult <- do.call(rbind, lapply(colnames(mat.dich), function(i){
      
      info <- data.frame(id = rownames(mat.dich), type = mat.dich[,i])
      info <- info[info$type %in% c("H", "L"),]
      
      diff <- difflimma(mat.value, info,
                        group1 = "H",
                        group2 = "L")
      
      data.frame(id1 = diff$id,
                 id2 = i,
                 logfc = diff[,value],
                 pvalue = diff$pvalue,
                 FDR = diff$FDR)
    }))
    
  }
  
  # 输出结果
  
  allresult
}


# limma循环差异分析2 ====================

limma_betweenAb <- function(data = data,
                            info = info,
                            thres = 0.9) {
  
  library(reshape2)
  library(future.apply)
  
  data <- t(as.matrix(data))
  info <- data.frame(info)
  
  # 二分类化分组变量
  
  info$type <- "M"
  info$type[info$value > quantile(info$value, probs = thres)] <- "H"
  info$type[info$value < quantile(info$value, probs = 1 - thres)] <- "L"
  info <- info[info$type != "M",]; info <- info[,-2]
  
  # 定义差异分析函数 ----------
  
  difflimma <- function(data = data,
                        info = info,
                        group1 = "R",
                        group2 = "NR",
                        filter = FALSE) {
    
    # 默认情况都是group1 - group2
    
    library(limma)
    library(metaMA)
    library(statmod)
    
    # 初步筛选基因
    
    if (filter == TRUE) {
      data <- data[rowMeans(data)>0,]
    }
    
    # 确保排序一致
    
    common <- intersect(colnames(data), info$id)
    info <- info[info$id %in% common,]
    data <- data[,info$id]
    data <- as.matrix(data)
    
    # 构建矩阵
    
    grade <- factor(info[,2], levels = c(group2, group1))
    design <- model.matrix(~0 + grade)
    
    rownames(design) <- info$id
    colnames(design) <- gsub(pattern = "grade", replacement = "",
                             x = colnames(design))
    # 对比矩阵
    
    cont.matrix <- as.matrix(c(-1, 1))
    rownames(cont.matrix) <- c(group2, group1)
    colnames(cont.matrix) <- paste0(group1, " - ", group2)
    
    # 线性拟合
    
    fit <- lmFit(data, design)
    fit <- contrasts.fit(fit, cont.matrix)
    fit <- eBayes(fit, trend = TRUE, robust = TRUE)
    
    # 得到差异基因
    
    diff <- topTable(fit, adjust = 'fdr',
                     coef = 1, n = Inf)
    
    diff <- data.frame(id = rownames(diff),
                       logfc = diff$logFC,
                       t = diff$t,
                       pvalue = diff$P.Value,
                       FDR = diff$adj.P.Val)
    
    # 得到分组平均值
    
    group_mean <- do.call(rbind, lapply(1:nrow(data), function(i){
      
      input <- data.frame(id = colnames(data), value = data[i,])
      input <- merge(input, info, by = "id")
      input <- na.omit(input)
      
      cohen <- (mean(input$value[input$type == group1]) - 
                  mean(input$value[input$type == group2])) / sd(input$value)
      
      data.frame(id = rownames(data)[i],
                 mean_G1 = mean(input$value[input$type == group1]),
                 mean_G2 = mean(input$value[input$type == group2]),
                 cohen = cohen)
    }))
    
    colnames(group_mean)[2:3] <- c(group1, group2)
    
    # 整合平均值结果
    
    diff <- merge(group_mean, diff, by = "id")
    
    # 得到moderated effect size
    
    es <- effectsize(fit$t, nrow(info),
                     (fit$df.prior + fit$df.residual))
    
    es <- data.frame(es = es[,"dprime"],
                     es_var = es[,"vardprime"])
    # 结果总结
    
    es <- es[diff$id,]
    es <- cbind(diff, es)
    rownames(es) <- NULL
    es
  }
  
  # 开始计算 ----------
  
  difflimma(data, info,
            group1 = "H",
            group2 = "L")
}


# 循环差异分析2 ====================

diff_betweenAb <- function(data = data,
                           info = info,
                           thres = 0.9) {
  
  library(reshape2)
  
  data <- t(as.matrix(data))
  info <- data.frame(info)
  
  # 二分类化分组变量
  
  info$type <- "M"
  info$type[info$value > quantile(info$value, probs = thres)] <- "H"
  info$type[info$value < quantile(info$value, probs = 1 - thres)] <- "L"
  info <- info[info$type != "M",]; info <- info[,-2]
  
  # 开始差异分析
  
  diff <- do.call(rbind, lapply(1:nrow(data), function(i){
    
    input <- data.frame(id = colnames(data), value = data[i,])
    input <- merge(input, info, by = "id")
    input <- na.omit(input)
    
    com <- wilcox.test(value ~ type, data = input)
    statp <- com$p.value
    
    fcvalue <- mean(input$value[input$type == "H"]) - 
      mean(input$value[input$type == "L"])
    
    data.frame(id = rownames(data)[i],
               logfc = fcvalue, pvalue = statp)
  }))
  
  diff$adjp <- p.adjust(diff$pvalue, method = "fdr")
  return(diff)
  
  # 输出结果
  
  diff
}



# Cytoscape导出结果 ============================================================
# ==============================================================================

output_network <- function(gsea = gsea,
                           topn = 3,
                           name.edge = name1,
                           name.node = name2) {
  library(dplyr)
  
  gsea$pvalue <- -log10(gsea$pvalue)
  
  # edge ----------
  
  edge <- data.frame(Var1 = gsea$type,
                     Var2 = gsea$id, value = gsea$pvalue)
  
  # node1 (periphery) ----------
  
  node1 <- data.frame(name = gsea$id, type = "periphery")
  
  # 计算node的degree
  
  degree <- data.frame(name = names(table(node1$name)),
                       degree = as.numeric(unname(table(node1$name))))
  
  # 选择top的node
  
  top <- do.call(c, lapply(unique(gsea$type), function(i){
    subdata <- gsea[gsea$type == i,]
    top_n(subdata, topn, pvalue)$id
  }))
  
  node1 <- merge(node1, degree, by = "name")
  node1$label <- 1
  node1$label[node1$name %in% top] <- 2
  
  
  # node2 (center) ----------
  
  node2 <- data.frame(name = gsea$type, type = "center",
                      degree = max(node1$degree),
                      label = 2)
  
  # 整合node结果
  
  node <- rbind(node2, node1)
  node <- node[!duplicated(node$name),]
  
  # 保存结果
  
  write.table(edge, name1, sep = "\t", quote = F, row.names = F, col.names = T)
  write.table(node, name2, sep = "\t", quote = F, row.names = F, col.names = T)
}



# 计算pertubation scores =======================================================
# ==============================================================================

pertub_score <- function(mat.fc = input,
                         pb.sig = pbsig,
                         nperm = 500) {
  
  library(future.apply)
  
  plan(multisession, workers = 3)
  options(future.globals.maxSize = 3000*1024^2)
  
  allscores <- do.call(rbind, future_lapply(colnames(mat.fc), function(i){
    fc <- data.frame(id = rownames(mat.fc),
                     value = mat.fc[,i])
    
    # 定义mean函数
    
    mean.y <- function(input){
      if (length(input) > 0) {
        mean(input)} else {0}}
    
    # 计算pertub分数
    
    scores <- do.call(rbind, lapply(names(pb.sig), function(j){
      sig <- pb.sig[[j]]
      
      up <- names(sig)[sig == 1]
      dn <- names(sig)[sig == -1]
      
      # 进行permutation
      
      subperm <- do.call(rbind, lapply(1:nperm, function(k){
        value <- mean.y(sample(fc$value, length(dn))) - 
                 mean.y(sample(fc$value, length(up)))
        data.frame(id = k, value = value)
      }))
      
      # 计算score
      
      value <- mean.y(fc$value[fc$id %in% dn]) -
               mean.y(fc$value[fc$id %in% up])
      
      # 整合数据
      
      data.frame(id = j, type = i, score = value,
                 zscore = (value - mean(subperm$value)) / sd(subperm$value),
                 pvalue = sum(value < subperm$value) / nperm)
    }))
    
    scores
  }, future.seed = TRUE))
  
  plan(sequential)
  allscores
}



# TotalVI分析 ==================================================================
# ==============================================================================

totalvi_latent <- function(expdata = expdata,
                           prodata = prodata) {
  
  library(sceasy)
  library(reticulate)
  library(anndata)
  
  # 设置环境
  
  reticulate::use_condaenv('totalvi')
  sc <- import("scanpy", convert = FALSE)
  scvi <- import("scvi", convert = FALSE)
  sys <- import ("sys", convert = FALSE)
  
  # 提取数据
  
  count.exp <- GetAssayData(expdata, slot = "counts", assay = "RNA")
  count.pro <- GetAssayData(prodata, slot = "counts", assay = "RNA")
  
  # 构建SCE对象
  
  exp <- SingleCellExperiment(list(counts = count.exp))
  pro <- SingleCellExperiment(list(counts = count.pro))
  
  altExp(exp) <- pro
  altExpNames(exp) <- "protein"
  
  # SCE对象转成anndata对象
  
  adata <- convertFormat(exp, from = "sce", to = "anndata",
                         main_layer = "counts", drop_single_values = FALSE)
  
  adata_pro <- convertFormat(altExp(exp), from = "sce", to = "anndata",
                             main_layer = "counts", drop_single_values = FALSE)
  
  adata$obsm["protein"] <- adata_pro$to_df()
  
  # 开始运行TotalVI
  
  scvi$model$TOTALVI$setup_anndata(adata, protein_expression_obsm_key = "protein")
  vae <- scvi$model$TOTALVI(adata)
  vae$train()
  
  # 整理结果
  
  latent <- py_to_r(vae$get_latent_representation())
  rownames(latent) <- py_to_r(adata$obs)[,1]
  colnames(latent) <- paste0("total_", 1:ncol(latent))
  latent
}



# GWAS 多组差异分析图 ==========================================================
# ==============================================================================

# 用于相关性分析的版本 ====================

gwas_diffplot_cor <- function(input = input,
                              topn = 3,
                              order = "name",
                              select = NULL) {
  
  library(ggplot2)
  library(ggrepel)
  library(dplyr)
  library(gtools)
  
  input <- na.omit(input)
  
  
  # 结果排序 ----------
  
  if (order == "value") {
    
    value <- do.call(c, lapply(unique(input$cluster), function(i){
      subinput <- input$value[input$cluster == i]
      max(subinput)}))
    names(value) <- unique(input$cluster)
    
    input$cluster <- factor(input$cluster,
                            levels = names(sort(value, decreasing = T)))
    input$number <- as.numeric(input$cluster)
    
  } else if (order == "name") {
    
    order <- mixedsort(unique(input$cluster))
    input$cluster <- factor(input$cluster, levels = order)
    input$number <- as.numeric(input$cluster)
    
  }
  
  
  # 提取要注释的点 ----------
  
  top_up_label <- do.call(rbind, lapply(unique(input$cluster), function(i){
    subinput <- input[input$cluster == i,]
    top_n(subinput, topn, value)
  }))
  
  top_dn_label <- do.call(rbind, lapply(unique(input$cluster), function(i){
    subinput <- input[input$cluster == i,]
    top_n(subinput, -topn, value)
  }))
  
  top_label <- rbind(top_up_label, top_dn_label)
  
  
  # 生成灰色背景色数据 ----------
  
  background_position <- input %>%
    dplyr::group_by(cluster) %>%
    dplyr::summarise(Min = min(value) - 0.2, Max = max(value) + 0.2) %>%
    as.data.frame()
  
  background_position$number <- 1:nrow(background_position)
  background_position$start <- background_position$number - 0.4
  background_position$end <- background_position$number + 0.4
  
  
  # 修改点的颜色，大小与透明度 ----------
  
  input$color <- ifelse(input$value > 0, "#f4ced8", "#d3e4f0")
  
  input1 <- input[input$id %in% top_label$id,]
  input <- input[!(input$id %in% top_label$id),]
  
  input1$color[input1$value > 0] <- "#da1735"
  input1$color[input1$value < 0] <- "#0070b2"
  
  
  # 手动添加注释 ----------
  
  if (!is.null(select)) {
    input2 <- input[input$id %in% select,]
    input <- input[!(input$id %in% select),]
    input2$color <- "#f7ae24"
  }
  
  # 添加手动选择的label
  
  if (!is.null(select)) {
    select_label <- input2
    select_label <- select_label[,(colnames(select_label) != "color")]
    top_label <- rbind(top_label, select_label)
    top_label <- top_label[!duplicated(top_label$id),]
  }
  
  
  # 设定颜色 ----------
  
  if (nrow(background_position) < 17) {
    col <- c("#A6D719", "#176EBF", "#00A8DE", "#AEE0E8",
             "#00A9A3", "#FBD324", "#F28A24", "#A52828",
             "#A37CB7", "#F2D7EE", "#CD6981", "#FBD0C0",
             "#F15E4C", "#ECB2C8", "#B2DBBF", "#CCDAD1")
  } else {
    col <- sample(c("#0070B2", "#5CB3DA", "#B8E3EA", "#DA1735", "#F15E4C", "#FF9F99",
                    "#A231A1", "#A37CB7", "#F2D7EE", "#B91372", "#E93B8C", "#ECB2C8",
                    "#FF7149", "#F7AE24", "#FBDD7E", "#679436", "#8BBE53", "#CDE391",
                    "#067D69", "#00A385", "#98D4C6", "#114B5F", "#028090", "#B2DBBF",
                    "#A23E48", "#CD6981", "#FBD0C0", "#788585", "#9CAEA9", "#CCDAD1"))
  }
  
  
  # 注释色块中的内容 ----------
  
  dfcol <- data.frame(x = c(1:nrow(background_position)),
                      y = 0, label = c(1:nrow(background_position)))
  dfcol$group <- background_position$cluster
  
  
  # 开始画图 ----------
  
  if (!is.null(select)) {
    
    ggplot() + 
      
      # 添加灰色背景色
      
      geom_rect(data = background_position,
                aes(xmin = start, xmax = end,
                    ymin = Min, ymax = Max),
                fill = "#525252", alpha = 0.05) + 
      
      # 添加点
      
      geom_jitter(data = input,
                  aes(x = number, y = value),
                  position = position_jitter(seed = 1),
                  size = 3, alpha = 0.3, 
                  color = input$color) + 
      
      geom_jitter(data = input1,
                  aes(x = number, y = value),
                  position = position_jitter(seed = 1),
                  size = 4, alpha = 1, 
                  color = input1$color) + 
      
      geom_jitter(data = input2,
                  aes(x = number, y = value),
                  position = position_jitter(seed = 1),
                  size = 5, alpha = 1, shape = 17,
                  color = input2$color) + 
      
      # 添加色块及相应的颜色
      
      geom_tile(data = dfcol,
                aes(x = x,y = y), height = 0.1,
                color = "black", alpha = 1, show.legend = F,
                fill = sample(col, nrow(background_position)))+
      
      geom_text(data = dfcol,
                aes(x = x, y = y, label = group),
                size = 5, color ="black") + 
      
      # 根据top_label标注基因名
      
      geom_text_repel(data = top_label,
                      aes(x = number, y = value, label = gene),
                      force = 1.2, size = 4,
                      min.segment.length = 100) + 
      
      scale_fill_manual(values = col) +
      labs(y = "Fold change value") + 
      
      theme_bw() + 
      theme(legend.position = "none",
            panel.grid.minor = element_blank(),
            panel.grid.major = element_blank(),
            axis.text = element_text(colour = "black", size = 15),
            axis.title = element_text(colour = "black", size = 15),
            axis.text.y = element_text(colour = 'black'),
            axis.text.x = element_blank(), 
            axis.title.x = element_blank(),
            panel.border = element_blank(),
            axis.ticks.x = element_blank(),
            axis.line.y = element_line(colour = "black")) + 
      
      scale_x_continuous(expand = c(0.01,0)) + # 不留边框
      scale_y_continuous(expand = c(0,0))
    
  } else {
    
    ggplot() + 
      
      # 添加灰色背景色
      
      geom_rect(data = background_position,
                aes(xmin = start, xmax = end,
                    ymin = Min, ymax = Max),
                fill = "#525252", alpha = 0.05) + 
      
      # 添加点
      
      geom_jitter(data = input,
                  aes(x = number, y = value),
                  position = position_jitter(seed = 1),
                  size = 3, alpha = 0.3, 
                  color = input$color) + 
      
      geom_jitter(data = input1,
                  aes(x = number, y = value),
                  position = position_jitter(seed = 1),
                  size = 4, alpha = 1, 
                  color = input1$color) + 
      
      # 添加色块及相应的颜色
      
      geom_tile(data = dfcol,
                aes(x = x,y = y), height = 0.1,
                color = "black", alpha = 1, show.legend = F,
                fill = sample(col, nrow(background_position)))+
      
      geom_text(data = dfcol,
                aes(x = x, y = y, label = group),
                size = 5, color ="black") + 
      
      # 根据top_label标注基因名
      
      geom_text_repel(data = top_label,
                      aes(x = number, y = value, label = gene),
                      force = 1.2, size = 4,
                      min.segment.length = 100) + 
      
      scale_fill_manual(values = col) +
      labs(y = "Fold change value") + 
      
      theme_bw() + 
      theme(legend.position = "none",
            panel.grid.minor = element_blank(),
            panel.grid.major = element_blank(),
            axis.text = element_text(colour = "black", size = 15),
            axis.title = element_text(colour = "black", size = 15),
            axis.text.y = element_text(colour = 'black'),
            axis.text.x = element_blank(), 
            axis.title.x = element_blank(),
            panel.border = element_blank(),
            axis.ticks.x = element_blank(),
            axis.line.y = element_line(colour = "black")) + 
      
      scale_x_continuous(expand = c(0.01,0)) + # 不留边框
      scale_y_continuous(expand = c(0,0))
    
  }
}


# 用于效应量分析的版本 ====================

gwas_diffplot <- function(input = input,
                          topn = 3,
                          order = "name",
                          select = NULL) {
  
  library(ggplot2)
  library(ggrepel)
  library(dplyr)
  library(gtools)
  
  input <- na.omit(input)
  
  
  # 结果排序 ----------
  
  if (order == "value") {
    
    value <- do.call(c, lapply(unique(input$cluster), function(i){
      subinput <- input$value[input$cluster == i]
      max(subinput)}))
    names(value) <- unique(input$cluster)
    
    input$cluster <- factor(input$cluster,
                            levels = names(sort(value, decreasing = T)))
    input$number <- as.numeric(input$cluster)
    
  } else if (order == "name") {
    
    order <- mixedsort(unique(input$cluster))
    input$cluster <- factor(input$cluster, levels = order)
    input$number <- as.numeric(input$cluster)
    
  }
  
  
  # 提取要注释的点 ----------
  
  top_up_label <- do.call(rbind, lapply(unique(input$cluster), function(i){
    subinput <- input[input$cluster == i,]
    top_n(subinput, topn, value)
  }))
  
  top_dn_label <- do.call(rbind, lapply(unique(input$cluster), function(i){
    subinput <- input[input$cluster == i,]
    top_n(subinput, -topn, value)
  }))
  
  top_label <- rbind(top_up_label, top_dn_label)
  
  
  # 生成灰色背景色数据 ----------
  
  background_position <- input %>%
    dplyr::group_by(cluster) %>%
    dplyr::summarise(Min = min(value) - 0.2, Max = max(value) + 0.2) %>%
    as.data.frame()
  
  background_position$number <- 1:nrow(background_position)
  background_position$start <- background_position$number - 0.4
  background_position$end <- background_position$number + 0.4
  
  
  # 修改点的颜色，大小与透明度 ----------
  
  input$color <- ifelse(input$value > 0, "#f4ced8", "#d3e4f0")
  
  input1 <- input[input$id %in% top_label$id,]
  input <- input[!(input$id %in% top_label$id),]
  
  input1$color[input1$value > 0] <- "#da1735"
  input1$color[input1$value < 0] <- "#0070b2"
  
  
  # 手动添加注释 ----------
  
  if (!is.null(select)) {
    input2 <- input[input$id %in% select,]
    input <- input[!(input$id %in% select),]
    input2$color <- "#f7ae24"
  }
  
  # 添加手动选择的label
  
  if (!is.null(select)) {
    select_label <- input2
    select_label <- select_label[,(colnames(select_label) != "color")]
    top_label <- rbind(top_label, select_label)
    top_label <- top_label[!duplicated(top_label$id),]
  }
  
  
  # 设定颜色 ----------
  
  if (nrow(background_position) < 17) {
    col <- c("#A6D719", "#176EBF", "#00A8DE", "#AEE0E8",
             "#00A9A3", "#FBD324", "#F28A24", "#A52828",
             "#A37CB7", "#F2D7EE", "#CD6981", "#FBD0C0",
             "#F15E4C", "#ECB2C8", "#B2DBBF", "#CCDAD1")
  } else {
    col <- sample(c("#0070B2", "#5CB3DA", "#B8E3EA", "#DA1735", "#F15E4C", "#FF9F99",
                    "#A231A1", "#A37CB7", "#F2D7EE", "#B91372", "#E93B8C", "#ECB2C8",
                    "#FF7149", "#F7AE24", "#FBDD7E", "#679436", "#8BBE53", "#CDE391",
                    "#067D69", "#00A385", "#98D4C6", "#114B5F", "#028090", "#B2DBBF",
                    "#A23E48", "#CD6981", "#FBD0C0", "#788585", "#9CAEA9", "#CCDAD1"))
  }
  
  
  # 注释色块中的内容 ----------
  
  dfcol <- data.frame(x = c(1:nrow(background_position)),
                      y = 0, label = c(1:nrow(background_position)))
  dfcol$group <- background_position$cluster
  
  
  # 开始画图 ----------
  
  if (!is.null(select)) {
    
    ggplot() + 
      
      # 添加灰色背景色
      
      geom_rect(data = background_position,
                aes(xmin = start, xmax = end,
                    ymin = Min, ymax = Max),
                fill = "#525252", alpha = 0.05) + 
      
      # 添加点
      
      geom_jitter(data = input,
                  aes(x = number, y = value),
                  position = position_jitter(seed = 1),
                  size = 3, alpha = 0.3, 
                  color = input$color) + 
      
      geom_jitter(data = input1,
                  aes(x = number, y = value),
                  position = position_jitter(seed = 1),
                  size = 4, alpha = 1, 
                  color = input1$color) + 
      
      geom_jitter(data = input2,
                  aes(x = number, y = value),
                  position = position_jitter(seed = 1),
                  size = 5, alpha = 1, shape = 17,
                  color = input2$color) + 
      
      # 添加色块及相应的颜色
      
      geom_tile(data = dfcol,
                aes(x = x,y = y), height = 0.35,
                color = "black", alpha = 1, show.legend = F,
                fill = sample(col, nrow(background_position)))+
      
      geom_text(data = dfcol,
                aes(x = x, y = y, label = group),
                size = 5, color ="black") + 
      
      # 根据top_label标注基因名
      
      geom_text_repel(data = top_label,
                      aes(x = number, y = value, label = gene),
                      force = 1.2, size = 4,
                      min.segment.length = 100) + 
      
      scale_fill_manual(values = col) +
      labs(y = "Moderated effect size") + 
      
      theme_bw() + 
      theme(legend.position = "none",
            panel.grid.minor = element_blank(),
            panel.grid.major = element_blank(),
            axis.text = element_text(colour = "black", size = 15),
            axis.title = element_text(colour = "black", size = 15),
            axis.text.y = element_text(colour = 'black'),
            axis.text.x = element_blank(), 
            axis.title.x = element_blank(),
            panel.border = element_blank(),
            axis.ticks.x = element_blank(),
            axis.line.y = element_line(colour = "black")) + 
      
      scale_x_continuous(expand = c(0.01,0)) + # 不留边框
      scale_y_continuous(expand = c(0,0))
    
  } else {
    
    ggplot() + 
      
      # 添加灰色背景色
      
      geom_rect(data = background_position,
                aes(xmin = start, xmax = end,
                    ymin = Min, ymax = Max),
                fill = "#525252", alpha = 0.05) + 
      
      # 添加点
      
      geom_jitter(data = input,
                  aes(x = number, y = value),
                  position = position_jitter(seed = 1),
                  size = 3, alpha = 0.3, 
                  color = input$color) + 
      
      geom_jitter(data = input1,
                  aes(x = number, y = value),
                  position = position_jitter(seed = 1),
                  size = 4, alpha = 1, 
                  color = input1$color) + 
      
      # 添加色块及相应的颜色
      
      geom_tile(data = dfcol,
                aes(x = x,y = y), height = 0.35,
                color = "black", alpha = 1, show.legend = F,
                fill = sample(col, nrow(background_position)))+
      
      geom_text(data = dfcol,
                aes(x = x, y = y, label = group),
                size = 5, color ="black") + 
      
      # 根据top_label标注基因名
      
      geom_text_repel(data = top_label,
                      aes(x = number, y = value, label = gene),
                      force = 1.2, size = 4,
                      min.segment.length = 100) + 
      
      scale_fill_manual(values = col) +
      labs(y = "Moderated effect size") + 
      
      theme_bw() + 
      theme(legend.position = "none",
            panel.grid.minor = element_blank(),
            panel.grid.major = element_blank(),
            axis.text = element_text(colour = "black", size = 15),
            axis.title = element_text(colour = "black", size = 15),
            axis.text.y = element_text(colour = 'black'),
            axis.text.x = element_blank(), 
            axis.title.x = element_blank(),
            panel.border = element_blank(),
            axis.ticks.x = element_blank(),
            axis.line.y = element_line(colour = "black")) + 
      
      scale_x_continuous(expand = c(0.01,0)) + # 不留边框
      scale_y_continuous(expand = c(0,0))
    
  }
}



# compass数据处理 ==============================================================
# ==============================================================================

compass_norm <- function(reaction.data = name_data,
                         reaction.info = name_info) {
  library(data.table)
  library(stringr)
  
  data <- fread(reaction.data, header = T, sep = '\t', fill = T, data.table = F)
  data <- column_to_rownames(data, var = "V1")
  
  
  # 排除样本间差异小的reaction ----------
  
  FSbyMAD <- function(Data, cut.type="topk", value){
    mads=apply(Data,1,mad)
    feature_num=length(mads)
    hist(mads, breaks=feature_num*0.1, col="red",
         main="Expression (MAD) distribution",
         xlab="The MAD of feature")
    if(cut.type=="topk")
    {
      index= sort(mads,decreasing = TRUE,index.return=TRUE)
      if(value>nrow(Data))
      {
        value=nrow(Data)
        cat("Warning: beyond the original feature numnber")
      }
      cutoff=index$x[value]
      abline(v=cutoff,col = "blue",lty = 5,lwd=1.5)
      index=index$ix[1:value]
      selectData=Data[index,]
    }
    if(cut.type=="cutoff")
    {
      abline(v=value,col = "blue",lty = 5,lwd=1.5)
      index=which(mads>value)
      selectData=Data[index,]
    }
    selectData
  }
  
  data <- FSbyMAD(data, cut.type = "cutoff", value = 0.5)
  
  
  # 数据标准化 ----------
  
  data <- -log2(data + 1)
  data <- t(scale(t(data)))
  
  
  # 只保留pos的reaction ----------
  
  data <- data[str_detect(rownames(data), "_pos"),]
  rownames(data) <- gsub(pattern = "_pos", replacement = "", rownames(data))
  
  
  # 整合metadata并过滤 ----------
  
  info <- fread(reaction.info, sep = ",", header = T, check.names = F)
  info <- data.frame(id = info$reaction_no_direction,
                     name = info$reaction_name,
                     subsystem = info$subsystem,
                     confidence = info$confidence)
  
  data <- data.frame(data)
  data <- rownames_to_column(data, var = "id")
  
  data <- merge(info, data, by = "id")
  data <- data[data$confidence %in% c(0, 4),]
  
  # 整理结果
  
  rownames(data) <- NULL
  data <- column_to_rownames(data, var = "id")
  data <- data[,-c(1:3)]
  data
}



# GSEA barcode =================================================================
# ==============================================================================

gsea_barcode <- function(input = input,
                         geneset = geneset) {
  
  # ggplot2的版本是3.4.0
  # https://github.com/NicolasH2/gggsea#Customization
  
  # 封装函数1 ------------------------------
  
  geom_gsea <- function(
    df, labelsize=4, zeroline=F, prettyGSEA=T, ncol=NULL, nrow=NULL,
    linecolor="green", linesize=1,
    tickcolor="black", ticksize=0.5,
    zerocolor="black", zerosize=0.5, zerotype="dashed",
    ...
  ){
    
    nsets <- length(unique(df$set)) 
    linecolor <- rep(rep(linecolor, nsets)[1:nsets], each=nrow(df)/nsets) 
    linesize <- rep(rep(linesize, nsets)[1:nsets], each=nrow(df)/nsets)
    
    nticks <- unlist( lapply(unique(df$set), function(x) nrow(df[df$set %in% x & !is.na(df$y1ticks),])) )
    tickcolor <- rep(rep(tickcolor, nsets)[1:nsets], nticks) 
    ticksize <- rep(rep(ticksize, nsets)[1:nsets], nticks)
    
    gseaLine <- geom_gseaLine(df, color=linecolor, size=linesize, ...)
    ticks <- geom_gseaTicks(df[!is.na(df$y1ticks), ], color=tickcolor, size=ticksize, ...)
    gradient <- geom_gseaGradient(df[!is.na(df$y1gradient), ], ...)
    statistics <- ggplot2::geom_label(data=df[!is.na(df$stattext),],
                                      mapping = aes(x, ystat, label=stattext ),
                                      size=labelsize, hjust=0, vjust=0 , parse=T, alpha=.7, fill="white")
    
    main <- list(gseaLine, ticks, gradient, statistics,
                 ggplot2::facet_wrap(~set, scale="free_y", ncol=ncol, nrow=nrow)
    )
    if(zeroline){
      xmid <-
        main <- c(
          ggplot2::geom_segment(mapping=ggplot2::aes(x=zeroline, xend=zeroline, y=bottomline, yend=Inf),
                                data=df[!duplicated(df$set),],
                                color=zerocolor, size=zerosize, linetype=zerotype),
          main)
    }
    
    if(prettyGSEA){
      
      break_fun <- function(y){
        maxY <- max(y) 
        minY <- min(y)
        sizeFactor <- abs(maxY-minY)
        minY <- minY + sizeFactor * 0.22
        ystepsize <- signif(sizeFactor/4, digits=1) 
        
        nDown <- ceiling(minY / ystepsize) 
        nUp <- round(maxY / ystepsize) 
        breaks <- c(
          seq(from = nDown * ystepsize, to = 0, by = ystepsize),
          seq(from = 0, to = nUp * ystepsize,    by = ystepsize)
        )
        return(breaks)
      }
      main <- c(list(
        geom_hline( mapping = aes(yintercept=bottomline), data = df[!duplicated(df$set),] ),
        geom_hline(yintercept=0),
        labs(x="rank", y="enrichment score"),
        scale_y_continuous(breaks=break_fun),
        main
      ))
    }
    return( main )
  }
  
  # 封装函数2 ------------------------------
  
  geom_gseaLine <- function(df, ...){
    
    gseaLine <- ggplot2::layer(
      data = df,
      mapping = ggplot2::aes(x=x, y=y),
      geom = "path",
      stat = "identity",
      position = "identity",
      show.legend = FALSE,
      inherit.aes = TRUE,
      params=list(lineend="round", ...)
    )
    userInput <- names(as.list(match.call())) #get all parameters set by the user
    if(!any(c("color","colour") %in% userInput)) gseaLine$aes_params[["colour"]] <- "green"
    if(!"size" %in% userInput) gseaLine$aes_params[["size"]] <- 1
    
    return(gseaLine)
  }
  
  # 封装函数3 ------------------------------
  
  geom_gseaTicks <- function(df, ...){
    
    gseaTicks <- ggplot2::layer(
      data = df,
      mapping = ggplot2::aes(x=x, y=y1ticks, xend=x, yend=y2ticks),
      geom = "segment",
      stat = "identity",
      position = "identity",
      show.legend = FALSE,
      inherit.aes = TRUE,
      params=list(...)
    )
    userInput <- names(as.list(match.call())) #get all parameters set by the user
    if(!"size" %in% userInput) gseaTicks$aes_params[["size"]] <- 0.2
    
    return(gseaTicks)
  }
  
  # 封装函数4 ------------------------------
  
  gseaCurve <- function(rl, setlist, gsea=NULL, weight=1){
    
    dfList <- mapply(function(set, setname){
      if( sum(set %in% names(rl))==0 ) stop("None of the genes in the ranked list are present in the set.")
      
      set <- set[set %in% names(rl)]
      
      presence <- rep(0,length(rl))
      positions <- which(names(rl) %in% set)
      presence[positions] <- abs(rl[positions])^weight
      
      absence <- rep(1,length(rl))
      absence[positions] <- 0
      
      cumPresence <- cumsum(presence)
      relPresence <- sapply(cumPresence, function(x) x/max(cumPresence)) 
      relAbsence <- cumsum(absence) / (length(rl) - length(set))
      
      es <- relPresence-relAbsence 
      xcoord <- seq_along(es)
      
      df <- data.frame(x = c(0,xcoord), y = c(0,es), set = setname, gene=c(0, names(rl)) )
      
      maxES <- max(df$y)
      minES <- min(df$y)
      sizeFactor <- abs(maxES - minES)
      lowestPoint <- minES - sizeFactor / 30
      df$bottomline <- lowestPoint
      df$zeroline <- median(which(rl==sort(abs(rl))[1]))
      
      statdf <- data.frame(x = 0,
                           ystat = lowestPoint+sizeFactor*.02,
                           stattext = NA )
      
      if(!is.null(gsea)){
        subgsea <- gsea[gsea$pathway %in% setname,]
        statdf$stattext = paste0("atop(italic(NES)==",as.character(round(subgsea$NES, 2)),
                                 ",italic(p)==",      as.character(round(subgsea$pval,4)),")")
      }
      df <- merge(df, statdf, by="x", all=T) 
      
      df <- merge(df, .presenceTicks(rl, set, lowestPoint, sizeFactor), by="x", all=TRUE)
      lowestPoint <- min(df$y2ticks, na.rm=TRUE) 
      
      df <- merge(df, .colorGradient(rl, lowestPoint, sizeFactor), by="x", all=TRUE)
      return(df)
      
    }, set=setlist, setname=names(setlist), SIMPLIFY=FALSE)
    df <- do.call(rbind, dfList)
    return(df)
  }
  
  .presenceTicks <- function(rl, set, lowestPoint, sizeFactor){
    
    ticks <- data.frame(x = which(names(rl) %in% set),
                        y1ticks = lowestPoint - sizeFactor / 40,
                        y2ticks = lowestPoint - sizeFactor / 8,
                        hitgene = names(rl[names(rl) %in% set]))
    return(ticks)
  }
  
  .colorGradient <- function(rl, lowestPoint, sizeFactor, lowcol="blue", midcol="white", highcol="red", resolution=20){
    
    gradient <- unlist(lapply(seq(0,1,length.out=resolution/2+1), function(x) dplyr::nth(sort(abs(rl)), as.integer(length(rl)*x)) ))
    gradient <- gradient[-1]
    gradient <- sort(c(gradient,-gradient))
    gradient <- data.frame(valueMax=gradient[-1])
    
    colfunc1 <- grDevices::colorRampPalette(c(highcol, midcol)) 
    colfunc2 <- grDevices::colorRampPalette(c(midcol, lowcol))
    gradient$color <- c(colfunc1(resolution/2), colfunc2(resolution/2)[-1])
    
    gradient$x <- sapply( gradient$valueMax, function(x) sum(rl <= x) )
    gradient <- gradient[!duplicated(gradient$x),]
    gradient$xGradientStart <- c( 1, gradient$x[-nrow(gradient)] )
    
    gradient$y1gradient <- lowestPoint
    gradient$y2gradient <- lowestPoint - sizeFactor / 8
    return(gradient)
  }
  
  
  # 开始画图 ------------------------------
  
  library(clusterProfiler)
  library(ggplot2)
  library(aplot)
  
  # 整理数据
  
  input <- input[order(input$value, decreasing = T),]
  data <- input$value
  names(data) <- input$id
  
  # 进行GSEA分析
  
  gsea <- gseaCurve(data, geneset)
  
  # 计算ES和pvalue
  
  geneset <- data.frame(term = names(geneset), gene = geneset[[1]])
  stat <- GSEA(data, TERM2GENE = geneset,
               minGSSize = 1, maxGSSize = 5000,
               pvalueCutoff = 1)
  
  NES <- stat$NES
  pvalue <- stat$qvalue
  
  # 注释文字
  
  label <- paste0("NES: ", round(NES, 2), "; ", "Adjust P: ", pvalue)
  
  # 画line plot
  
  p1 <- ggplot() + geom_gseaLine(gsea, color= "black", size = 0.5) + 
    geom_hline(yintercept = 0, color = "grey20",
               linetype = "dashed") + 
    
    annotate(geom = "text", x = -Inf, y = -Inf,
             hjust = -0.1, vjust = -1.5, size = 5, label = label) + 
    
    theme_classic() +
    theme(axis.title.x = element_blank(),
          panel.grid = element_blank(), 
          axis.ticks.x = element_blank(), 
          axis.text.x = element_blank(),
          axis.text = element_text(colour = "black", size = 15),
          axis.title = element_text(colour = "black", size = 15),
          plot.title = element_text(size = 16)) + 
    
    scale_x_continuous(expand = c(0,0)) + # 不留边框
    scale_y_continuous(expand = c(0.03,0.03)) + 
    labs(y = "ES") + ggtitle(unique(geneset[,1]))
  
  # 画barcode plot
  
  p2 <- ggplot() + geom_gseaTicks(gsea, color= "#F9FB0E", size = 0.5) +
    
    theme_bw() +
    theme(panel.background = element_rect(fill = "#352A87",
                                          colour = "#352A87",
                                          size = 0.5, linetype = "solid"),
          axis.title = element_blank(),
          panel.grid = element_blank(), # 删去网格线
          axis.ticks = element_blank(), # 删去刻度线
          axis.text = element_blank()) + # 删去刻度标签
    
    scale_x_continuous(expand = c(0,0)) + # 不留边框
    scale_y_continuous(expand = c(0,0))
  
  # 组合图形
  
  p1 %>% 
    insert_bottom(p2, height = 0.7)
}



# annotation bar ====================

annotation_bar <- function(input = input,
                           lwd = 0.5,
                           order.keep = T,
                           show.name = T) {
  
  library(ggplot2)
  library(forcats)
  library(reshape2)
  
  # 保留原来的名字顺序
  
  if (order.keep == T) {
    input$id <- fct_inorder(input$id)
  }
  
  # 开始画图
  
  if (ncol(input) == 2) {
    
    input <- data.frame(input)
    input$name <- "name"
    input$value <- input$type
    
    plot <- ggplot(input, aes(x = id, y = name)) +
      geom_tile(aes(fill = type), color = "white", linewidth = lwd)
    
  } else {
    
    input <- data.frame(input)
    input <-  melt(input,id = "id")
    
    plot <- ggplot(input, aes(x = id, y = variable)) +
      geom_tile(aes(fill = value), color = "white", linewidth = lwd)
    
  }
  
  # 设定颜色
  
  if (length(unique(input$value)) < 17) {
    col <- c("#A6D719", "#176EBF", "#00A8DE", "#AEE0E8",
             "#00A9A3", "#FBD324", "#F28A24", "#A52828",
             "#A37CB7", "#F2D7EE", "#CD6981", "#FBD0C0",
             "#F15E4C", "#ECB2C8", "#B2DBBF", "#CCDAD1")
  } else {
    col <- sample(c("#0070B2", "#5CB3DA", "#B8E3EA", "#DA1735", "#F15E4C", "#FF9F99",
                    "#A231A1", "#A37CB7", "#F2D7EE", "#B91372", "#E93B8C", "#ECB2C8",
                    "#FF7149", "#F7AE24", "#FBDD7E", "#679436", "#8BBE53", "#CDE391",
                    "#067D69", "#00A385", "#98D4C6", "#114B5F", "#028090", "#B2DBBF",
                    "#A23E48", "#CD6981", "#FBD0C0", "#788585", "#9CAEA9", "#CCDAD1"))
  }
  
  plot <- plot + scale_fill_manual(values = col)
  
  # 保留名字
  
  if (show.name == T) {
    plot <- plot +
      theme_bw() + 
      theme(legend.position = "bottom",
            legend.title = element_blank(),
            panel.grid = element_blank(),
            axis.title = element_blank(),
            axis.ticks = element_blank(),
            panel.border = element_blank())
  } else {
    plot <- plot + 
      theme_bw() + 
      theme(legend.position = "bottom",
            legend.title = element_blank(),
            panel.grid = element_blank(),
            axis.text = element_blank(),
            axis.title = element_blank(),
            axis.ticks = element_blank(),
            panel.border = element_blank())
  }
  
  plot
}



# 蛋白表达分组后差异 ===========================================================
# ==============================================================================

protein_group_diff <- function(pro.obj = subpro,
                               pro.name = "CD49f",
                               var.obj = subdata,
                               var.name = "CD36",
                               thres = 0.9) {
  library(ggplot2)
  library(tibble)
  
  # 整理数据
  
  subpro <- data.frame(ntype = t(GetAssayData(pro.obj, slot = "data"))[,pro.name])
  subdata <- data.frame(value = t(GetAssayData(var.obj, slot = "data"))[,var.name])
  
  subpro <- rownames_to_column(subpro, var = "id")
  subdata <- rownames_to_column(subdata, var = "id")
  input <- merge(subpro, subdata, by = "id")
  
  # 二分类数据
  
  input$type <- "M"
  input$type[input$ntype > quantile(input$ntype, probs = thres)] <- "H"
  input$type[input$ntype < quantile(input$ntype, probs = 1 - thres)] <- "L"
  input <- input[input$type != "M",]; input <- input[,-c(1:2)]
  
  # 开始画图
  
  ggplot(input, aes(x = type, y = value, fill = type)) +
    stat_boxplot(geom = "errorbar", width = 0, color = "black") +
    geom_boxplot(alpha = 1, outlier.shape = NA, size = 0.7, width = 0.7) + 
    
    geom_quasirandom(width = 0.3, size = 2, alpha = 0.2) + 
    scale_fill_manual(values=c("#FBD324", "#A37CB7")) + 
    
    stat_compare_means(method = "t.test", size = 5,
                       label.x = 1.1, label.y = 0.99*max(input$value)) + 
    
    theme_bw() + 
    theme(panel.grid = element_blank(),
          legend.position = "none", # 去除图例
          axis.text = element_text(colour = "black", size = 15), 
          axis.title = element_text(colour = "black", size = 15),
          panel.border = element_rect(fill = NA, color = "black", linewidth = 1)) + 
    labs(x = '', y = 'Gene activity',title = '')
}



# reference mapping ============================================================
# ==============================================================================

# label and coord mapping ====================

refmapping <- function(refer = refer,
                       query = query,
                       method = "rpca", k.weight = 50,
                       refer.label = "cluster",
                       refer.coord = "dm") {
  
  library(Seurat) # v4.3.0
  
  # 进行数据映射
  
  if (method == "rpca") {
    
    anchors <- FindTransferAnchors(reference = refer, query = query, 
                                   normalization.method = "LogNormalize", 
                                   reduction = "rpca")
    
    refer$cellname <- colnames(refer)
    predict <- TransferData(anchorset = anchors,
                            reference = refer, query = query,
                            refdata = list(cell = "cellname",
                                           cluster = refer.label),
                            k.weight = k.weight)
    
  } else if (method == "cca") {
    
    anchors <- FindTransferAnchors(reference = refer, query = query, 
                                   normalization.method = "LogNormalize", 
                                   reduction = "cca")
    
    refer$cellname <- colnames(refer)
    predict <- TransferData(anchorset = anchors,
                            reference = refer, query = query, 
                            weight.reduction = "cca",
                            refdata = list(cell = "cellname",
                                           cluster = refer.label),
                            k.weight = k.weight)
    
  } else if (method == "pca") {
    
    anchors <- FindTransferAnchors(reference = refer, query = query, 
                                   normalization.method = "LogNormalize", 
                                   reduction = "pcaproject")
    
    refer$cellname <- colnames(refer)
    predict <- TransferData(anchorset = anchors,
                            reference = refer, query = query, 
                            refdata = list(cell = "cellname",
                                           cluster = refer.label),
                            k.weight = k.weight)
  }
  
  # 整理结果
  
  predict <- data.frame(id = colnames(predict),
                        map_cell = predict$predicted.cell,
                        map_cell_score = predict$predicted.cell.score,
                        map_cluster = predict$predicted.cluster,
                        map_cluster_score = predict$predicted.cluster.score)
  
  # 整合坐标
  
  coord <- data.frame(Embeddings(refer, refer.coord))
  coord <- rownames_to_column(coord, var = "map_cell")
  predict <- merge(predict, coord, by = "map_cell")
  
  data.frame(id = predict$id,
             map_cell = predict$map_cell,
             map_cluster = predict$map_cluster,
             map_cell_score = predict$map_cell_score,
             map_cluster_score = predict$map_cluster_score,
             coord_x = predict[,6],
             coord_y = predict[,7])
}


# 整合refmapping结果 ====================

refmapping_seurat <- function(query = query,
                              mapdata = mapdata,
                              mapdata.cutoff = 0.5) {
  library(Seurat)
  library(ggplot2)
  library(viridis)
  library(tibble)
  
  # 过滤数据
  
  mapdata <- mapdata[mapdata$map_cluster_score > mapdata.cutoff,]
  query <- query[,mapdata$id]
  
  # 整合metadata
  
  rownames(mapdata) <- NULL
  mapdata <- column_to_rownames(mapdata, var = "id")
  query <- AddMetaData(query, mapdata)
  
  # 整合坐标
  
  coord <- mapdata[,c("coord_x", "coord_y")]
  names(coord)[1:2] <- c("coord_1", "coord_2")
  query[["refmapping"]] <- CreateDimReducObject(as.matrix(coord), key = "coord")
  query
}


# 密度图可视化 (适用于所有降维情况) ====================

refmapping_plot <- function(refer = refer,
                            refer.coord = "dm",
                            mapdata = mapdata,
                            mapdata.cutoff = 0.5,
                            pt.size = 1,
                            resolution = 1) {
  library(Seurat)
  library(ggplot2)
  library(viridis)
  
  # 过滤数据
  
  raw <- nrow(mapdata)
  mapdata <- mapdata[mapdata$map_cluster_score > mapdata.cutoff,]
  
  filter <- nrow(mapdata)
  prop <- round(filter / raw, 2)
  
  # 整理输入数据
  
  refdata <- Embeddings(refer, reduction = refer.coord) %>% data.frame()
  mapdata <- data.frame(x = mapdata$coord_x, y = mapdata$coord_y)
  
  # 散点图
  
  plot1 <- ggplot(refdata, aes(x = refdata[,1],y = refdata[,2])) + 
    geom_point(color = "grey90", size = pt.size) + 
    geom_point(data = mapdata, aes(x = mapdata[,1],y = mapdata[,2]),
               color = "#8A2C74", size = pt.size) + 
    
    annotate(geom = "text", x = -Inf, y = Inf,
             hjust = -0.1, vjust = 2,
             label = paste0("n cell: ", filter, " / ", raw, ", ", prop)) + 
    
    labs(x = 'UMAP1',y= 'UMAP2',title = '') + 
    guides(colour = guide_legend(override.aes = list(size = 3))) + 
    
    theme_bw() + 
    theme(strip.background = element_rect(colour = NA, fill = 'grey90'),
          legend.position = "none",
          axis.title = element_text(colour = "black", size = 15), 
          panel.grid = element_blank(),
          strip.placement = 'outside',
          axis.ticks = element_blank(),
          axis.text = element_blank())
  
  # 密度图
  
  plot2 <- ggplot(mapdata, aes(x = mapdata[,1],y = mapdata[,2])) + 
    
    stat_density_2d(aes(fill = ..density..), geom = "raster",
                    h = resolution, contour = FALSE) + 
    
    geom_density2d(size = 0.1, colour = "#FDAF9199",
                   bins = 10, h = resolution) +
    
    geom_point(data = refdata, aes(x = refdata[,1],y = refdata[,2]),
               color = "grey90", size = pt.size) + 
    
    scale_fill_viridis(option = "magma") + 
    labs(x = 'UMAP1',y= 'UMAP2',title = '') + 
    guides(colour = guide_legend(override.aes = list(size = 3))) + 
    
    theme_bw() + 
    theme(strip.background = element_rect(colour = NA, fill = 'grey90'),
          strip.text.x = element_text(size = 15), 
          panel.grid = element_blank(),
          strip.placement = 'outside',
          axis.ticks = element_blank(),
          axis.text = element_blank()) + 
    
    scale_x_continuous(expand = c(0,0)) +
    scale_y_continuous(expand = c(0,0))
  
  # 图形整合
  
  plot1 + plot2
}


# data mapping ====================

mapping_data <- function(refer = refer,
                         refer.data = data,
                         query = query,
                         method = "rpca",
                         k.weight = 50) {
  
  library(Seurat) # v4.3.0
  
  # 进行数据映射
  
  if (method == "rpca") {
    
    anchors <- FindTransferAnchors(reference = refer, query = query, 
                                   normalization.method = "LogNormalize", 
                                   reduction = "rpca")
    
    predict <- TransferData(anchorset = anchors,
                            reference = refer, 
                            refdata = refer.data,
                            k.weight = k.weight)
    
  } else if (method == "cca") {
    
    anchors <- FindTransferAnchors(reference = refer, query = query, 
                                   normalization.method = "LogNormalize", 
                                   reduction = "cca")
    
    predict <- TransferData(anchorset = anchors,
                            reference = refer, 
                            weight.reduction = "cca",
                            refdata = refer.data,
                            k.weight = k.weight)
    
  } else if (method == "pcaproject") {
    
    anchors <- FindTransferAnchors(reference = refer, query = query, 
                                   normalization.method = "LogNormalize", 
                                   reduction = "pcaproject")
    
    predict <- TransferData(anchorset = anchors,
                            reference = refer, 
                            refdata = refer.data,
                            k.weight = k.weight)
  }
  
  # 整理结果
  
  predict <- CreateSeuratObject(predict)
  predict@meta.data <- query@meta.data
  predict@reductions <- query@reductions
  predict
}


# umap mapping ====================

mapping_umap <- function(refer = refer,
                         query = query,
                         method = "cca",
                         umap.name = "umap_mapping",
                         k.weight = 50) {
  
  library(Seurat) # v4.3.0
  
  # 重新运行umap
  
  dims = refer@commands[["RunUMAP.RNA.pca"]]$dims
  reduction = refer@commands[["RunUMAP.RNA.pca"]]$reduction
  n.neighbors = refer@commands[["RunUMAP.RNA.pca"]]$n.neighbors
  min.dist = refer@commands[["RunUMAP.RNA.pca"]]$min.dist
  seed.use = refer@commands[["RunUMAP.RNA.pca"]]$seed.use
  
  refer <- RunUMAP(refer, dims = dims,
                   reduction = reduction, 
                   reduction.name = "umap", 
                   n.neighbors = n.neighbors, min.dist = min.dist,
                   seed.use = seed.use,
                   return.model = TRUE)
  
  # 进行数据映射
  
  if (method == "rpca") {
    
    anchors <- FindTransferAnchors(reference = refer, query = query, 
                                   normalization.method = "LogNormalize",
                                   reference.reduction = "pca",
                                   reduction = "rpca")
    
    predict <- MapQuery(anchorset = anchors,
                        reference = refer, query = query, 
                        reduction.model = "umap",
                        transferdata.args = list(k.weight = k.weight),
                        projectumap.args = list(reduction.name = umap.name))
    
  } else if (method == "cca") {
    
    anchors <- FindTransferAnchors(reference = refer, query = query, 
                                   normalization.method = "LogNormalize",
                                   reduction = "cca")
    
    predict <- MapQuery(anchorset = anchors,
                        reference = refer, query = query, 
                        reduction.model = "umap",
                        transferdata.args = list(k.weight = k.weight),
                        projectumap.args = list(reduction.name = umap.name))
  } else {
    
    anchors <- FindTransferAnchors(reference = refer, query = query, 
                                   normalization.method = "LogNormalize", 
                                   reference.reduction = "pca",
                                   dims = 1:50)
    
    predict <- MapQuery(anchorset = anchors,
                        reference = refer, query = query,
                        reference.reduction = "pca",
                        reduction.model = "umap",
                        transferdata.args = list(k.weight = k.weight),
                        projectumap.args = list(reduction.name = umap.name))
  }
  
  predict
}


# refer - query 对比图 ====================

mapping_integ_plot <- function(refer = refer,
                               query = query,
                               refer.coord = "umap",
                               query.coord = "umap_mapping") {
  library(Seurat)
  library(ggplot2)
  library(cowplot)
  
  # 重新运行umap
  
  dims = refer@commands[["RunUMAP.RNA.pca"]]$dims
  reduction = refer@commands[["RunUMAP.RNA.pca"]]$reduction
  n.neighbors = refer@commands[["RunUMAP.RNA.pca"]]$n.neighbors
  min.dist = refer@commands[["RunUMAP.RNA.pca"]]$min.dist
  seed.use = refer@commands[["RunUMAP.RNA.pca"]]$seed.use
  
  refer <- RunUMAP(refer, dims = dims,
                   reduction = reduction, 
                   reduction.name = "umap", 
                   n.neighbors = n.neighbors, min.dist = min.dist,
                   seed.use = seed.use,
                   return.model = TRUE)
  
  # 提取坐标数据
  
  refdata <- Embeddings(refer, reduction = refer.coord) %>% data.frame()
  refdata$type <- "refer"; names(refdata)[1:2] <- c("a", "b")
  
  quydata <- Embeddings(query, reduction = query.coord) %>% data.frame()
  quydata$type <- "query"; names(quydata)[1:2] <- c("a", "b")
  
  # 整合数据
  
  input <- rbind(refdata, quydata)
  
  # 散点图 ----------
  
  plot1 <- ggplot(input, aes(x = input[,1],y = input[,2])) + 
    geom_point(aes(color = type), size = 0.5) + 
    scale_color_manual(values = c("#8A2C74", "grey90")) + 
    
    labs(x = 'UMAP1',y= 'UMAP2',title = '') + 
    guides(colour = guide_legend(override.aes = list(size = 3))) + 
    
    theme_bw() + 
    theme(strip.background = element_rect(colour = NA, fill = 'grey90'),
          legend.position = "none",
          axis.title = element_text(colour = "black", size = 15), 
          panel.grid = element_blank(),
          strip.placement = 'outside',
          axis.ticks = element_blank(),
          axis.text = element_blank())
  
  # 密度图1 ----------
  
  plot2 <- ggplot(refdata, aes(x = refdata[,1],y = refdata[,2])) + 
    geom_point(color = "grey90", size = 1) + 
    
    geom_bin2d(data = quydata, aes(x = quydata[,1], y = quydata[,2]), bins = 90) + 
    scale_fill_viridis(option = "magma") + 
    
    labs(x = 'UMAP1',y = 'UMAP2',title = '') + 
    guides(colour = guide_legend(override.aes = list(size = 3))) + 
    
    theme_bw() + 
    theme(legend.position = "none",
          strip.background = element_rect(colour = NA, fill = 'grey90'),
          strip.text.x = element_text(size = 15),
          axis.title = element_text(colour = "black", size = 15),
          panel.grid = element_blank(),
          strip.placement = 'outside',
          axis.ticks = element_blank(),
          axis.text = element_blank()) + 
    
    scale_x_continuous(expand = c(0,0)) +
    scale_y_continuous(expand = c(0,0))
  
  # 密度图2 ----------
  
  plot3 <- ggplot(refdata, aes(x = refdata[,1],y = refdata[,2])) + 
    geom_point(color = "grey70", size = 1) + 
    
    stat_density_2d(data = quydata, aes(x = quydata[,1],y = quydata[,2]),
                    size = 0.2, colour = "black", bins = 10, h = 3) + 
    
    labs(x = 'UMAP1',y= 'UMAP2',title = '') + 
    guides(colour = guide_legend(override.aes = list(size = 3))) + 
    
    theme_bw() + 
    theme(strip.background = element_rect(colour = NA, fill = 'grey90'),
          strip.text.x = element_text(size = 15), 
          panel.grid = element_blank(),
          strip.placement = 'outside',
          axis.ticks = element_blank(),
          axis.text = element_blank()) + 
    
    scale_x_continuous(expand = c(0,0)) +
    scale_y_continuous(expand = c(0,0))
  
  # 密度图3 ----------
  
  plot4 <- ggplot(quydata, aes(x = quydata[,1],y = quydata[,2])) + 
    
    stat_density_2d(aes(fill = ..density..), geom = "raster",
                    h = 3, contour = FALSE) + 
    
    geom_density2d(size = 0.1, colour = "#FDAF9199",
                   bins = 10, h = 3) +
    
    geom_point(data = refdata, aes(x = refdata[,1],y = refdata[,2]),
               color = "grey90", size = 0.1) + 
    
    scale_fill_viridis(option = "magma") + 
    labs(x = 'UMAP1',y= 'UMAP2',title = '') + 
    guides(colour = guide_legend(override.aes = list(size = 3))) + 
    
    theme_bw() + 
    theme(legend.position = "none",
          strip.background = element_rect(colour = NA, fill = 'grey90'),
          strip.text.x = element_text(size = 15), 
          panel.grid = element_blank(),
          strip.placement = 'outside',
          axis.ticks = element_blank(),
          axis.text = element_blank()) + 
    
    scale_x_continuous(expand = c(0,0)) +
    scale_y_continuous(expand = c(0,0))
  
  # 整合图形 ----------
  
  allplot <- list(plot1, plot2, plot3, plot4)
  plot_grid(plotlist = allplot, ncol = 2)
}



# dotplot ======================================================================
# ==============================================================================

dotplot_marker <- function(data = datafilt,
                           group.by = "cluster",
                           marker = select,
                           species = "human",
                           width = 15,
                           height = 6,
                           output = name){
  
  library(Seurat)
  library(ggpubr)
  
  # 设置marker
  
  if (is.null(species)) {
    
    gene_list <- marker
    
  } else if (species == "human") {
    
    Tcell = c("CD3D", "CD3E")
    CD8T = c("CD8A", "CD8B")
    CD4T = c("CD4")
    Treg = c("FOXP3", "IL2RA", "IL7R")
    NKcell = c("KLRD1", "NKG7", "NCAM1","FCGR3A")
    Bcell = c("CD19", "CD79A", "MS4A1")
    Plasma = c("IGKC", "IGLC2", "TNFRSF17")
    Macro = c("APOC1", "SPP1", "C1QC")
    Mono = c("FCN1", "S100A8", "S100A9")
    cDC = c("FCER1A", "CD207", "XCR1")
    pDC = c("IL3RA", "LILRA4")
    MAST = c("KIT", "MS4A2")
    Neu = c("FCGR3B", "CEACAM8", "CSF3R")
    Fibro = c("COL1A1", "COL1A2")
    Endo = c("PECAM1", "VWF")
    hepatocyte = c("ALB", "CYP3A4", "HNF4A")
    biliary = c("EPCAM", "KRT7", "KRT19")
    
    gene_list <- list(Tcell = Tcell,
                      CD8T = CD8T,
                      CD4T = CD4T,
                      Treg = Treg,
                      NKcell = NKcell,
                      Bcell = Bcell,
                      Plasma = Plasma,
                      Macro = Macro,
                      Mono = Mono,
                      cDC = cDC,
                      pDC = pDC,
                      MAST = MAST,
                      Neu = Neu,
                      Fibro = Fibro,
                      Endo = Endo,
                      hepatocyte = hepatocyte,
                      biliary = biliary)
    
  } else if (species == "mouse") {
    
    Tcell = c("Cd3d", "Cd3e")
    CD8T = c("Cd8a", "Cd8b1")
    CD4T = c("Cd4")
    Treg = c("Foxp3", "Il2ra", "Il7r")
    NKcell = c("Klrd1", "Nkg7", "Ncam1")
    Bcell = c("Cd19", "Cd79a", "Ms4a1")
    Plasma = c("Igkc", "Tnfrsf17")
    Macro = c("Apoc1", "Spp1", "C1qc")
    Mono = c("S100a8", "S100a9")
    cDC = c("Fcer1a", "Cd207", "Xcr1")
    pDC = c("Il3ra", "Gm14548")
    MAST = c("Kit", "Ms4a2")
    Neu = c("Csf3r", "Fut4")
    Fibro = c("Col1a1", "Col1a2")
    Endo = c("Pecam1", "Vwf")
    hepatocyte = c("Alb", "Cyp3a11", "Hnf4a")
    biliary = c("Epcam", "Krt7", "Krt19")
    
    gene_list <- list(Tcell = Tcell,
                      CD8T = CD8T,
                      CD4T = CD4T,
                      Treg = Treg,
                      NKcell = NKcell,
                      Bcell = Bcell,
                      Plasma = Plasma,
                      Macro = Macro,
                      Mono = Mono,
                      cDC = cDC,
                      pDC = pDC,
                      MAST = MAST,
                      Neu = Neu,
                      Fibro = Fibro,
                      Endo = Endo,
                      hepatocyte = hepatocyte,
                      biliary = biliary)
    
  }
  
  # 设置颜色
  
  col <- colorRampPalette(c("#0070b2","#009bc7","#b8e3ea",
                            "#f3f3f1","#fccdb9", "#f15e4c","#da1735"))(100)
  
  # 开始画图
  
  plot <- DotPlot(data, scale = T, col.min = -1,
                  group.by = group.by, col.max = 1, features = gene_list) + 
    scale_color_gradientn(colors = col) + 
    theme_bw()+
    theme(legend.position = "right", legend.box = "vertical",
          legend.margin = margin(t = 0, unit='cm'),
          panel.grid = element_blank(),
          axis.text = element_text(color = "black", size = 12),
          legend.text = element_text(size = 12,color = "black"),
          legend.title = element_text(size = 12,color = "black")) + 
    labs(x = '', y = '', title = '') + rotate_x_text(45)
  
  # 保存结果
  
  if (is.null(output)) {
    plot
  } else {
    ggsave(output, plot, width = width, height = height)
  }
  
}



# bulk survival analysis =======================================================
# ==============================================================================

survival_gene_plots <- function(cohort = HCC_cohorts,
                                regulon = regulon_list,
                                select = "ITGA6",
                                is.viper = FALSE,
                                group.by = "optimal") {
  library(tibble)
  library(ggplot2)
  library(ggpubr)
  library(viper)
  library(survival)
  library(survminer)
  
  # 读入函数1 ----------
  
  survival_curve_gene <- function(input = input,
                                  select = select,
                                  group.by = "optimal",
                                  name = "cohort") {
    library(survival)
    library(survminer)
    
    # 确定阈值
    
    if (group.by == "median") {
      
      thres <- median(input$value)
      input$type <- ifelse(input$value > thres, "H", "L")
      
    } else if (group.by == "quantile") {
      
      thres1 <- quantile(input$value, probs = c(0.75), na.rm = T)
      thres2 <- quantile(input$value, probs = c(0.25), na.rm = T)
      input$type <- NA
      input$type[input$value > thres1] <- "H"
      input$type[input$value < thres2] <- "L"
      input <- na.omit(input)
      
    } else if (group.by == "optimal") {
      
      thres <- surv_cutpoint(input, time = "time", minprop = 0.15,
                             event = "status", variables = "value")
      thres <- thres$cutpoint[[1]]
      input$type <- ifelse(input$value > thres, "H", "L")
      
    }
    
    # 计算p值
    
    my.surv <- Surv(input$time, input$status)
    data.survdiff <- survdiff(my.surv ~ input$type)
    p.val = 1 - pchisq(data.survdiff$chisq, length(data.survdiff$n) - 1)
    
    # 计算HR
    
    mycox <- coxph(Surv(time,status) ~ value, data = input)
    coxResult <- summary(mycox)
    
    HR = coxResult$coefficients[,"exp(coef)"]
    lower_95CI = coxResult$conf.int[,3]
    upper_95CI = coxResult$conf.int[,4]
    
    HR <- paste("Hazard Ratio = ", round(HR,2), sep = "")
    CI <- paste("95% CI: ", paste(round(lower_95CI, 2),
                                  round(upper_95CI, 2), sep = " - "), sep = "")
    
    # 基本信息
    
    number_H <- paste("number H = ", sum(input$type == "H"), sep = "")
    number_L <- paste("number L = ", sum(input$type == "L"), sep = "")
    cutoff <- paste("cutoff = ", round(thres, 3), sep = "")
    
    # 开始画图
    
    if (group.by != "quantile") {
      
      fit <- survfit(Surv(time, status) ~ type, data = input)
      ggsurvplot(fit, data = input, size = 1, palette = c("#f63a4e","#0089c1"), 
                 risk.table = F, conf.int = F,
                 conf.int.style = "step", ncensor.plot = FALSE, censor = F,
                 font.legend = 12, font.title = 12, font.x = 12, font.y = 12,
                 pval = paste(pval = ifelse(p.val < 0.001, "p < 0.001", 
                                            paste("P = ",round(p.val,3), sep = "")),
                              HR, CI, number_H, number_L, cutoff, sep = "\n"),
                 legend.title = name)
      
    } else {
      
      fit <- survfit(Surv(time, status) ~ type, data = input)
      ggsurvplot(fit, data = input, size = 1, palette = c("#f63a4e","#0089c1"), 
                 risk.table = F, conf.int = F,
                 conf.int.style = "step", ncensor.plot = FALSE, censor = F,
                 font.legend = 12, font.title = 12, font.x = 12, font.y = 12,
                 pval = paste(pval = ifelse(p.val < 0.001, "p < 0.001", 
                                            paste("P = ",round(p.val,3), sep = "")),
                              HR, CI, sep = "\n"),
                 legend.title = name)
    }
  }
  
  # 读入函数2 ----------
  
  RankTransform <- function(dat.mat) {
    rank.mat <- apply(dat.mat, 2, rank)
    median <- apply(rank.mat, 1, median)
    mad <- apply(rank.mat, 1, mad)
    rank.mat <- (rank.mat - median) / mad
    return(rank.mat)
  }
  
  # 批量作图 ----------
  
  if (class(cohort) == "list") {
    
    all_plots <- lapply(names(cohort), function(i) {
      
      data <- cohort[[i]]
      
      # 蛋白活性预测 
      
      if (is.viper == TRUE) {
        
        info <- data[,c(1:3)]
        data <- column_to_rownames(data, var = "id")
        data <- t(data[,-c(1:2)])
        
        # VIPER数据预处理
        
        data <- as.matrix(data)
        data <- RankTransform(data)
        
        # Meta VIPER
        
        data <- viper(data, regulon,
                      minsize = 25, cores = 10, method = 'none')
        
        # 整理结果
        
        data <- t(data)
        data <- data[info$id,]
        
      } else {
        
        info <- data[,c(1:3)]
        data <- column_to_rownames(data, var = "id")
        data <- data[,-c(1:2)]
      }
      
      # 开始生存分析
      
      if (select %in% colnames(data)) {
        input <- data.frame(value = data[,select],
                            time = info$time,
                            status = info$status)
        survival_curve_gene(input, group.by = group.by, name = i)
      } else {NA}
    })
    
    all_plots <- all_plots[!is.na(all_plots)]
    arrange_ggsurvplots(all_plots, ncol = 3, nrow = 3)
    
  } else {
    
    data <- cohort
    
    # 蛋白活性预测 
    
    if (is.viper == TRUE) {
      
      info <- data[,c(1:3)]
      data <- column_to_rownames(data, var = "id")
      data <- t(data[,-c(1:2)])
      
      # VIPER数据预处理
      
      data <- as.matrix(data)
      data <- RankTransform(data)
      
      # Meta VIPER
      
      data <- viper(data, regulon,
                    minsize = 25, cores = 10, method = 'none')
      
      # 整理结果
      
      data <- t(data)
      data <- data[info$id,]
      
    } else {
      
      info <- data[,c(1:3)]
      data <- column_to_rownames(data, var = "id")
      data <- data[,-c(1:2)]
    }
    
    # 开始生存分析
    
    input <- data.frame(value = data[,select],
                        time = info$time,
                        status = info$status)
    survival_curve_gene(input, group.by = group.by, name = "cohort")
  }
  
}



# metastasis analysis ==========================================================
# ==============================================================================

metastasis_gene_plots <- function(cohort = alldata,
                                  select = select,
                                  is.viper = TRUE,
                                  regulon = regulon_list) {
  library(tibble)
  library(ggplot2)
  library(ggpubr)
  library(ggbeeswarm)
  library(cowplot)
  
  # 读入函数 ----------
  
  common_violin <- function(input = input,
                            output = name,
                            title = NULL,
                            rotate = 45,
                            width = 3.5, height = 5) {
    # 开始画图
    
    plot <- ggplot(input, aes(x = type, y = value)) +
      geom_quasirandom(width = 0.3, size = 2, color = "grey90") + 
      geom_violin(trim = FALSE, alpha = 0) + 
      geom_boxplot(aes(fill = type), alpha = 1, outlier.shape = NA,
                   size = 0.7, width = 0.1) + 
      scale_fill_manual(values = c("#FBD324", "#A37CB7")) + 
      
      stat_compare_means(method = "t.test", size = 5,
                         label.x = 0.7, label.y = max(input$value)) + 
      
      theme_bw() + 
      theme(panel.grid = element_blank(),
            legend.position = "none", # 去除图例
            axis.text = element_text(colour = "black", size = 15), 
            axis.title = element_text(colour = "black", size = 15),
            panel.border = element_rect(fill = NA, color = "black", linewidth = 1)) + 
      labs(x = NULL, y= 'Gene activity',title = title) + 
      rotate_x_text(rotate)
    
    # 输出结果
    
    if (is.null(output)) {
      plot
    } else {
      ggsave(output, plot, width = width, height = height)
    }
  }
  
  # 循环分析 ----------
  
  allplots <- lapply(names(cohort), function(i){
    
    data <- cohort[[i]]
    data <- data[data$type != "normal",]
    info <- data.frame(id = rownames(data),
                       type = data$type)
    data <- t(data[,-1])
    
    # 蛋白活性预测
    
    if (is.viper == TRUE) {
      
      # VIPER数据预处理
      
      data <- as.matrix(data)
      data <- RankTransform(data)
      
      # Meta VIPER
      
      data <- viper(data, regulon,
                    minsize = 25, cores = 10, method = 'none')
    }
    
    # 整合感兴趣基因
    
    input <- data.frame(id = colnames(data),
                        value = data[select,])
    
    input <- merge(input, info, by = "id")
    input <- input[,-1]
    
    # 开始画图
    
    common_violin(input = input,
                  output = NULL, title = i,
                  rotate = 0)
  })
  
  plot_grid(plotlist = allplots, ncol = 2)
}



# ICB analysis =================================================================
# ==============================================================================

# ICB response ====================

ICB_response_plot <- function(cohort = ICB_data,
                              allinfo = ICB_info,
                              select.gene = "ITGA6",
                              select.time = "all",
                              is.viper = FALSE,
                              regulon = regulon_list) {
  library(viper)
  library(tibble)
  library(ggplot2)
  library(ggpubr)
  library(ggbeeswarm)
  library(cowplot)
  
  # 读入函数1 ----------
  
  common_violin <- function(input = input,
                            output = name,
                            title = NULL,
                            rotate = 45,
                            width = 3.5, height = 5) {
    # 开始画图
    
    plot <- ggplot(input, aes(x = type, y = value)) +
      geom_quasirandom(width = 0.3, size = 2, color = "grey90") + 
      geom_violin(trim = FALSE, alpha = 0) + 
      geom_boxplot(aes(fill = type), alpha = 1, outlier.shape = NA,
                   size = 0.7, width = 0.1) + 
      scale_fill_manual(values = c("#FBD324", "#A37CB7")) + 
      
      stat_compare_means(method = "t.test", size = 5,
                         label.x = 0.7, label.y = max(input$value)) + 
      
      theme_bw() + 
      theme(panel.grid = element_blank(),
            legend.position = "none", # 去除图例
            axis.text = element_text(colour = "black", size = 15), 
            axis.title = element_text(colour = "black", size = 15),
            panel.border = element_rect(fill = NA, color = "black", linewidth = 1)) + 
      labs(x = NULL, y= 'Gene activity',title = title) + 
      rotate_x_text(rotate)
    
    # 输出结果
    
    if (is.null(output)) {
      plot
    } else {
      ggsave(output, plot, width = width, height = height)
    }
  }
  
  # 读入函数2 ----------
  
  RankTransform <- function(dat.mat) {
    rank.mat <- apply(dat.mat, 2, rank)
    median <- apply(rank.mat, 1, median)
    mad <- apply(rank.mat, 1, mad)
    rank.mat <- (rank.mat - median) / mad
    return(rank.mat)
  }
  
  
  # 循环分析 ----------
  
  all_plots <- lapply(names(cohort), function(i){
    
    data <- as.matrix(cohort[[i]])
    info <- allinfo[[i]]
    
    # 得选出pre的样本
    
    response <- data.frame(id = info$id,
                           type = info$response1,
                           time = info$sample_time)
    
    response <- na.omit(response)
    if (select.time == "pre") {response <- response[response$time == "pre",]}
    
    # 蛋白活性预测
    
    if (is.viper == TRUE) {
      
      # VIPER数据预处理
      
      data <- as.matrix(data)
      data <- RankTransform(data)
      
      # Meta VIPER
      
      data <- viper(data, regulon,
                    minsize = 25, cores = 10, method = 'none')
    }
    
    # 开始画图
    
    if (select.gene %in% rownames(data)) {
      
      input <- data.frame(id = colnames(data),
                          value = data[select.gene,])
      
      input <- merge(input, response, by = "id")
      input <- input[,c(2:3)]
      
      common_violin(input = input,
                    output = NULL, title = i,
                    rotate = 0)
    } else {NA}
    
  })
  
  # 图形整合 ----------
  
  all_plots <- all_plots[!is.na(all_plots)]
  plot_grid(plotlist = all_plots, ncol = 5)
}


# ICB OS ====================

ICB_os_plot <- function(cohort = ICB_data,
                        allinfo = ICB_info,
                        annoinfo = basic_info,
                        select.gene = "ITGA6",
                        select.time = "all",
                        group.by = "optimal") {
  library(viper)
  library(tibble)
  library(ggplot2)
  library(ggpubr)
  library(survival)
  library(survminer)
  
  # 读入函数1 ----------
  
  survival_curve_gene <- function(input = input,
                                  select = select,
                                  group.by = "optimal",
                                  name = "cohort") {
    library(survival)
    library(survminer)
    
    # 确定阈值
    
    if (group.by == "median") {
      
      thres <- median(input$value)
      input$type <- ifelse(input$value > thres, "H", "L")
      
    } else if (group.by == "quantile") {
      
      thres1 <- quantile(input$value, probs = c(0.75), na.rm = T)
      thres2 <- quantile(input$value, probs = c(0.25), na.rm = T)
      input$type <- NA
      input$type[input$value > thres1] <- "H"
      input$type[input$value < thres2] <- "L"
      input <- na.omit(input)
      
    } else if (group.by == "optimal") {
      
      thres <- surv_cutpoint(input, time = "time", minprop = 0.15,
                             event = "status", variables = "value")
      thres <- thres$cutpoint[[1]]
      input$type <- ifelse(input$value > thres, "H", "L")
      
    }
    
    # 计算p值
    
    my.surv <- Surv(input$time, input$status)
    data.survdiff <- survdiff(my.surv ~ input$type)
    p.val = 1 - pchisq(data.survdiff$chisq, length(data.survdiff$n) - 1)
    
    # 计算HR
    
    mycox <- coxph(Surv(time,status) ~ value, data = input)
    coxResult <- summary(mycox)
    
    HR = coxResult$coefficients[,"exp(coef)"]
    lower_95CI = coxResult$conf.int[,3]
    upper_95CI = coxResult$conf.int[,4]
    
    HR <- paste("Hazard Ratio = ", round(HR,2), sep = "")
    CI <- paste("95% CI: ", paste(round(lower_95CI, 2),
                                  round(upper_95CI, 2), sep = " - "), sep = "")
    
    # 基本信息
    
    number_H <- paste("number H = ", sum(input$type == "H"), sep = "")
    number_L <- paste("number L = ", sum(input$type == "L"), sep = "")
    cutoff <- paste("cutoff = ", round(thres, 3), sep = "")
    
    # 开始画图
    
    if (group.by != "quantile") {
      
      fit <- survfit(Surv(time, status) ~ type, data = input)
      ggsurvplot(fit, data = input, size = 1, palette = c("#f63a4e","#0089c1"), 
                 risk.table = F, conf.int = F,
                 conf.int.style = "step", ncensor.plot = FALSE, censor = F,
                 font.legend = 12, font.title = 12, font.x = 12, font.y = 12,
                 pval = paste(pval = ifelse(p.val < 0.001, "p < 0.001", 
                                            paste("P = ",round(p.val,3), sep = "")),
                              HR, CI, number_H, number_L, cutoff, sep = "\n"),
                 legend.title = name)
      
    } else {
      
      fit <- survfit(Surv(time, status) ~ type, data = input)
      ggsurvplot(fit, data = input, size = 1, palette = c("#f63a4e","#0089c1"), 
                 risk.table = F, conf.int = F,
                 conf.int.style = "step", ncensor.plot = FALSE, censor = F,
                 font.legend = 12, font.title = 12, font.x = 12, font.y = 12,
                 pval = paste(pval = ifelse(p.val < 0.001, "p < 0.001", 
                                            paste("P = ",round(p.val,3), sep = "")),
                              HR, CI, sep = "\n"),
                 legend.title = name)
    }
  }
  
  
  # 循环分析 ----------
  
  # 选择有OS数据的队列
  
  OS_id <- annoinfo$id[annoinfo$OS == "Y"]
  
  # 开始循环
  
  all_plots <- lapply(OS_id, function(i){
    
    data <- as.matrix(cohort[[i]])
    info <- allinfo[[i]]
    
    # 得选出pre的样本
    
    survival <- data.frame(id = info$id,
                           time = info$os_day,
                           status = info$os_censor,
                           time = info$sample_time)
    
    survival <- na.omit(survival)
    if (select.time == "pre") {survival <- survival[survival$time == "pre",]}
    
    # 开始画图
    
    if (select.gene %in% rownames(data)) {
      
      input <- data.frame(id = colnames(data),
                          value = data[select.gene,])
      
      input <- merge(input, survival, by = "id")
      input <- input[,c(2:4)]
      
      survival_curve_gene(input = input,
                          group.by = group.by,
                          name = i)
    } else {NA}
    
  })
  
  # 图形整合 ----------
  
  all_plots <- all_plots[!is.na(all_plots)]
  arrange_ggsurvplots(all_plots, ncol = 3, nrow = 4)
}


# ICB PFS ====================

ICB_pfs_plot <- function(cohort = ICB_data,
                         allinfo = ICB_info,
                         annoinfo = basic_info,
                         select.gene = "ITGA6",
                         select.time = "all",
                         group.by = "optimal") {
  library(viper)
  library(tibble)
  library(ggplot2)
  library(ggpubr)
  library(survival)
  library(survminer)
  
  # 读入函数1 ----------
  
  survival_curve_gene <- function(input = input,
                                  select = select,
                                  group.by = "optimal",
                                  name = "cohort") {
    library(survival)
    library(survminer)
    
    # 确定阈值
    
    if (group.by == "median") {
      
      thres <- median(input$value)
      input$type <- ifelse(input$value > thres, "H", "L")
      
    } else if (group.by == "quantile") {
      
      thres1 <- quantile(input$value, probs = c(0.75), na.rm = T)
      thres2 <- quantile(input$value, probs = c(0.25), na.rm = T)
      input$type <- NA
      input$type[input$value > thres1] <- "H"
      input$type[input$value < thres2] <- "L"
      input <- na.omit(input)
      
    } else if (group.by == "optimal") {
      
      thres <- surv_cutpoint(input, time = "time", minprop = 0.15,
                             event = "status", variables = "value")
      thres <- thres$cutpoint[[1]]
      input$type <- ifelse(input$value > thres, "H", "L")
      
    }
    
    # 计算p值
    
    my.surv <- Surv(input$time, input$status)
    data.survdiff <- survdiff(my.surv ~ input$type)
    p.val = 1 - pchisq(data.survdiff$chisq, length(data.survdiff$n) - 1)
    
    # 计算HR
    
    mycox <- coxph(Surv(time,status) ~ value, data = input)
    coxResult <- summary(mycox)
    
    HR = coxResult$coefficients[,"exp(coef)"]
    lower_95CI = coxResult$conf.int[,3]
    upper_95CI = coxResult$conf.int[,4]
    
    HR <- paste("Hazard Ratio = ", round(HR,2), sep = "")
    CI <- paste("95% CI: ", paste(round(lower_95CI, 2),
                                  round(upper_95CI, 2), sep = " - "), sep = "")
    
    # 基本信息
    
    number_H <- paste("number H = ", sum(input$type == "H"), sep = "")
    number_L <- paste("number L = ", sum(input$type == "L"), sep = "")
    cutoff <- paste("cutoff = ", round(thres, 3), sep = "")
    
    # 开始画图
    
    if (group.by != "quantile") {
      
      fit <- survfit(Surv(time, status) ~ type, data = input)
      ggsurvplot(fit, data = input, size = 1, palette = c("#f63a4e","#0089c1"), 
                 risk.table = F, conf.int = F,
                 conf.int.style = "step", ncensor.plot = FALSE, censor = F,
                 font.legend = 12, font.title = 12, font.x = 12, font.y = 12,
                 pval = paste(pval = ifelse(p.val < 0.001, "p < 0.001", 
                                            paste("P = ",round(p.val,3), sep = "")),
                              HR, CI, number_H, number_L, cutoff, sep = "\n"),
                 legend.title = name)
      
    } else {
      
      fit <- survfit(Surv(time, status) ~ type, data = input)
      ggsurvplot(fit, data = input, size = 1, palette = c("#f63a4e","#0089c1"), 
                 risk.table = F, conf.int = F,
                 conf.int.style = "step", ncensor.plot = FALSE, censor = F,
                 font.legend = 12, font.title = 12, font.x = 12, font.y = 12,
                 pval = paste(pval = ifelse(p.val < 0.001, "p < 0.001", 
                                            paste("P = ",round(p.val,3), sep = "")),
                              HR, CI, sep = "\n"),
                 legend.title = name)
    }
  }
  
  
  # 循环分析 ----------
  
  # 选择有PFS数据的队列
  
  PFS_id <- annoinfo$id[annoinfo$PFS == "Y"]
  
  # 开始循环
  
  all_plots <- lapply(PFS_id, function(i){
    
    data <- as.matrix(cohort[[i]])
    info <- allinfo[[i]]
    
    # 得选出pre的样本
    
    survival <- data.frame(id = info$id,
                           time = info$pfs_day,
                           status = info$pfs_censor,
                           time = info$sample_time)
    
    survival <- na.omit(survival)
    if (select.time == "pre") {survival <- survival[survival$time == "pre",]}
    
    # 开始画图
    
    if (select.gene %in% rownames(data)) {
      
      input <- data.frame(id = colnames(data),
                          value = data[select.gene,])
      
      input <- merge(input, survival, by = "id")
      input <- input[,c(2:4)]
      
      survival_curve_gene(input = input,
                          group.by = group.by,
                          name = i)
    } else {NA}
    
  })
  
  # 图形整合 ----------
  
  all_plots <- all_plots[!is.na(all_plots)]
  arrange_ggsurvplots(all_plots, ncol = 3, nrow = 3)
}



# 免疫浸润分析 =================================================================
# ==============================================================================

# 计算免疫浸润 ====================

immune_scores <- function(data = data,
                          source = path,
                          geneset = "allsets",
                          method = "ssgsea") {
  
  library(GSVA)
  library(reshape2)
  
  # 处理注释信息 ----------
  
  load(source)
  sig_list <- immune_genesets[[geneset]]
  
  # 开始计算分数 ----------
  
  if (method == "bisque") {
    
    library(BisqueRNA)
    library(Biobase)
    
    sig_list <- reshape2::melt(sig_list)
    sig_list <- data.frame(gene = sig_list$value,
                           cluster = sig_list$L1,
                           logfc = 1)
    
    common <- intersect(sig_list$gene, rownames(data))
    sig_list <- sig_list[sig_list$gene %in% common,]
    
    # 过滤基因数小于5的基因集
    
    number <- data.frame(table(sig_list$cluster))
    sig_list <- sig_list[sig_list$cluster %in% number$Var1[number$Freq > 5],]
    
    # 开始计算
    
    data <- as.matrix(data)
    input <- ExpressionSet(assayData = data)
    scores <- MarkerBasedDecomposition(input, sig_list,
                                       ct_col = "cluster",
                                       gene_col = "gene",
                                       w_col = "logfc",
                                       weighted = T,
                                       unique_markers = F,
                                       verbose = TRUE)
    scores <- scores$bulk.props
    
  } else {
    
    data <- as.matrix(data)
    scores <- gsva(data, sig_list, 
                   min.sz = 2, max.sz = 500, 
                   method = method, parallel.sz = 16,
                   verbose = TRUE)
  }
}


# 计算免疫浸润差异 ====================

immune_content_diff <- function(cohort = HCC_cohorts,
                                source = path,
                                geneset = "TCIA",
                                select = "PVR",
                                is.viper = FALSE,
                                regulon = regulon_list,
                                thres = 0.75) {
  library(GSVA)
  library(reshape2)
  library(future.apply)
  library(limma)
  library(metaMA)
  library(metap)
  library(statmod)
  library(tibble)
  library(viper)
  library(tibble)
  
  # 读入函数1 ----------
  
  mean_rmout <- function(input = input) {
    
    remove_outliers <- function(x, na.rm = TRUE, ...) {
      qnt <- quantile(x, probs = c(.25, .75), na.rm = na.rm, ...)
      H <- 1.5 * IQR(x, na.rm = na.rm)
      y <- x
      y[x < (qnt[1] - H)] <- NA
      y[x > (qnt[2] + H)] <- NA
      y
    }
    
    input <- remove_outliers(input)
    mean(input, na.rm = TRUE)
  }
  
  sd_rmout <- function(input = input) {
    
    remove_outliers <- function(x, na.rm = TRUE, ...) {
      qnt <- quantile(x, probs = c(.25, .75), na.rm = na.rm, ...)
      H <- 1.5 * IQR(x, na.rm = na.rm)
      y <- x
      y[x < (qnt[1] - H)] <- NA
      y[x > (qnt[2] + H)] <- NA
      y
    }
    
    input <- remove_outliers(input)
    sd(input, na.rm = TRUE)
  }
  
  metapvalue <- function(input = input) {
    pvalue <- sumz(input, log.p = FALSE)
    pvalue[["p"]][,1]
  }
  
  # 读入函数2 ----------
  
  immune_scores <- function(data = data,
                            source = path,
                            geneset = "allsets",
                            method = "ssgsea") {
    load(source)
    sig_list <- immune_genesets[[geneset]]
    
    # 开始计算分数
    
    if (method == "bisque") {
      
      library(BisqueRNA)
      library(Biobase)
      
      sig_list <- reshape2::melt(sig_list)
      sig_list <- data.frame(gene = sig_list$value,
                             cluster = sig_list$L1,
                             logfc = 1)
      
      common <- intersect(sig_list$gene, rownames(data))
      sig_list <- sig_list[sig_list$gene %in% common,]
      
      # 过滤基因数小于5的基因集
      
      number <- data.frame(table(sig_list$cluster))
      sig_list <- sig_list[sig_list$cluster %in% number$Var1[number$Freq > 5],]
      
      # 开始计算
      
      data <- as.matrix(data)
      input <- ExpressionSet(assayData = data)
      scores <- MarkerBasedDecomposition(input, sig_list,
                                         ct_col = "cluster",
                                         gene_col = "gene",
                                         w_col = "logfc",
                                         weighted = T,
                                         unique_markers = F,
                                         verbose = TRUE)
      scores <- scores$bulk.props
      
    } else {
      
      data <- as.matrix(data)
      scores <- gsva(data, sig_list, 
                     min.sz = 2, max.sz = 500, 
                     method = method, parallel.sz = 16,
                     verbose = TRUE)
    }
  }
  
  # 读入函数3 ----------
  
  RankTransform <- function(dat.mat) {
    rank.mat <- apply(dat.mat, 2, rank)
    median <- apply(rank.mat, 1, median)
    mad <- apply(rank.mat, 1, mad)
    rank.mat <- (rank.mat - median) / mad
    return(rank.mat)
  }
  
  # 读入函数4 ----------
  
  limma_betweenAb <- function(data = data,
                              info = info,
                              thres = 0.9) {
    data <- t(as.matrix(data))
    info <- data.frame(info)
    
    # 二分类化分组变量
    
    info$type <- "M"
    info$type[info$value > quantile(info$value, probs = thres)] <- "H"
    info$type[info$value < quantile(info$value, probs = 1 - thres)] <- "L"
    info <- info[info$type != "M",]; info <- info[,-2]
    
    # 定义差异分析函数
    
    difflimma <- function(data = data,
                          info = info,
                          group1 = "R",
                          group2 = "NR") {
      # 确保排序一致
      
      common <- intersect(colnames(data), info$id)
      info <- info[info$id %in% common,]
      data <- data[,info$id]
      data <- as.matrix(data)
      
      # 构建矩阵
      
      grade <- factor(info[,2], levels = c(group2, group1))
      design <- model.matrix(~0 + grade)
      
      rownames(design) <- info$id
      colnames(design) <- gsub(pattern = "grade", replacement = "",
                               x = colnames(design))
      # 对比矩阵
      
      cont.matrix <- as.matrix(c(-1, 1))
      rownames(cont.matrix) <- c(group2, group1)
      colnames(cont.matrix) <- paste0(group1, " - ", group2)
      
      # 线性拟合
      
      fit <- lmFit(data, design)
      fit <- contrasts.fit(fit, cont.matrix)
      fit <- eBayes(fit, trend = TRUE, robust = TRUE)
      
      # 得到差异基因
      
      diff <- topTable(fit, adjust = 'fdr',
                       coef = 1, n = Inf)
      
      diff <- data.frame(id = rownames(diff),
                         logfc = diff$logFC,
                         t = diff$t,
                         pvalue = diff$P.Value,
                         FDR = diff$adj.P.Val)
      
      # 得到分组平均值
      
      group_mean <- do.call(rbind, lapply(1:nrow(data), function(i){
        
        input <- data.frame(id = colnames(data), value = data[i,])
        input <- merge(input, info, by = "id")
        input <- na.omit(input)
        
        fcvalue <- mean(input$value[input$type == group1]) - 
          mean(input$value[input$type == group2])
        
        data.frame(id = rownames(data)[i],
                   mean_G1 = mean(input$value[input$type == group1]),
                   mean_G2 = mean(input$value[input$type == group2]))
      }))
      
      colnames(group_mean)[2:3] <- c(group1, group2)
      
      # 整合平均值结果
      
      diff <- merge(group_mean, diff, by = "id")
      
      # 得到moderated effect size
      
      es <- effectsize(fit$t, nrow(info),
                       (fit$df.prior + fit$df.residual))
      
      es <- data.frame(es = es[,"dprime"],
                       es_var = es[,"vardprime"])
      # 结果总结
      
      es <- es[diff$id,]
      es <- cbind(diff, es)
      rownames(es) <- NULL
      es
    }
    
    # 开始计算 ----------
    
    difflimma(data, info,
              group1 = "H",
              group2 = "L")
  }
  
  # 基因与免疫浸润相关性 ==========
  
  alldiff <- lapply(names(cohort), function(i){
    
    # 输入数据预处理
    
    data <- cohort[[i]]
    data <- column_to_rownames(data, var = "id")
    data <- t(data[,-c(1:2)])
    
    # 免疫浸润评估
    
    scores <- immune_scores(data = data,
                            source = source,
                            geneset = geneset,
                            method = "ssgsea")
    scores <- t(scores)
    
    # 蛋白活性预测
    
    if (is.viper == TRUE) {
      data <- as.matrix(data)
      data <- RankTransform(data)
      data <- viper(data, regulon,
                    minsize = 25, cores = 10, method = 'none')
    }
    
    # 开始差异分析
    
    if (select %in% rownames(data)) {
      info <- data.frame(id = colnames(data), value = data[select,])
      diff <- limma_betweenAb(data = scores, info = info, thres = thres)
      diff$cohort <- i
      diff
    } else {NA}
    
  })
  
  alldiff <- alldiff[!is.na(alldiff)]
  alldiff <- do.call(rbind, alldiff)
  
  # 结果总结 ==========
  
  input <- do.call(rbind, lapply(unique(alldiff$id), function(i){
    diff <- alldiff[alldiff$id == i,]
    data.frame(id = i,
               es_mean = mean_rmout(diff$es),
               es_sd = sd_rmout(diff$es),
               p_mean = metapvalue(diff$pvalue),
               logp_mean = -log10(metapvalue(diff$pvalue)))
  }))
  
  input$p_mean <- p.adjust(input$p_mean, method = "fdr")
  input$logp_mean <- -log10(input$p_mean)
  input
}


# 结果可视化 ====================

immune_content_plot <- function(input = input,
                                thres.p = 0.05,
                                thres.fc = 0.1,
                                scale = 0.5,
                                select = select,
                                size.label = 3,
                                size.point = 3) {
  library(ggplot2)
  library(ggpubr)
  library(ggrepel)
  
  # 整理数据
  
  sigene_h <- input[input$p_mean < thres.p & input$es_mean > thres.fc,]
  sigene_l <- input[input$p_mean < thres.p & input$es_mean < -thres.fc,]
  select_h <- sigene_h[sigene_h$id %in% select,]
  select_l <- sigene_l[sigene_l$id %in% select,]
  select <- input[input$id %in% select,]
  
  # 开始画图
  
  ggplot(data = input, aes(es_mean, logp_mean)) + 
    geom_point(alpha = 1, size = 2, colour = "grey90") + 
    
    # 显著性的点
    
    geom_errorbarh(data = sigene_l, height = 0, colour = "#F2D7EE",
                   mapping = aes(y = logp_mean,
                                 xmin = es_mean - scale*es_sd,
                                 xmax = es_mean + scale*es_sd)) + 
    geom_errorbarh(data = sigene_h, height = 0, colour = "#FBDD7E",
                   mapping = aes(y = logp_mean,
                                 xmin = es_mean - scale*es_sd,
                                 xmax = es_mean + scale*es_sd)) + 
    geom_point(data = sigene_l, aes(es_mean, logp_mean),
               alpha = 1, size = size.point, colour = "#F2D7EE") + 
    geom_point(data = sigene_h, aes(es_mean, logp_mean),
               alpha = 1, size = size.point, colour = "#FBDD7E") + 
    
    # 手动选择的点
    
    geom_errorbarh(data = select_l, height = 0, colour = "#A231A1", 
                   mapping = aes(y = logp_mean,
                                 xmin = es_mean - scale*es_sd,
                                 xmax = es_mean + scale*es_sd)) + 
    geom_errorbarh(data = select_h, height = 0, colour = "#FCB040",
                   mapping = aes(y = logp_mean,
                                 xmin = es_mean - scale*es_sd,
                                 xmax = es_mean + scale*es_sd)) + 
    geom_point(data = select_l, aes(es_mean, logp_mean),
               shape = 15, alpha = 1, size = size.point, colour = "#A231A1") + 
    geom_point(data = select_h, aes(es_mean, logp_mean),
               shape = 15, alpha = 1, size = size.point, colour = "#FCB040") + 
    
    geom_text_repel(data = select,
                    aes(label = id),
                    force = 1.2, size = size.label,
                    min.segment.length = 100) + 
    
    theme_bw() + 
    theme(panel.grid = element_blank(),
          axis.text = element_text(colour = "black", size = 15),
          axis.title = element_text(colour = "black", size = 15),
          panel.border = element_rect(fill = NA, color = "black", linewidth = 1)) + 
    
    geom_vline(aes(xintercept = thres.fc), linetype="dashed") + 
    geom_vline(aes(xintercept = -thres.fc), linetype="dashed") + 
    geom_hline(aes(yintercept = -log10(thres.p)), linetype="dashed") + 
    labs(x = 'Combined effect size',y= 'Adjusted P value',title = '')
}



# 火山图可视化 =================================================================
# ==============================================================================

# 火山图1 ====================

common_volcano_plot <- function(input = input,
                                output = name,
                                thres.p = 0.05,
                                thres.fc = 1,
                                topn = 5,
                                marker = select,
                                label.size = 5,
                                width = 8, height = 7) {
  
  library(ggplot2)
  library(ggrepel)
  library(ggthemes)
  library(gridExtra)
  library(dplyr)
  
  input <- input
  input$max <- input$logfc * -log10(input$pvalue)
  
  # 选择显著基因
  
  sigene_h <- input[input$pvalue < thres.p & input$logfc > thres.fc,]
  sigene_l <- input[input$pvalue < thres.p & input$logfc < -thres.fc,]
  
  # 选择top基因
  
  toph <- top_n(input, topn, max)
  topl <- top_n(input, -topn, max)
  topgene <- rbind(toph, topl)
  
  # 选择marker基因
  
  select_gene <- input[input$id %in% marker,]
  
  
  # 开始画图
  
  plot <- ggplot(data = input, aes(logfc, -log10(pvalue))) + 
    geom_point(alpha = 1, size = 3, colour = "grey90") + 
    
    #画阈值分界线
    
    geom_vline(xintercept = c(thres.fc), color = "black", linetype = "dashed", lwd = 0.75) + 
    geom_vline(xintercept = c(-thres.fc), color = "black", linetype = "dashed", lwd = 0.75) + 
    geom_hline(yintercept = -log10(thres.p), color = "black", linetype = "dashed", lwd = 0.75) + 
    
    # 差异基因
    
    geom_point(data = sigene_h, alpha = 1, size = 3.5, color = "#FBD324") + 
    geom_point(data = sigene_l, alpha = 1, size = 3.5, color = "#176EBF") + 
    
    # marker基因
    
    geom_point(data = select_gene, alpha = 1, size = 5, colour = "#A37CB7") + 
    
    # top label
    
    geom_text_repel(data = topgene, aes(label = id), size = label.size) + 
    
    # marker label
    
    geom_text_repel(data = select_gene, aes(label=id), size = label.size) + 
    
    theme_bw() + 
    theme(panel.grid = element_blank(),
          axis.text = element_text(colour = "black", size = 15),
          axis.title = element_text(colour = "black", size = 15),
          panel.border = element_rect(fill = NA, color = "black", linewidth = 1)) + 
    
    labs(x = 'Log Fold Change',y= 'Log (P-value)',title = '')
  
  # 输出结果
  
  if (is.null(output)) {
    plot
  } else {
    ggsave(output, plot, dpi = 600, width = width, height = height)
  }
  
}


# 火山图2 ====================

common_volcano_plot2 <- function(input = input,
                                 thres.p = 0.05,
                                 thres.fc = 0,
                                 select = select,
                                 label.size = 5) {
  
  library(ggplot2)
  library(ggrepel)
  library(ggthemes)
  library(gridExtra)
  library(dplyr)
  
  # 选择显著基因
  
  sigene_h <- input[input$FDR < thres.p & input$es > thres.fc,]
  sigene_l <- input[input$FDR < thres.p & input$es < -thres.fc,]
  select_h <- sigene_h[sigene_h$id %in% select,]
  select_l <- sigene_l[sigene_l$id %in% select,]
  select <- input[input$id %in% select,]
  
  # 开始画图
  
  ggplot(data = input, aes(es, -log10(FDR))) + 
    geom_point(alpha = 1, size = 3, colour = "grey90") + 
    
    # 显著性的点
    
    geom_point(data = sigene_l, aes(es, -log10(FDR)),
               alpha = 1, size = 3.5, colour = "#F2D7EE") + 
    geom_point(data = sigene_h, aes(es, -log10(FDR)),
               alpha = 1, size = 3.5, colour = "#FBDD7E") + 
    
    # 手动选择的点
    
    geom_point(data = select_l, aes(es, -log10(FDR)),
               shape = 15, alpha = 1, size = 5, colour = "#A231A1") + 
    geom_point(data = select_h, aes(es, -log10(FDR)),
               shape = 15, alpha = 1, size = 5, colour = "#FCB040") + 
    
    geom_text_repel(data = select,
                    aes(label = id),
                    force = 1.2, size = 5,
                    min.segment.length = 100) + 
    
    theme_bw() + 
    theme(panel.grid = element_blank(),
          axis.text = element_text(colour = "black", size = 15),
          axis.title = element_text(colour = "black", size = 15),
          panel.border = element_rect(fill = NA, color = "black", linewidth = 1)) + 
    
    geom_vline(aes(xintercept = thres.fc), linetype="dashed") + 
    geom_vline(aes(xintercept = -thres.fc), linetype="dashed") + 
    geom_hline(aes(yintercept = -log10(thres.p)), linetype="dashed") + 
    labs(x = 'Moderated effect size',y= 'Adjusted P value',title = '')
}



# 临床特征的boxplot ============================================================
# ==============================================================================

clinical_boxplot <- function(value = value,
                             info = info,
                             rotate = 45) {
  library(ggplot2)
  library(ggpubr)
  library(ggbeeswarm)
  library(cowplot)
  
  # 设定颜色
  
  col <- c("#0070B2", "#5CB3DA", "#B8E3EA", "#DA1735", "#F15E4C", "#FF9F99",
           "#A231A1", "#A37CB7", "#F2D7EE", "#B91372", "#E93B8C", "#ECB2C8",
           "#FF7149", "#F7AE24", "#FBDD7E", "#679436", "#8BBE53", "#CDE391",
           "#067D69", "#00A385", "#98D4C6", "#114B5F", "#028090", "#B2DBBF",
           "#A23E48", "#CD6981", "#FBD0C0", "#788585", "#9CAEA9", "#CCDAD1")
  
  # 批量画图
  
  all_plots <- lapply(colnames(info)[-1], function(i){
    
    subinfo <- data.frame(id = info$id, type = info[,i])
    input <- merge(value, subinfo, by = "id")
    input <- na.omit(input)
    input$type <- as.factor(input$type)
    
    # 开始画图
    
    ggplot(input, aes(x = type, y = value, fill = type)) +
      stat_boxplot(geom = "errorbar", width = 0, color = "black") +
      geom_boxplot(alpha = 1, outlier.shape = NA, size = 0.7, width = 0.7) + 
      geom_quasirandom(width = 0.3, size = 2, alpha = 0.2) + 
      scale_fill_manual(values=c("#FBD324", "#A37CB7", sample(col))) + 
      
      stat_compare_means(method = "kruskal.test", size = 5,
                         label.x = 1.1, label.y = 0.99*max(input$value)) + 
      
      theme_bw() + 
      theme(panel.grid = element_blank(),
            legend.position = "none", # 去除图例
            axis.text = element_text(colour = "black", size = 15), 
            axis.title = element_text(colour = "black", size = 15),
            panel.border = element_rect(fill = NA, color = "black", linewidth = 1)) + 
      labs(x = '', y= 'Gene activity',title = i) + 
      rotate_x_text(rotate)
  })
  
  plot_grid(plotlist = all_plots, ncol = 3)
}



# 根据某个基因在某种细胞中的表达给样本分组 =====================================
# ==============================================================================

seurat_sample_group <- function(datafilt = datafilt,
                                col.sample = "sample",
                                col.type = "celltype_sig2",
                                col.type.cell = "tumor",
                                gene.select = "ITGA6",
                                gene.metrics = "prop",
                                gene.thres = 0.75) {
  library(Seurat)
  library(dplyr)
  library(tibble)
  
  
  # average expression的替代函数 ----------
  
  meanexpression <- function(data = datafilt,
                             slot = "data",
                             group = group) {
    library(Seurat)
    
    info <- data@meta.data
    info <- data.frame(id = rownames(info), metacell = info[,group])
    counts <- GetAssayData(data, slot = slot, assay = "RNA")
    
    # 计算平均值
    
    metadata <- do.call(cbind, lapply(unique(info$metacell), function(i){
      cell <- info$id[info$metacell == i]
      metadata <- data.frame(rowMeans(counts[,cell]))
      names(metadata) <- i
      metadata
    }))
    
    # 整理结果
    
    as.matrix(metadata)
  }
  
  
  # 计算分组 ----------
  
  if (gene.metrics == "prop") {
    
    info <- datafilt@meta.data
    
    # 计算比例
    
    dotplot <- DotPlot(datafilt,
                       features = gene.select,
                       group.by = col.sample)
    
    prop <- dotplot$data
    group <- data.frame(id = prop$id, value = prop$pct.exp)
    
  } else {
    
    # 计算bulk表达
    
    info <- datafilt@meta.data
    select <- rownames(info)[info[,col.type] == col.type.cell]
    subfilt <- datafilt[,select]
    data <- meanexpression(subfilt, slot = "data", group = col.sample)
    data <- t(data)
    group <- data.frame(id = rownames(data), value = data[,gene.select])
  }
  
  # 进行分组
  
  group$group <- "M"
  group$group[group$value > quantile(group$value, probs = gene.thres)] <- "H"
  group$group[group$value < quantile(group$value, probs = 1 - gene.thres)] <- "L"
  
  # 整合结果
  
  info <- data.frame(cell = rownames(info), sample = info$sample)
  info <- left_join(info, group, by = c("sample" = "id"))
  info <- data.frame(group = info$group, row.names = info$cell)
  
  # seurat整合
  
  datafilt <- AddMetaData(datafilt, info)
  datafilt
}



# CellPhoneDB相关函数 ==========================================================
# ==============================================================================

# 准备输入数据 ====================

cellphonedb_input <- function(datafilt = datafilt,
                              path = path,
                              celltype = "celltype_sig2") {
  library(Seurat)
  library(sceasy)
  library(reticulate)
  
  use_condaenv('scanpy')
  dir.create(path)
  
  # 将log转换数据转回去
  
  data <- as.matrix(GetAssayData(datafilt, slot = "data", assay = "RNA"))
  data <- exp(data)-1
  datafilt <- SetAssayData(datafilt, slot = "data",
                           new.data = data, assay = "RNA")
  
  # 输出metainfo
  
  info <- datafilt@meta.data
  info <- data.frame(barcode_sample = colnames(datafilt),
                     cell_type = info[,celltype])
  
  name = paste0(path, "/metainfo.txt")
  write.table(info, name, sep = "\t", quote = F, row.names = F, col.names = T)
  
  # 输出表达矩阵
  
  name = paste0(path, "/expdata.h5ad")
  convertFormat(datafilt, outFile = name,
                from = "seurat", to = "anndata", assay = "RNA")
}


# 计算显著的cell type pairs ====================

interaction_p <- function(input = input,
                          thres = 0.05) {
  
  library(reshape2)
  
  # 重抽样函数
  
  re_data <- function(data = data) {
    rand <- runif(n = length(data))
    prop <- rand / sum(rand)
    sum(data) * prop}
  
  # 计算pvalue
  
  pvalue <- do.call(cbind, lapply(colnames(input), function(i){
    data <- input[,i]
    
    perm <- t(do.call(cbind, lapply(1:1000, function(j){
      data.frame(re_data(data))})))
    
    data.frame(do.call(c, lapply(1:length(data), function(j){
      subperm <- unname(perm[,j])
      sum(data[j] < subperm) / length(subperm)})))
  }))
  
  # 整理结果
  
  rownames(pvalue) <- rownames(input)
  colnames(pvalue) <- colnames(input)
  
  # 矩阵处理
  
  diag(pvalue) <- NA
  pvalue1 <- pvalue
  pvalue2 <- pvalue
  
  pvalue1[upper.tri (pvalue1)] <- NA
  pvalue2[lower.tri (pvalue2)] <- NA
  pvalue2 <- t(pvalue2)
  
  # 选择最小值
  
  for(i in 1:(ncol(pvalue)-1)){
    for(j in (i+1):ncol(pvalue)){
      if (pvalue1[j,i] > pvalue2[j,i]) {
        pvalue1[j,i] <- pvalue2[j,i]}
    }}
  
  pvalue1 <- as.matrix(pvalue1)
  pvalue1 <- na.omit(reshape2::melt(pvalue1))
  
  # 阈值选择
  
  pvalue1[pvalue1$value < thres,]
}



# 3D柱状图 legoplot ============================================================
# ==============================================================================

bar3d <- function(input = input,
                  scale = 10,
                  color = "discrete") {
  
  library(barplot3d)
  library(RColorBrewer)
  
  # 预处理数据
  
  input <- t(input)
  data <- t(input)
  data <- do.call(c, lapply(1:ncol(data), function(i){data[,i]}))
  
  # 设定颜色
  
  if (color == "discrete") {
    
    col <- c("#A6D719", "#176EBF", "#00A8DE",
             "#AEE0E8", "#00A9A3", "#FBD324",
             "#F28A24", "#A52828", "#A37CB7")
    
  } else if (color == "continuous") {
    
    col <- c("#f3bd2e","#e2720f","#e02f2c",
             "#861b20","#b51b7f","#7f137f","#622183")
    col <- colorRampPalette(col)(nrow(input))
  }
  
  # 颜色数据处理
  
  input_col <- do.call(rbind, lapply(1:nrow(input), function(i){
    rep(col[i], ncol(input))}))
  
  input_col <- t(input_col)
  input_col <- do.call(c, lapply(1:ncol(input_col), function(i){input_col[,i]}))
  
  # 开始画图
  
  barplot3d(rows = nrow(input), cols = ncol(input), z = data,
            topcolors = input_col, 
            sidecolors = input_col,
            alpha = 1, scalexy = scale,
            gap = 0.1, gridlines = FALSE,
            xlabels = colnames(input),
            ylabels = rownames(input))
}



# 环状比例图 ===================================================================
# ==============================================================================

circ_prop <- function(data) {
  
  library(ggplot2)
  
  data <- data.frame(data)
  names(data)[1:2] <- c("type", "n")
  data$fraction = data$n / sum(data$n)
  data$ymax = cumsum(data$fraction)
  data$ymin = c(0, head(data$ymax, n = -1))
  
  data = data[order(data$n, decreasing = TRUE),]
  myLabel = as.vector(data$type)   
  myLabel = paste(myLabel, "(", round(data$n / sum(data$n) * 100, 2), "%)", sep = "")   
  
  ggplot(data = data, aes(fill = type, ymax = ymax, ymin = ymin, xmax = 4, xmin = 3)) +
    geom_rect(colour = "grey30", show_guide = FALSE) +
    coord_polar(theta = "y") +
    labs(x = "", y = "", title = "") + 
    xlim(2.5,NA) +
    theme_bw() +
    theme(panel.grid=element_blank()) + ## 去掉白色外框
    theme(axis.text=element_blank()) + ## 把图旁边的标签去掉
    theme(axis.ticks=element_blank()) + ## 去掉左上角的坐标刻度线
    theme(panel.border=element_blank()) + ## 去掉最外层的正方形边框
    geom_text(aes(x = 3.5, y = ((ymin+ymax)/2), label = myLabel)) 
}



# 注释热图 =====================================================================
# ==============================================================================

# annotation bar

annotation_bar <- function(input = input,
                           lwd = 0.5,
                           order.keep = T,
                           show.name = T) {
  
  library(ggplot2)
  library(forcats)
  library(reshape2)
  
  # 保留原来的名字顺序
  
  if (order.keep == T) {
    input$id <- fct_inorder(input$id)
  }
  
  # 开始画图
  
  if (ncol(input) == 2) {
    
    input <- data.frame(input)
    input$name <- "name"
    input$value <- input$type
    
    plot <- ggplot(input, aes(x = id, y = name)) +
      geom_tile(aes(fill = type), color = "white", linewidth = lwd)
    
  } else {
    
    input <- data.frame(input)
    input <-  melt(input,id = "id")
    
    plot <- ggplot(input, aes(x = id, y = variable)) +
      geom_tile(aes(fill = value), color = "white", linewidth = lwd)
    
  }
  
  # 设定颜色
  
  if (length(unique(input$value)) < 17) {
    col <- c("#A6D719", "#176EBF", "#00A8DE", "#AEE0E8",
             "#00A9A3", "#FBD324", "#F28A24", "#A52828",
             "#A37CB7", "#F2D7EE", "#CD6981", "#FBD0C0",
             "#F15E4C", "#ECB2C8", "#B2DBBF", "#CCDAD1")
  } else {
    col <- sample(c("#0070B2", "#5CB3DA", "#B8E3EA", "#DA1735", "#F15E4C", "#FF9F99",
                    "#A231A1", "#A37CB7", "#F2D7EE", "#B91372", "#E93B8C", "#ECB2C8",
                    "#FF7149", "#F7AE24", "#FBDD7E", "#679436", "#8BBE53", "#CDE391",
                    "#067D69", "#00A385", "#98D4C6", "#114B5F", "#028090", "#B2DBBF",
                    "#A23E48", "#CD6981", "#FBD0C0", "#788585", "#9CAEA9", "#CCDAD1"))
  }
  
  plot <- plot + scale_fill_manual(values = col)
  
  # 保留名字
  
  if (show.name == T) {
    plot <- plot +
      theme_bw() + 
      theme(legend.position = "bottom",
            legend.title = element_blank(),
            panel.grid = element_blank(),
            axis.title = element_blank(),
            axis.ticks = element_blank(),
            panel.border = element_blank())
  } else {
    plot <- plot + 
      theme_bw() + 
      theme(legend.position = "bottom",
            legend.title = element_blank(),
            panel.grid = element_blank(),
            axis.text = element_blank(),
            axis.title = element_blank(),
            axis.ticks = element_blank(),
            panel.border = element_blank())
  }
  
  plot
}



# 曲线图 =======================================================================
# ==============================================================================

lineplot <- function(input = input,
                     color = "continuous"){
  
  library(ggplot2)
  
  # 设定颜色
  
  if (length(color) == 1) {
    if (color == "discrete") {
      col <- c("#A6D719", "#176EBF", "#00A8DE",
               "#AEE0E8", "#00A9A3", "#FBD324",
               "#F28A24", "#A52828", "#A37CB7")
      
    } else if (color == "continuous") {
      col <- c("#f3bd2e","#e2720f","#e02f2c",
               "#861b20","#b51b7f","#7f137f","#622183")
      col <- colorRampPalette(col)(length(unique(input$type)))
    }
  } else {
    col <- color
  }
  
  # 开始画图
  
  ggplot(input,aes(value1, value2, color = type))+
    geom_smooth(span = 1.2,  se = FALSE) + 
    scale_color_manual(values = c(col)) + 
    theme_bw() + 
    theme(panel.grid = element_blank(),
          axis.text = element_text(colour = "black", size = 15),
          axis.title = element_text(colour = "black", size = 15),
          panel.border = element_rect(fill = NA, color = "black", linewidth = 1)) + 
    labs(x = 'value1', y= 'value2',title = '') + 
    
    scale_x_continuous(expand = c(0,0)) + # 不留边框
    scale_y_continuous(expand = c(0,0))
}



# average expression的替代函数 =================================================
# ==============================================================================

meanexpression <- function(data = datafilt,
                           slot = "data",
                           group = group,
                           method = "mean") {
  library(Seurat)
  
  info <- data@meta.data
  info <- data.frame(id = rownames(info), metacell = info[,group])
  counts <- GetAssayData(data, slot = slot, assay = "RNA")
  
  # 计算平均值
  
  metadata <- do.call(cbind, lapply(unique(info$metacell), function(i){
    cell <- info$id[info$metacell == i]
    
    if (length(cell) == 1) {
      
      metadata <- data.frame(counts[,cell])
      
    } else {
      
      if (method == "mean") {
        metadata <- data.frame(rowMeans(counts[,cell]))
      } else if (method == "sum") {
        metadata <- data.frame(rowSums(counts[,cell]))
      }
      
    }
    
    names(metadata) <- i
    metadata
  }))
  
  # 整理结果
  
  as.matrix(metadata)
}



# 散点箱线图 ===================================================================
# ==============================================================================

common_dotbox <- function(input = input,
                          method = "t.test",
                          rotate = 45,
                          order = TRUE,
                          decreasing = F) {
  
  library(ggbeeswarm)
  library(ggplot2)
  library(ggpubr)
  
  input <- input
  
  # 设定颜色
  
  col <- c("#F2D7EE", "#A37CB7", "#A231A1", "#B8E3EA", "#5CB3DA", "#0070B2", 
           "#ECB2C8", "#E93B8C", "#B91372", "#FBDD7E", "#F7AE24", "#FF7149", 
           "#FF9F99", "#F15E4C", "#DA1735", "#CDE391", "#8BBE53", "#679436", 
           "#98D4C6", "#00A385", "#067D69", "#B2DBBF", "#028090", "#114B5F", 
           "#FBD0C0", "#CD6981", "#A23E48", "#CCDAD1", "#9CAEA9", "#788585")
  
  # 数据排序
  
  mean_data <- aggregate(input$value, by = list(input$type), FUN = mean)
  names(mean_data)[1:2] <- c("id", "mean_value")
  
  if (order == TRUE) {
    levels <- mean_data$id[order(mean_data$mean_value, decreasing = decreasing)]
    input$type <- factor(input$type, levels = levels)
    mean_data$id <- factor(mean_data$id, levels = levels)
  }
  
  # 开始画图
  
  plot <- ggplot(mean_data, aes(x = id, y = mean_value)) +
    
    geom_quasirandom(data = input, aes(x = type, y = value, fill = type),
                     width = 0.2, size = 3, color = "black",
                     alpha = 1, shape = 21) + 
    
    stat_summary(fun = median, 
                 geom = "crossbar", 
                 width = 0.5, linewidth = 0.5) + 
    
    scale_fill_manual(values = (col)) + 
    
    theme_bw() + 
    theme(panel.grid = element_blank(),
          legend.position = "none", # 去除图例
          axis.text = element_text(colour = "black", size = 15), 
          axis.title = element_text(colour = "black", size = 15),
          panel.border = element_rect(fill = NA, color = "black", linewidth = 1)) + 
    labs(x = '', y= 'Gene activity',title = '') + 
    rotate_x_text(rotate)
  
  # 添加统计检验
  
  if (length(unique(input$type)) == 2) {
    plot + stat_compare_means(data = input, aes(x = type, y = value),
                              method = method, size = 5,
                              label.x = 1.1)
  } else {plot}
}


# 散点箱线图2 ====================

common_dotbox2 <- function(input = input,
                           rotate = 45,
                           order = TRUE,
                           decreasing = F,
                           show.point = TRUE) {
  library(ggplot2)
  library(ggpubr)
  library(ggrastr)
  
  # 均值标准差计算
  
  aggdata1 <- aggregate(input$value, by = list(input$type), FUN = mean)
  aggdata2 <- aggregate(input$value, by = list(input$type), FUN = sd)
  
  new_data <- data.frame(aggdata1, sd = aggdata2[,2])
  names(new_data)[1:2] <- c("id", "mean_value")
  
  # 数据排序
  
  if (order == TRUE) {
    levels <- new_data$id[order(new_data$mean_value, decreasing = decreasing)]
    input$type <- factor(input$type, levels = levels)
    new_data$id <- factor(new_data$id, levels = levels)
  }
  
  # 开始画图
  
  if (show.point == TRUE) {
    
    plot <- ggplot(new_data, aes(x = id, y = mean_value)) +
      
      geom_quasirandom_rast(data = input,
                            aes(x = type, y = value),
                            colour = "grey90", 
                            size = 1, 
                            alpha = 1) + 
      
      geom_pointrange(aes(ymin = mean_value-sd,
                          ymax = mean_value+sd))
    
  } else {
    
    plot <- ggplot(new_data, aes(x = id, y = mean_value)) +
      geom_pointrange(aes(ymin = mean_value-sd,
                          ymax = mean_value+sd))
    
  }
  
  plot + theme_bw() + 
    theme(panel.grid = element_blank(),
          legend.position = "none", # 去除图例
          axis.text = element_text(colour = "black", size = 15), 
          axis.title = element_text(colour = "black", size = 15),
          panel.border = element_rect(fill = NA, color = "black", linewidth = 1)) + 
    labs(x = '', y= 'Gene activity',title = '') + 
    rotate_x_text(rotate)
}



# ECDF曲线 =====================================================================
# ==============================================================================

ecdf_plot <- function(input = input,
                      ylim = c(0,1)) {
  
  library(ggplot2)
  library(rstatix)
  
  # 设定颜色
  
  col <- c("#F2AB27","#ABDAE1","#257396","#1C9DCE","#F6CB66","#EFDA34",
           "#E6CFA9","#DAD0D6","#E5E4E3","#CA5A7C","#9C78AF","#F2D7EE",
           "#B6D683","#00A9A3","#D6D756")
  
  # 开始画图
  
  plot <- ggplot(input, aes(value, color = type)) +
    stat_ecdf(geom = "step", size = 1) + 
    scale_color_manual(values = c(col)) + 
    labs(y = "Cumulative fraction") +
    theme_bw() + 
    theme(legend.key.size = unit(1,'cm'),
          legend.text = element_text(size = 12),
          legend.title = element_blank(),
          panel.grid = element_blank(),
          axis.text = element_text(colour = "black", size = 15),
          axis.title = element_text(colour = "black", size = 15),
          panel.border = element_rect(fill = NA, color = "black", linewidth = 1)) +
    ylim(ylim)
  
  # 计算p值
  
  pvalue <- wilcox_test(input, value ~ type, alternative = "two.sided")
  pvalue <- pvalue$p[1]
  
  if(length(unique(input$type)) == 2) {
    plot + 
      annotate(geom = "text", x = -Inf, y = Inf, size = 5,
               hjust = -0.35, vjust = 3, label = paste0("P = ", pvalue))
  } else {plot}
}



# 背靠背prop ===================================================================
# ==============================================================================

prop_back2back <- function(datafilt = datafilt,
                           group = "group",
                           cluster = "celltype",
                           order = TRUE) {
  library(Seurat)
  library(ggplot2)
  library(gtools)
  
  # 整理数据
  
  info <- datafilt@meta.data
  info <- data.frame(group = info[,group],
                     cluster = info[,cluster])
  
  input <- data.frame(table(info$group, info$cluster))
  names(input) <- c("group", "cluster", "prop")
  
  # 把数量转成比例
  
  input <- do.call(rbind, lapply(unique(input$group), function(i){
    subinput <- input[input$group == i,]
    subinput$prop <- subinput$prop / sum(subinput$prop)
    subinput}))
  
  input$label <- paste0(round(input$prop * 100, 1), "%")
  
  # 排序处理
  
  if (order == TRUE) {
    name <- unique(mixedsort(input$cluster, decreasing = TRUE))
    input$cluster <- factor(input$cluster, levels = name)
  }
  
  # 开始画图
  
  ggplot(input, aes(x = cluster, fill = group)) + 
    scale_fill_manual(values = c("#A231A1", "#F2D7EE")) + 
    
    geom_bar(stat = "identity",
             data = subset(input, group == unique(input$group)[1]),
             aes(y = prop)) +
    geom_text(data = subset(input, group == unique(input$group)[1]), 
              aes(y = prop, label = label), size = 5, hjust = -0.1) +
    
    geom_bar(stat = "identity",
             data = subset(input, group == unique(input$group)[2]),
             aes(y = prop * (-1)) ) +
    geom_text(data = subset(input, group == unique(input$group)[2]), 
              aes(y = prop * (-1), label = label), size = 5, hjust = 1.1) +
    
    theme_bw() +
    theme(legend.key.size = unit(1,'cm'),
          legend.text = element_text(size = 12),
          legend.title = element_blank(),
          panel.grid = element_blank(),
          axis.text = element_text(colour = "black", size = 15),
          axis.title = element_text(colour = "black", size = 15),
          panel.border = element_rect(fill = NA, color = "black", linewidth = 1)) + 
    
    coord_flip() + ylab("Proportion") + xlab("") + 
    ylim(-max(input$prop) - 0.035, max(input$prop) + 0.035)
}



# 筛选基因 =====================================================================
# ==============================================================================

FSbyMAD<-function(Data, cut.type="topk", value)
{
  mads=apply(Data,1,mad)
  feature_num=length(mads)
  hist(mads, breaks=feature_num*0.1, col="red",
       main="Expression (MAD) distribution",
       xlab="The MAD of feature")
  if(cut.type=="topk")
  {
    index= sort(mads,decreasing = TRUE,index.return=TRUE)
    if(value>nrow(Data))
    {
      value=nrow(Data)
      cat("Warning: the feature selection number is beyond the original feature numnber")
    }
    cutoff=index$x[value]
    abline(v=cutoff,col = "blue",lty = 5,lwd=1.5)
    index=index$ix[1:value]
    selectData=Data[index,]
  }
  if(cut.type=="cutoff")
  {
    abline(v=value,col = "blue",lty = 5,lwd=1.5)
    index=which(mads>value)
    selectData=Data[index,]
  }
  selectData
}



# 分组热图可视化 ===============================================================
# ==============================================================================

heatmap_cluster <- function(input = input,
                            type = type,
                            color = "blue2red",
                            font.size = 10,
                            outlier.rm = T,
                            outlier.thres = 0.01,
                            name.row = T,
                            name.col = F) {
  
  library(ComplexHeatmap)
  library(circlize)
  
  # 确保输入的是矩阵
  
  input <- as.matrix(input)
  
  # 设定颜色
  
  if (color == "parula") {
    col <- colorRampPalette(c("#352A87","#343EB1","#1558D9","#036CE0","#107AD9",
                              "#1387D3","#0997D1","#06A4C9","#0CADBB","#23B4A9",
                              "#43BB97","#6ABE83","#8FBF73","#AEBD66","#CBBB5B",
                              "#E6B94F","#FDBE3C","#FBCF2C","#F5E21E","#F9FB0E"))(100)
    
  } else if (color == "kovesi") {
    col <- colorRampPalette(c("#1B0084","#1B099A","#1C14AE","#1C20C0","#1F2DCE",
                              "#233DD6","#2950CE","#2E68AB","#377989","#3F876A",
                              "#46954D","#53A036","#65AB26","#7BB41A","#95BE16",
                              "#AFC61C","#C6CE26","#DAD636","#EAE04E","#F1EC74",
                              "#F8F7AF","#FFFFFF"))(100)
    
  } else if (color == "ocean.haline") {
    col <- colorRampPalette(c("#2A186C","#2E1B87","#2B229F","#1D35A1","#11459A",
                              "#0C5294","#115D8F","#19678C","#22718A","#2B7A89",
                              "#328388","#388D88","#3E9886","#44A284","#4CAC80",
                              "#55B67A","#62BF72","#73C869","#8AD060","#A4D75C",
                              "#BEDC62","#D5E171","#EAE784","#FDEF9A"))(100)
    
  } else if (color == "ocean.dense") {
    col <- c(colorRampPalette(c("white",
                                "#E6F1F1"))(20),
             colorRampPalette(rev(c("#360E24","#5D1A58","#723692","#795CC3",
                                    "#7487E0", "#7EB0E4","#AAD2E3")))(80))
    
  } else if (color == "magma") {
    col <- c(colorRampPalette(c(magma(323, begin = 0.15)[1]))(10),
             magma(323, begin = 0.18))
    
  } else if (color == "white2blue") {
    col <- colorRampPalette(c("#FBF4F8","#E5E0ED","#BFC6DD","#8CADCC",
                              "#4E92BA","#1871A8","#085889","#003758"))(100)
    
  } else if (color == "blue2red") {
    col <- colorRampPalette(c("#0070b2","#009bc7","#5ec7dd",
                              "#b8e3ea","#f3f3f1","#fccdb9",
                              "#f79676","#f15e4c","#da1735"))(100)
    
  } else if (color == "rainbow") {
    col <- colorRampPalette(c("#343391","#0064af","#0090cc","#00b6db","#01b7c2",
                              "#53c0a3","#8dcb8a","#bbd967","#fbd324","#f6bd25",
                              "#f4a02e","#ed6f32","#ea5c2e","#d5452f","#c02e2f",
                              "#8b2a21"))(100)
  }
  
  # 计算四分位值从而确定颜色范围
  
  if (outlier.rm == T) {
    all_value <- reshape2::melt(input)
    thres <- quantile(all_value$value, probs = c(outlier.thres, 1-outlier.thres))
    col <- colorRamp2(seq(from = thres[1], to = thres[2],
                          length.out = length(col)), col)}
  
  # 处理注释信息
  
  common <- intersect(type$id, colnames(input))
  type <- type[type$id %in% common,]
  type <- type[order(type$type, decreasing = T),]
  input <- input[,type$id]
  
  # 开始画图
  
  ha <- HeatmapAnnotation(df = data.frame(type$type), 
                          which = "column", show_annotation_name = F,
                          show_legend = FALSE)
  
  draw(Heatmap(input, col = col,
               name = "Z-score",
               top_annotation = ha,
               column_gap = unit(2, "mm"),
               row_gap = unit(0, "mm"),
               border = "#404040",  
               show_row_names = name.row, 
               show_column_names = name.col,
               column_names_rot = 45, 
               row_names_gp = gpar(fontsize = font.size),
               column_split = type$type, 
               cluster_rows = T, show_row_dend = F,
               cluster_columns = T, show_column_dend = T,
               heatmap_legend_param = list(
                 legend_direction = "horizontal", 
                 legend_width = unit(6, "cm"))),
       heatmap_legend_side = "bottom")
}



# ITH计算 ======================================================================
# ==============================================================================

# 计算3种ITH分数 ====================

# 输入数据既可以是一个seurat对象，也可以是一个list

scITH <- function(data = data,
                  group = NULL,
                  npca = 50) {
  
  # 数据预处理
  
  if (class(data) != "list") {
    data <- SplitObject(data, split.by = group)
  }
  
  # 开始计算
  
  do.call(rbind, lapply(names(data), function(i){
    
    subdata <- data[[i]]
    pca <- subdata@reductions[["pca"]]@cell.embeddings[,c(1:npca)]
    
    # 计算Euclidean距离 ----------
    
    distance <- as.matrix(dist(pca, method = "euclidean",
                               diag = FALSE, upper = FALSE, p = 2))
    diag(distance) <- NA 
    distance[upper.tri (distance)] <- NA
    
    distance <- melt(distance)
    distance <- na.omit(distance)
    ITH1 = mean(distance$value)
    
    # 计算Manhattan距离 ----------
    
    # expdata <- as.matrix(GetAssayData(subdata, slot = "data", assay = "RNA"))
    # distance <- as.matrix(dist(expdata, method = "manhattan",
    # diag = FALSE, upper = FALSE, p = 2))
    
    # 计算Spearman距离 ----------
    
    distance <- 1-cor(t(pca), method = "spearman")
    diag(distance) <- NA 
    distance[upper.tri (distance)] <- NA
    
    distance <- melt(distance)
    distance <- na.omit(distance)
    ITH2 = mean(distance$value)
    
    # 计算diversity ----------
    
    pca <- data.frame(t(pca))
    ITH3 <- sapply(colnames(pca), function(j){
      pca$mean <- rowMeans(pca)
      distance <- (pca[,j]-pca[,"mean"])^2 %>%
        sum() %>% sqrt()
      return(distance)
    }) %>% mean()
    
    # 总结结果 ----------
    
    data.frame(id = i, ITH_euc = ITH1,
               ITH_cor = ITH2, ITH_div = ITH3)
  }))
}


# 基于euclidean的scITH ====================

scITH_euclidean <- function(data = data,
                            group = NULL,
                            npca = 50) {
  
  # 数据预处理
  
  if (class(data) != "list") {
    data <- SplitObject(data, split.by = group)
  }
  
  # 开始计算
  
  do.call(rbind, lapply(names(data), function(i){
    
    subdata <- data[[i]]
    pca <- subdata@reductions[["pca"]]@cell.embeddings[,c(1:npca)]
    
    # 计算Euclidean距离 ----------
    
    distance <- as.matrix(dist(pca, method = "euclidean",
                               diag = FALSE, upper = FALSE, p = 2))
    diag(distance) <- NA 
    distance[upper.tri (distance)] <- NA
    
    distance <- melt(distance)
    distance <- na.omit(distance)
    
    # 总结结果 ----------
    
    data.frame(type = i, value = distance$value)
  }))
}



# 相关性散点图 =================================================================
# ==============================================================================

corplot <- function(input = input,
                    method = "pearson") {
  
  library(ggplot2)
  
  # 计算P值
  
  test <- cor.test(input[,1], input[,2], method = method)
  pvalue <- test$p.value
  rho <- test$estimate
  
  # 开始画图
  
  ggplot(input, aes(input[,1], input[,2])) +
    geom_point(colour = "grey90", size = 3, alpha = 1) +
    geom_smooth(colour = "#009bc7", 
                method = "lm", se = TRUE) + 
    
    annotate(geom = "text", x = -Inf, y = Inf, size = 5,
             hjust = -0.42, vjust = 3, label = paste0("R = ", round(rho, 3))) + 
    annotate(geom = "text", x = -Inf, y = Inf, size = 5,
             hjust = -0.35, vjust = 5, label = paste0("P = ", round(pvalue, 6))) + 
    
    theme_bw() + 
    theme(panel.grid = element_blank(),
          axis.text = element_text(colour = "black", size = 15),
          axis.title = element_text(colour = "black", size = 15),
          panel.border = element_rect(fill = NA, color = "black", linewidth = 1)) +  
    labs(x = names(input)[1], y= names(input)[2], title = '')
}


# 单细胞基本流程 ===============================================================
# ==============================================================================

# 自动降维 ====================

autoumap <- function(datafilt, nfeatures = 2000, ndim = 15,
                     neigh = 20, dist = 1){
  library(Seurat)
  
  # 测序深度标准化
  
  datafilt <- NormalizeData(datafilt, scale.factor = 10000,
                            normalization.method = "LogNormalize")
  # 变异度高的基因
  
  datafilt <- FindVariableFeatures(datafilt, nfeatures = nfeatures, 
                                   selection.method = "vst")
  # scale标准化
  
  datafilt <- ScaleData(datafilt, features = VariableFeatures(datafilt))
  
  # PCA分析
  
  datafilt <- RunPCA(datafilt, assay = 'RNA', slot = 'scale.data')
  
  # 重新降维
  
  datafilt <- RunUMAP(datafilt, dims = 1:ndim,
                      n.neighbors = neigh, min.dist = dist, 
                      reduction = "pca", reduction.name = "umap")
  return(datafilt)
}


# umap降维图 ====================

dimplot_autoanno <- function(data = dataintg, filename = filename,
                             psize = 0.2, width = 9, height = 7.5){
  
  plot <- DimPlot(data, pt.size = psize, label = F, repel = T, 
                  raster = FALSE, label.size = 3, reduction = "umap",
                  group.by = c("celltype_sig2")) + 
    
    theme_bw() + 
    theme(legend.key.size = unit(0.5,'cm'),
          legend.text = element_text(size = 12),
          legend.title = element_blank(),
          panel.grid = element_blank(), # 删去网格线
          axis.ticks = element_blank(), # 删去刻度线
          axis.text = element_blank(), # 删去刻度标签
          axis.title = element_text(colour = "black", size = 15),
          panel.border = element_rect(fill = NA, color = "black", linewidth = 1)) +   
    
    labs(x = 'UMAP1',y= 'UMAP2',title = '') + 
    
    scale_color_manual(values=c("CD8T" = "#B8E3EA",
                                "CD4T" = "#0070B2",
                                "Treg" = "#A6D719",
                                "NKcell" = "#F15E4C",
                                "Bcell" = "#A231A1",
                                "DC" = "#D5B81B",
                                "Macro" = "#028090",
                                "Mono" = "#B2DBBF",
                                "MAST" = "#B32226",
                                "Neutrophil" = "#00A9A3",
                                "Fibroblast" = "#FBD324",
                                "Endothelial" = "#CD6981",
                                "tumor" = "#9CAEA9",
                                "None" = "#F6F5BD"))
  
  ggsave(filename, plot, dpi = 600, width = width, height = height)
}



# NTP分析 ======================================================================
# ==============================================================================

# NTP预测 ====================

ntp_class <- function(data = data,
                      geneclass = class,
                      thres = 0.15,
                      seed = 123) {
  library(Biobase)
  library(CMScaller)
  
  # 整理基因注释
  
  geneclass <- data.frame(class = as.factor(geneclass$type),
                          probe = geneclass$id)
  # 数据标准化
  
  data <- ematAdjust(data, normMethod = "quantile")
  
  # 开始预测
  
  result <- ntp(data, geneclass, doPlot = FALSE,
                nPerm = 1000, seed = seed)
  # 整理结果
  
  result <- result[result$p.value < thres,]
  data.frame(id = rownames(result),
             type = result$prediction)
}



# 基因在亚群间分布 =============================================================
# ==============================================================================

exp_distribution <- function(datafilt = datafilt,
                             select = select,
                             group = group,
                             order = TRUE,
                             decreasing = TRUE,
                             show.point = TRUE,
                             size.point = 2,
                             method = "wilcox.test",
                             ncol = 2, 
                             rotate = 45) {
  
  library(Seurat)
  library(stringr)
  library(ggplot2)
  library(ggpubr)
  library(ggrastr)
  library(cowplot)
  library(ggbeeswarm)
  
  
  # 画图函数 ----------
  
  common_dotbox <- function(input = input,
                            rotate = 45,
                            order = TRUE,
                            decreasing = F,
                            show.point = TRUE) {
    
    # 均值标准差计算
    
    aggdata1 <- aggregate(input$value, by = list(input$type), FUN = mean)
    aggdata2 <- aggregate(input$value, by = list(input$type), FUN = sd)
    
    new_data <- data.frame(aggdata1, sd = aggdata2[,2])
    names(new_data)[1:2] <- c("id", "mean_value")
    
    # 数据排序
    
    if (order == TRUE) {
      levels <- new_data$id[order(new_data$mean_value, decreasing = decreasing)]
      input$type <- factor(input$type, levels = levels)
      new_data$id <- factor(new_data$id, levels = levels)
    }
    
    # 开始画图
    
    if (show.point == TRUE) {
      
      plot <- ggplot(new_data, aes(x = id, y = mean_value)) +
        
        geom_quasirandom_rast(data = input,
                              aes(x = type, y = value),
                              colour = "grey90", 
                              size = size.point, 
                              alpha = 1) + 
        
        stat_summary(fun = median, 
                     geom = "crossbar", 
                     width = 0.5, linewidth = 0.5)
      
    } else {
      
      plot <- ggplot(new_data, aes(x = id, y = mean_value)) +
        stat_summary(fun = median, 
                     geom = "crossbar", 
                     width = 0.5, linewidth = 0.5)
      
    }
    
    plot + theme_bw() + 
      theme(panel.grid = element_blank(),
            legend.position = "none", # 去除图例
            axis.text = element_text(colour = "black", size = 15), 
            axis.title = element_text(colour = "black", size = 15),
            panel.border = element_rect(fill = NA, color = "black", linewidth = 1)) + 
      labs(x = '', y= 'Gene activity',title = '') + 
      rotate_x_text(rotate)
  }
  
  
  # 开始画图 ----------
  
  if (length(select) == 1) {
    
    data <- GetAssayData(datafilt, slot = "data", assay = "RNA")[select,]
    data <- data.frame(as.matrix(data))
    
    info <- datafilt@meta.data
    input <- data.frame(value = data[,1],
                        type = info[,group])
    
    input <- na.omit(input)
    plot <- common_dotbox(input = input,
                          rotate = rotate,
                          order = order,
                          decreasing = decreasing,
                          show.point = show.point)
    plot <- plot + ggtitle(select)
    
    # 添加统计检验
    
    if (length(unique(input$type)) == 2) {
      plot + stat_compare_means(data = input, aes(x = type, y = value),
                                method = method, size = 5,
                                label.x = 1.1)
    } else {plot}
    
  } else {
    
    common <- intersect(select, rownames(datafilt))
    data <- GetAssayData(datafilt, slot = "data", assay = "RNA")[common,]
    data <- data.frame(t(as.matrix(data)))
    
    allplots <- lapply(colnames(data), function(i){
      info <- datafilt@meta.data
      input <- data.frame(value = data[,i],
                          type = info[,group])
      
      input <- na.omit(input)
      plot <- common_dotbox(input = input,
                            rotate = rotate,
                            order = order,
                            decreasing = decreasing,
                            show.point = show.point)
      
      plot <- plot + ggtitle(select)
      
      # 添加统计检验
      
      if (length(unique(input$type)) == 2) {
        plot + stat_compare_means(data = input, aes(x = type, y = value),
                                  method = method, size = 5,
                                  label.x = 1.1)
      } else {plot}
      
    })
    
    plot_grid(plotlist = allplots, ncol = ncol)
  }
  
}


# exp distribution ecdf ====================

exp_distribution_ecdf <- function(datafilt = datafilt,
                                  select = select,
                                  group = group,
                                  method = "wilcox.test",
                                  ncol = 2) {
  
  library(Seurat)
  library(stringr)
  library(ggplot2)
  library(ggpubr)
  library(ggrastr)
  library(cowplot)
  library(ggbeeswarm)
  
  
  # 画图函数 ----------
  
  ecdf_plot <- function(input = input,
                        ylim = c(0,1)) {
    
    library(ggplot2)
    library(rstatix)
    
    # 设定颜色
    
    col <- c("#F2AB27","#ABDAE1","#257396","#1C9DCE","#F6CB66","#EFDA34",
             "#E6CFA9","#DAD0D6","#E5E4E3","#CA5A7C","#9C78AF","#F2D7EE",
             "#B6D683","#00A9A3","#D6D756")
    
    # 开始画图
    
    plot <- ggplot(input, aes(value, color = type)) +
      stat_ecdf(geom = "step", size = 1) + 
      scale_color_manual(values = c(col)) + 
      labs(y = "Cumulative fraction") +
      theme_bw() + 
      theme(legend.key.size = unit(1,'cm'),
            legend.text = element_text(size = 12),
            legend.title = element_blank(),
            panel.grid = element_blank(),
            axis.text = element_text(colour = "black", size = 15),
            axis.title = element_text(colour = "black", size = 15),
            panel.border = element_rect(fill = NA, color = "black", linewidth = 1)) +
      ylim(ylim)
    
    # 计算p值
    
    pvalue <- wilcox_test(input, value ~ type, alternative = "two.sided")
    pvalue <- pvalue$p[1]
    
    if(length(unique(input$type)) == 2) {
      plot + 
        annotate(geom = "text", x = -Inf, y = Inf, size = 5,
                 hjust = -0.35, vjust = 3, label = paste0("P = ", pvalue))
    } else {plot}
  }
  
  
  # 开始画图 ----------
  
  if (length(select) == 1) {
    
    data <- GetAssayData(datafilt, slot = "data", assay = "RNA")[select,]
    data <- data.frame(as.matrix(data))
    
    info <- datafilt@meta.data
    input <- data.frame(value = data[,1],
                        type = info[,group])
    
    input <- na.omit(input)
    plot <- ecdf_plot(input, ylim = c(0,1))
    plot <- plot + ggtitle(select)
    plot
    
  } else {
    
    common <- intersect(select, rownames(datafilt))
    data <- GetAssayData(datafilt, slot = "data", assay = "RNA")[common,]
    data <- data.frame(t(as.matrix(data)))
    
    allplots <- lapply(colnames(data), function(i){
      info <- datafilt@meta.data
      input <- data.frame(value = data[,i],
                          type = info[,group])
      
      input <- na.omit(input)
      plot <- ecdf_plot(input, ylim = c(0,1))
      plot <- plot + ggtitle(select)
      plot
      
    })
    
    plot_grid(plotlist = allplots, ncol = ncol)
  }
  
}



# 柱状比例图 ===================================================================
# ==============================================================================

prop_plot <- function(input = input,
                      rotate = 45,
                      decreasing = T) {
  
  library(ggplot2)
  library(ggpubr)
  library(gtools)
  
  mycol <- c("#A6D719", "#176EBF", "#00A8DE",
             "#AEE0E8", "#00A9A3", "#FBD324",
             "#F28A24", "#A52828", "#A37CB7")
  
  # 变量排序
  
  input$Var2 <- as.character(input$Var2)
  name <- unique(mixedsort(input$Var2, decreasing = decreasing))
  input$Var2 <- factor(input$Var2, levels = name)
  
  # 开始画图
  
  ggplot(input, aes(x = Var1, y = Freq, fill = Var2)) +
    geom_bar(stat = "identity", position = "fill", width = 0.75) + 
    scale_fill_manual(values = c(mycol)) + 
    theme_bw() + 
    theme(panel.grid = element_blank(),
          legend.key.size = unit(0.75,'cm'),
          legend.text = element_text(size = 15),
          legend.title = element_blank(),
          axis.text = element_text(colour = "black", size = 15),
          axis.title = element_text(colour = "black", size = 15)) + 
    scale_y_continuous(expand = c(0,0)) + 
    labs(x = '', y = 'Proportion', title = '') + 
    rotate_x_text(rotate)
}



# GSEA分析 =====================================================================
# ==============================================================================

gsea_analysis <- function(input = input,
                          source = path,
                          geneset = NULL,
                          set.min = 5,
                          set.max = 1000) {
  
  library(clusterProfiler)
  library(enrichplot)
  library(gridExtra)
  library(msigdbr)
  options(connectionObserver = NULL)
  
  # 处理注释信息
  
  if (is.null(geneset)) {
    
    sig_list <- read.table(source, sep = ",", header = F,
                           row.names = 1, na.strings = "")
    
    sig_list <- lapply(rownames(sig_list), function(i){
      subdata <- t(sig_list[i,])[,1]
      subdata <- data.frame(term = i, gene = subdata)
    })
    
    sig_list <- do.call(rbind, sig_list)
    sig_list <- na.omit(sig_list)
    
  } else {
    
    all_genesets <- readRDS(source)
    genesets <- reshape2::melt(all_genesets[[geneset]])
    sig_list <- data.frame(term = genesets[,2], gene = genesets[,1])
    
  }
  
  # 整理数据
  
  input <- input[order(input$value, decreasing = T),]
  data <- input$value
  names(data) <- input$id
  
  # 开始进行GSEA分析
  
  kk <- GSEA(data, TERM2GENE = sig_list,
             minGSSize = set.min, maxGSSize = set.max,
             pvalueCutoff = 1, nPermSimple = 10000, eps = 0)
  
  # 结果整理
  
  result <- data.frame(id = kk$Description, 
                       ES = kk$enrichmentScore,
                       NES = kk$NES, 
                       pvalue = kk$pvalue, 
                       FDR = kk$p.adjust, 
                       setsize = kk$setSize, 
                       leading_prop = kk$leading_edge,
                       leading_gene = kk$core_enrichment)
  
  result$leading_prop <- do.call(rbind, strsplit(result$leading_prop, ','))[,1]
  result$leading_prop <- do.call(rbind, strsplit(result$leading_prop, '='))[,2]
  
  # 结果输出
  
  result <- result[order(result$NES, decreasing = T),]
  result
}


# 进行leading edge分析 ====================

leading_edge <- function(input = input,
                         geneset = list) {
  library(Pi)
  library(tibble)
  
  # 数据排序
  
  input <- input[order(input$value, decreasing = T),]
  
  # 整理数据
  
  rownames(input) <- NULL
  input <- column_to_rownames(input, var = "id")
  input$rank <- 1:nrow(input)
  names(input)[1] <- "priority"
  
  # 开始分析
  
  eGSEA <- xPierGSEA(input, fast = T,
                     size.range = c(5, 500),
                     nperm = 1000, 
                     customised.genesets = geneset)
  # 导出结果
  
  result <- data.frame(rank = eGSEA[["leading"]][[1]])
  result <- rownames_to_column(result, var = "id")
  result
}


# 画leading edge plot ====================

leading_edge_plot <- function(input = input,
                              geneset = list,
                              leading = TRUE,
                              select.gene = FALSE,
                              select.name = select) {
  library(Pi)
  library(tibble)
  
  # 数据排序
  
  input <- input[order(input$value, decreasing = T),]
  
  # 整理数据
  
  rownames(input) <- NULL
  input <- column_to_rownames(input, var = "id")
  input$rank <- 1:nrow(input)
  names(input)[1] <- "priority"
  
  # 开始分析
  
  eGSEA <- xPierGSEA(input, fast = T,
                     size.range = c(5, 500),
                     nperm = 1000, 
                     customised.genesets = geneset)
  
  # 设定颜色
  
  col <- "#343391-#00b6db-#8dcb8a-#f6bd25-#ea5c2e-#8b2a21"
  
  # 开始画图
  
  if (select.gene == TRUE) {
    
    plot <- xGSEAdotplot(eGSEA, top = names(geneset),
                         peak.color = "black",
                         leading = leading,
                         leading.query = select.name,
                         leading.query.only = TRUE,
                         leading.size = 3,
                         leading.color = "black",
                         leading.alpha = 1,
                         colormap = col,
                         ncolors = 6)
    plot
    
  } else {
    
    plot <- xGSEAdotplot(eGSEA, top = names(geneset),
                         peak.color = "black",
                         leading = leading,
                         leading.query.only = TRUE,
                         leading.size = 3,
                         leading.color = "black",
                         leading.alpha = 1,
                         colormap = col,
                         ncolors = 6)
    plot
  }
}



# 亚群特异JSD分数 ==============================================================
# ==============================================================================

jsd_score <- function(data = data,
                      cluster = cluster,
                      select = NULL) {
  
  library(philentropy)
  library(reshape2)
  library(pbapply)
  library(tibble)
  library(caret)
  
  # 预处理分群数据
  
  cluster$value <- 1
  cluster <- reshape2::acast(cluster, id ~ type,
                             value.var = "value",
                             fun.aggregate = mean)
  
  cluster[cluster == "NaN"] <- 0
  
  # 排除variation为0的基因
  
  data <- as.matrix(data)
  var <- do.call(rbind, lapply(rownames(data), function(i){
    data.frame(id = i, value = var(data[i,]))}))
  data <- data[var$id[var$value > 0],]
  
  # 预处理表达数据
  
  data <- t(data)
  preprocess <- caret::preProcess(data, method = c("range"))
  data <- predict(preprocess, data)
  
  # 保持行名一致
  
  common <- intersect(rownames(cluster), rownames(data))
  cluster <- cluster[common,]
  data <- data[common,]
  
  # 只选择部分亚组进行分析
  
  if (!is.null(select)) {
    cluster <- data.frame(row.names = rownames(cluster),
                          select = cluster[,select])}
  
  # 计算JSD
  
  jsd <- pblapply(colnames(data), function(i) {
    sapply(colnames(cluster), function(j) {
      
      1 - JSD(rbind(data[,i], cluster[,j]),
              unit = 'log2', est.prob = "empirical")
    })
  })
  
  jsd <- do.call(rbind, jsd)
  
  # 结果命名
  
  if (!is.null(select)) {
    rownames(jsd) <- colnames(data)
    colnames(jsd) <- paste0(select, "_jsd")
  
  } else {
    rownames(jsd) <- colnames(data)
    colnames(jsd) <- colnames(cluster)
  }
  
  # 输出结果
  
  if (!is.null(select)) {
    rownames_to_column(data.frame(jsd), var = "id")
    
  } else {
    jsd
  }
  
}



# 差异MA-plot ==================================================================
# ==============================================================================

common_maplot <- function(input = input, 
                          show.diff = FALSE, thres.p = 0.05, thres.fc = 1,
                          topn = NULL, marker = NULL, label.size = 5,
                          output = NULL, width = 8, height = 7) {
  library(ggplot2)
  library(ggrepel)
  library(ggthemes)
  library(gridExtra)
  library(dplyr)
  
  input <- input
  
  # 开始画图
  
  if (nrow(input) > 5000) {
    
    library(ggrastr)
    plot <- ggplot(data = input, aes(exp, logfc)) + 
      geom_point_rast(alpha = 1, size = 2, colour = "grey90")
    
  } else {
    
    plot <- ggplot(data = input, aes(exp, logfc)) + 
      geom_point(alpha = 1, size = 2, colour = "grey90")
  }
  
  plot <- plot + 
    theme_bw() + 
    theme(panel.grid = element_blank(),
          axis.text = element_text(colour = "black", size = 15),
          axis.title = element_text(colour = "black", size = 15),
          panel.border = element_rect(fill = NA, color = "black", linewidth = 1)) + 
    
    geom_hline(yintercept = 0, color = "black", linetype = "solid", lwd = 0.5) + 
    labs(x = 'Log Mean Expression',y= 'Log Fold Change',title = '')
  
  # 加上差异基因
  
  if (show.diff == TRUE) {
    
    sigene_h <- input[input$pvalue < thres.p & input$logfc > thres.fc,]
    sigene_l <- input[input$pvalue < thres.p & input$logfc < -thres.fc,]
    
    plot <- plot + 
      geom_point(data = sigene_h, alpha = 1, size = 2, color = "#F2D7EE") + 
      geom_point(data = sigene_l, alpha = 1, size = 2, color = "#F2D7EE") + 
      
      geom_hline(yintercept = thres.fc,
                 color = "black", linetype = "dashed", lwd = 0.5) + 
      geom_hline(yintercept = -thres.fc,
                 color = "black", linetype = "dashed", lwd = 0.5)
  }
  
  # 加上marker基因
  
  if (!is.null(marker)) {
    
    select_gene <- input[input$id %in% marker,]
    plot <- plot + geom_point(data = select_gene,
                              aes(exp, logfc), alpha = 1,
                              size = 3, shape = 15, colour = "#A231A1") + 
      geom_text_repel(data = select_gene,
                      aes(exp, logfc, label=id), size = label.size)
  }
  
  # 加上top基因
  
  if (!is.null(topn)) {
    
    toph <- top_n(input, topn, logfc)
    topl <- top_n(input, -topn, logfc)
    topgene <- rbind(toph, topl)
    
    plot <- plot + 
      geom_text_repel(data = topgene,
                      aes(exp, logfc, label = id), size = label.size)
  }
  
  # 输出结果
  
  if (is.null(output)) {
    plot
  } else {
    ggsave(output, plot, dpi = 600, width = width, height = height)
  }
  
}


# maplot2 ====================

common_maplot2 <- function(input = input, 
                          show.diff = FALSE, thres.p = 0.05, thres.fc = 1,
                          topn = NULL, marker = NULL, label.size = 5,
                          output = NULL, width = 8, height = 7) {
  library(ggplot2)
  library(ggrepel)
  library(ggthemes)
  library(gridExtra)
  library(dplyr)
  
  input <- input
  
  # 开始画图
  
  if (nrow(input) > 5000) {
    
    library(ggrastr)
    plot <- ggplot(data = input, aes(exp, logfc)) + 
      geom_point_rast(alpha = 1, aes(size = -log(pvalue)), colour = "grey90")
    
  } else {
    
    plot <- ggplot(data = input, aes(exp, logfc)) + 
      geom_point(alpha = 1, aes(size = -log(pvalue)), colour = "grey90")
  }
  
  plot <- plot + 
    theme_bw() + 
    theme(panel.grid = element_blank(),
          axis.text = element_text(colour = "black", size = 15),
          axis.title = element_text(colour = "black", size = 15),
          panel.border = element_rect(fill = NA, color = "black", linewidth = 1)) + 
    
    geom_hline(yintercept = 0, color = "black", linetype = "solid", lwd = 0.5) + 
    labs(x = 'Log Mean Expression',y= 'Log Fold Change',title = '')
  
  # 加上差异基因
  
  if (show.diff == TRUE) {
    
    sigene_h <- input[input$pvalue < thres.p & input$logfc > thres.fc,]
    sigene_l <- input[input$pvalue < thres.p & input$logfc < -thres.fc,]
    
    plot <- plot + 
      geom_point(data = sigene_h, alpha = 1, aes(size = -log(pvalue)), color = "#F2D7EE") + 
      geom_point(data = sigene_l, alpha = 1, aes(size = -log(pvalue)), color = "#F2D7EE") + 
      
      geom_hline(yintercept = thres.fc,
                 color = "black", linetype = "dashed", lwd = 0.5) + 
      geom_hline(yintercept = -thres.fc,
                 color = "black", linetype = "dashed", lwd = 0.5)
  }
  
  # 加上marker基因
  
  if (!is.null(marker)) {
    
    select_gene <- input[input$id %in% marker,]
    plot <- plot + geom_point(data = select_gene,
                              aes(exp, logfc, size = -log(pvalue)), alpha = 1,
                              size = 3, shape = 15, colour = "#A231A1") + 
      geom_text_repel(data = select_gene,
                      aes(exp, logfc, label=id), size = label.size)
  }
  
  # 加上top基因
  
  if (!is.null(topn)) {
    
    toph <- top_n(input, topn, logfc)
    topl <- top_n(input, -topn, logfc)
    topgene <- rbind(toph, topl)
    
    plot <- plot + 
      geom_text_repel(data = topgene,
                      aes(exp, logfc, label = id), size = label.size)
  }
  
  # 输出结果
  
  if (is.null(output)) {
    plot
  } else {
    ggsave(output, plot, dpi = 600, width = width, height = height)
  }
  
}



# 空转数据分析 =================================================================
# ==============================================================================

# 表达相关性 ====================

spatial_exp <- function(dataspat = dataspat,
                        select = select,
                        assay = "Spatial",
                        outlier.rm = T,
                        ncol = 3) {
  library(Seurat)
  library(SeuratData)
  library(dplyr)
  library(ggplot2)
  library(cowplot)
  library(patchwork)
  
  
  # 处理坐标数据 ----------
  
  coord <- as.data.frame(dataspat@images$slice1@coordinates)[c(3,2)]
  coord[,2] <- (-coord[,2])
  
  names(coord) <- c("row_ind", "col_ind")
  coord <- arrange(coord, col_ind, row_ind)
  
  
  # 开始画图 ----------
  
  library(Rmagic)
  library(reticulate)
  use_condaenv('magic')
  
  dataimpu <- magic(dataspat, genes = select,
                    npca = 50, n.jobs = 30, assay = assay)
  
  data <- GetAssayData(dataimpu, slot = "data", assay = paste0("MAGIC_", assay))
  data <- data[,rownames(coord)]
  
  # 设定颜色
  
  col <- c(colorRampPalette(c("#20B8E5","#167B98","#113D4C","#242021",
                              "#555625", "#A9AB37","#F2EA1B"))(16))
  
  # 针对输入基因不同的情况
  
  if (length(select) == 1) {
    
    input <- coord
    input$value <- data
    
    if (outlier.rm == T) {
      thres <- quantile(input$value, probs = c(0.01, 0.99))
      input$value[input$value < thres[1]] <- thres[1]
      input$value[input$value > thres[2]] <- thres[2]}
    
    # 开始画图
    
    input$col <- cut(input$value, 16, labels = c(1:16))
    input$col <- as.numeric(input$col)
    
    ggplot(input, aes(x = row_ind, y = col_ind, shape = 'a'))+ 
      geom_point(aes(size = 1, color = col)) +
      scale_shape_manual(values = c(15))+
      scale_colour_gradientn(colors = col)+
      theme_void()
    
  } else {
    
    allplots <- lapply(select, function(i){
      
      input <- coord
      input$value <- data[i,]
      
      if (outlier.rm == T) {
        thres <- quantile(input$value, probs = c(0.01, 0.99))
        input$value[input$value < thres[1]] <- thres[1]
        input$value[input$value > thres[2]] <- thres[2]}
      
      # 开始画图
      
      input$col <- cut(input$value, 16, labels = c(1:16))
      input$col <- as.numeric(input$col)
      
      ggplot(input, aes(x = row_ind, y = col_ind, shape = 'a'))+ 
        geom_point(aes(size = 1, color = col)) +
        scale_shape_manual(values = c(15))+
        scale_colour_gradientn(colors = col)+
        theme_void() + ggtitle(i) + 
        theme(plot.title = element_text(size = 30))
    })
    
    plot_grid(plotlist = allplots, ncol = ncol)
  }
}


# feature可视化 ====================

spatial_feature <- function(dataspat = dataspat,
                            select = select,
                            outlier.rm = T,
                            ncol = 3) {
  library(Seurat)
  library(SeuratData)
  library(dplyr)
  library(ggplot2)
  library(cowplot)
  library(patchwork)
  
  
  # 处理坐标数据 ----------
  
  coord <- as.data.frame(dataspat@images$slice1@coordinates)[c(3,2)]
  coord[,2] <- (-coord[,2])
  
  names(coord) <- c("row_ind", "col_ind")
  coord <- arrange(coord, col_ind, row_ind)
  
  
  # 处理注释数据 ----------
  
  select = intersect(select, colnames(info))
  info <- dataspat@meta.data[rownames(coord),]
  data <- info[,select]
  
  # 设定颜色
  
  col <- c(colorRampPalette(c("#343391","#0064af","#0090cc","#00b6db","#01b7c2",
                              "#53c0a3","#8dcb8a","#bbd967","#fbd324","#f6bd25",
                              "#f4a02e","#ed6f32","#ea5c2e","#d5452f","#c02e2f",
                              "#8b2a21"))(100))
  
  # 针对输入基因不同的情况
  
  if (length(select) == 1) {
    
    input <- coord
    input$value <- data
    
    if (outlier.rm == T) {
      thres <- quantile(input$value, probs = c(0.01, 0.99))
      input$value[input$value < thres[1]] <- thres[1]
      input$value[input$value > thres[2]] <- thres[2]}
    
    # 开始画图
    
    ggplot(input, aes(x = row_ind, y = col_ind, shape = 'a'))+ 
      geom_point(aes(size = 1, color = value)) +
      scale_shape_manual(values = c(15))+
      scale_colour_gradientn(colors = col)+
      theme_void()
    
  } else {
    
    allplots <- lapply(select, function(i){
      
      input <- coord
      input$value <- data[,i]
      
      if (outlier.rm == T) {
        thres <- quantile(input$value, probs = c(0.01, 0.99))
        input$value[input$value < thres[1]] <- thres[1]
        input$value[input$value > thres[2]] <- thres[2]}
      
      # 开始画图
      
      ggplot(input, aes(x = row_ind, y = col_ind, shape = 'a'))+ 
        geom_point(aes(size = 1, color = value)) +
        scale_shape_manual(values = c(15))+
        scale_colour_gradientn(colors = col)+
        theme_void() + ggtitle(i) + 
        theme(plot.title = element_text(size = 30))
    })
    
    plot_grid(plotlist = allplots, ncol = ncol)
  }
  
}


# dimplot可视化 ====================

spatial_dimplot <- function(dataspat = dataspat,
                            select = select,
                            color = "continuous") {
  library(Seurat)
  library(SeuratData)
  library(dplyr)
  library(ggplot2)
  library(cowplot)
  library(patchwork)
  
  # 处理坐标数据 ----------
  
  coord <- as.data.frame(dataspat@images$slice1@coordinates)[c(3,2)]
  coord[,2] <- (-coord[,2])
  
  names(coord) <- c("row_ind", "col_ind")
  coord <- arrange(coord, col_ind, row_ind)
  
  
  # 处理注释数据 ----------
  
  select = intersect(select, colnames(info))
  info <- dataspat@meta.data[rownames(coord),]
  data <- info[,select]
  
  input <- coord
  input$type <- data
  
  
  # 处理颜色 ----------
  
  if (length(color) == 1) {
    if (color == "discrete") {
      col <- c("#A6D719", "#176EBF", "#00A8DE",
               "#AEE0E8", "#00A9A3", "#FBD324",
               "#F28A24", "#A52828", "#A37CB7")
      
    } else if (color == "continuous") {
      col <- c("#f3bd2e","#e2720f","#e02f2c",
               "#861b20","#b51b7f","#7f137f","#622183")
      col <- colorRampPalette(col)(length(unique(input$type)))
    }
  } else {
    col <- color
  }
  
  
  # 开始画图 ----------
  
  ggplot(input, aes(x = row_ind, y = col_ind, shape = 'a'))+ 
    geom_point(aes(size = 1, color = type)) +
    scale_shape_manual(values = c(15))+
    scale_colour_manual(values = col)+
    theme_void()
}


# 空转距离计算 ====================

spot_distance <- function(dataspat = dataspat,
                          select1 = select1,
                          select2 = select2) {
  
  # 500 * 3000的运行时间是15分钟
  
  library(Seurat)
  library(SeuratData)
  library(reshape2)
  
  # 处理坐标数据
  
  coord <- as.data.frame(dataspat@images$slice1@coordinates)[c(3,2)]
  coord[,2] <- (-coord[,2])
  
  names(coord) <- c("row_ind", "col_ind")
  coord <- arrange(coord, col_ind, row_ind)
  
  # 计算距离
  
  alldist <- do.call(rbind, lapply(select1, function(i){
    dist <- do.call(rbind, lapply(select2, function(j){
      input <- coord[c(i,j),]
      dist <- sqrt((input[1,1] - input[2,1]) ^ 2  + (input[1,2] - input[2,2]) ^ 2)
      data.frame(id1 = i, id2 = j, dist = dist)
    }))
  }))
  
  # 整理数据
  
  alldist <- reshape2::acast(alldist, id1 ~ id2, value.var = "dist",
                             fun.aggregate = mean, na.rm = TRUE)
  
  data.frame(alldist, check.names = F)
}



# BayesPrism 分析 ==============================================================
# ==============================================================================

# 准备参考数据集 ====================

# 数据集中新增state一列

bayesprism_reference <- function(datafilt = datafilt,
                                 cluster = "celltype_sig2") {
  library(Seurat)
  
  # 自动聚类函数 ----------
  
  autocluster <- function(datafilt, nfeatures = 1000, ndim = 15,
                          neigh = 20, dist = 0.5, res = 0.5){
    
    datafilt <- NormalizeData(datafilt, scale.factor = 10000,
                              normalization.method = "LogNormalize")
    
    datafilt <- FindVariableFeatures(datafilt, nfeatures = nfeatures, 
                                     selection.method = "vst")
    
    datafilt <- ScaleData(datafilt, features = VariableFeatures(datafilt))
    datafilt <- RunPCA(datafilt, assay = 'RNA', slot = 'scale.data')
    
    datafilt <- FindNeighbors(datafilt, k.param = neigh,
                              dims = 1:ndim, reduction = "pca")
    
    datafilt <- FindClusters(datafilt, resolution = res, n.iter = 50)
    return(datafilt)
  }
  
  # 排除低数量细胞 ----------
  
  info <- datafilt@meta.data
  number <- data.frame(table(info[,cluster]))
  stateid <- number$Var1[number$Freq > 100]
  cellid <- rownames(info)[info[,cluster] %in% stateid]
  
  datafilt <- datafilt[,cellid]
  info <- info[cellid,]
  
  # 进行聚类 ----------
  
  cellstate <- lapply(stateid, function(i){
    
    subfilt <- datafilt[,info[,cluster] %in% i]
    subfilt <- autocluster(subfilt, nfeatures = 2000,
                           ndim = 15, neigh = 20,
                           dist = 0.5, res = 0.1)
    
    subfilt$state <- paste0(i, "_", subfilt$seurat_clusters)
    subfilt
  })
  
  # 整合结果 ----------
  
  datafilt <- cellstate[[1]]
  for (i in 2:length(cellstate)) {
    data <- cellstate[[i]]
    datafilt <- merge(datafilt, data)
  }
  
  datafilt
}


# 进行bayesprism分析 ====================

bayesprism_analysis <- function(scdata = scdata,
                                bkdata = bkdata,
                                celltype = celltype,
                                cellstate = cellstate,
                                ncores = ncores) {
  library(Seurat)
  library(BayesPrism)
  
  # bulk数据处理 ----------
  
  bkdata <- t(bkdata)
  
  # 排除NA值
  
  if (any(is.na(bkdata)) == TRUE) {
    library(impute)
    bkdata <- t(bkdata)
    bkdata <- bkdata[rowSums(is.na(bkdata))<0.5*ncol(bkdata),]
    bkdata <- impute.knn(bkdata) # genes in the rows, samples in the columns
    bkdata <- t(bkdata$data)
  }
  
  # 检查log2转换情况
  
  if(max(bkdata) < 20) {
    bkdata <- 2 ^ (bkdata) - 1}
  
  # 单细胞数据处理 ----------
  
  info <- scdata@meta.data
  cell.type.labels <- info[,celltype]
  cell.state.labels <- info[,cellstate]
  
  scdata <- as.matrix(GetAssayData(scdata, slot = "data", assay = "RNA"))
  scdata <- t(exp(scdata)-1)
  
  scdata_filt <- cleanup.genes(input = scdata,
                               input.type = "count.matrix",
                               species = "hs", exp.cells = 5,
                               gene.group = c("other_Rb","chrM","chrX",
                                              "chrY","Rb","Mrp","act",
                                              "hb","MALAT1"))
  # 生成BayesPrism对象 ----------
  
  myPrism <- new.prism(reference = scdata_filt, 
                       mixture = bkdata,
                       input.type = "count.matrix", 
                       cell.type.labels = cell.type.labels, 
                       cell.state.labels = cell.state.labels,
                       key = "tumor",
                       outlier.cut = 0.01,
                       outlier.fraction = 0.1)
  
  # 开始运行 ----------
  
  run.prism(prism = myPrism,
            n.cores = ncores)
}



# bulk 免疫浸润分析 ============================================================

# TCGA差异浸润分析 ====================

immune_content_difftcga <- function(data = data,
                                    info = info,
                                    source = path,
                                    geneset = "TCIA",
                                    select = "PVR",
                                    thres = 0.75) {
  library(GSVA)
  library(reshape2)
  library(future.apply)
  library(limma)
  library(metaMA)
  library(metap)
  library(statmod)
  library(tibble)
  library(viper)
  library(tibble)
  
  # 读入函数1 ----------
  
  immune_scores <- function(data = data,
                            source = path,
                            geneset = "allsets",
                            method = "ssgsea") {
    load(source)
    sig_list <- immune_genesets[[geneset]]
    
    # 开始计算分数
    
    if (method == "bisque") {
      
      library(BisqueRNA)
      library(Biobase)
      
      sig_list <- reshape2::melt(sig_list)
      sig_list <- data.frame(gene = sig_list$value,
                             cluster = sig_list$L1,
                             logfc = 1)
      
      common <- intersect(sig_list$gene, rownames(data))
      sig_list <- sig_list[sig_list$gene %in% common,]
      
      # 过滤基因数小于5的基因集
      
      number <- data.frame(table(sig_list$cluster))
      sig_list <- sig_list[sig_list$cluster %in% number$Var1[number$Freq > 5],]
      
      # 开始计算
      
      data <- as.matrix(data)
      input <- ExpressionSet(assayData = data)
      scores <- MarkerBasedDecomposition(input, sig_list,
                                         ct_col = "cluster",
                                         gene_col = "gene",
                                         w_col = "logfc",
                                         weighted = T,
                                         unique_markers = F,
                                         verbose = TRUE)
      scores <- scores$bulk.props
      
    } else {
      
      data <- as.matrix(data)
      scores <- gsva(data, sig_list, 
                     min.sz = 2, max.sz = 500, 
                     method = method, parallel.sz = 16,
                     verbose = TRUE)
    }
  }
  
  # 读入函数2 ----------
  
  limma_betweenAb <- function(data = data,
                              info = info,
                              thres = 0.9) {
    data <- t(as.matrix(data))
    info <- data.frame(info)
    
    # 二分类化分组变量
    
    info$type <- "M"
    info$type[info$value > quantile(info$value, probs = thres)] <- "H"
    info$type[info$value < quantile(info$value, probs = 1 - thres)] <- "L"
    info <- info[info$type != "M",]; info <- info[,-2]
    
    # 定义差异分析函数
    
    difflimma <- function(data = data,
                          info = info,
                          group1 = "R",
                          group2 = "NR",
                          filter = FALSE) {
      
      # 默认情况都是group1 - group2
      
      library(limma)
      library(metaMA)
      library(statmod)
      
      # 初步筛选基因
      
      if (filter == TRUE) {
        data <- data[rowMeans(data)>0,]
      }
      
      # 确保排序一致
      
      common <- intersect(colnames(data), info$id)
      info <- info[info$id %in% common,]
      data <- data[,info$id]
      data <- as.matrix(data)
      
      # 构建矩阵
      
      grade <- factor(info[,2], levels = c(group2, group1))
      design <- model.matrix(~0 + grade)
      
      rownames(design) <- info$id
      colnames(design) <- gsub(pattern = "grade", replacement = "",
                               x = colnames(design))
      # 对比矩阵
      
      cont.matrix <- as.matrix(c(-1, 1))
      rownames(cont.matrix) <- c(group2, group1)
      colnames(cont.matrix) <- paste0(group1, " - ", group2)
      
      # 线性拟合
      
      fit <- lmFit(data, design)
      fit <- contrasts.fit(fit, cont.matrix)
      fit <- eBayes(fit, trend = TRUE, robust = TRUE)
      
      # 得到差异基因
      
      diff <- topTable(fit, adjust = 'fdr',
                       coef = 1, n = Inf)
      
      diff <- data.frame(id = rownames(diff),
                         logfc = diff$logFC,
                         t = diff$t,
                         pvalue = diff$P.Value,
                         FDR = diff$adj.P.Val)
      
      # 得到分组平均值
      
      group_mean <- do.call(rbind, lapply(1:nrow(data), function(i){
        
        input <- data.frame(id = colnames(data), value = data[i,])
        input <- merge(input, info, by = "id")
        input <- na.omit(input)
        
        cohen <- (mean(input$value[input$type == group1]) - 
                    mean(input$value[input$type == group2])) / sd(input$value)
        
        data.frame(id = rownames(data)[i],
                   mean_G1 = mean(input$value[input$type == group1]),
                   mean_G2 = mean(input$value[input$type == group2]),
                   cohen = cohen)
      }))
      
      colnames(group_mean)[2:3] <- c(group1, group2)
      
      # 整合平均值结果
      
      diff <- merge(group_mean, diff, by = "id")
      
      # 得到moderated effect size
      
      es <- effectsize(fit$t, nrow(info),
                       (fit$df.prior + fit$df.residual))
      
      es <- data.frame(es = es[,"dprime"],
                       es_var = es[,"vardprime"])
      # 结果总结
      
      es <- es[diff$id,]
      es <- cbind(diff, es)
      rownames(es) <- NULL
      es
    }
    
    # 开始计算
    
    difflimma(data, info,
              group1 = "H",
              group2 = "L")
  }
  
  
  # 基因与免疫浸润相关性 ----------
  
  alldiff <- lapply(unique(info$type), function(i){
    
    # 输入数据预处理
    
    subdata <- data[,rownames(info)[info$type == i]]
    
    # 免疫浸润评估
    
    scores <- immune_scores(data = subdata,
                            source = source,
                            geneset = geneset,
                            method = "ssgsea")
    scores <- t(scores)
    
    # 开始差异分析
    
    if (select %in% rownames(subdata)) {
      info <- data.frame(id = colnames(subdata), value = subdata[select,])
      diff <- limma_betweenAb(data = scores, info = info, thres = thres)
      diff$cohort <- i
      diff
    } else {NA}
    
  })
  
  alldiff <- alldiff[!is.na(alldiff)]
  alldiff <- do.call(rbind, alldiff)
  alldiff
}


# 展示logfc和pvalue的热图 ====================

heatmap_logfc_pvalue <- function(logfc = logfc,
                                 pvalue = pvalue,
                                 thres = thres,
                                 cluster.row = TRUE,
                                 cluster.col = TRUE,
                                 border = TRUE) {
  library(pheatmap)
  library(ComplexHeatmap)
  
  # 确保排序一致
  
  common_row <- intersect(rownames(logfc), rownames(pvalue))
  common_col <- intersect(colnames(logfc), colnames(pvalue))
  
  logfc <- logfc[common_row, common_col]
  pvalue <- pvalue[common_row, common_col]
  
  # 设定阈值
  
  if (is.null(thres)) {
    all_value <- reshape2::melt(logfc)
    thres_h <- quantile(all_value$value[all_value$value > 0], probs = c(0.33, 0.67))
    thres_l <- quantile(all_value$value[all_value$value < 0], probs = c(0.33, 0.67))
  }
  
  # 对logfc进行分类
  
  if(is.null(thres)) {
    
    logfc_b <- apply(logfc, 2, function(x){
      cut(x, breaks = c(-Inf, thres_l[1], thres_l[2], thres_h[1], thres_h[2], Inf),
          labels = c("< low_2", "low_2 - low_1",
                     "low_1 - high_1", "high_1 - high_2", "> high_2"))})
    
    rownames(logfc_b) <- rownames(logfc)
    
  } else {
    
    logfc_b <- apply(logfc, 2, function(x){
      cut(x, breaks = c(-Inf, thres, Inf),
          labels = c("< low_2", "low_2 - low_1",
                     "low_1 - high_1", "high_1 - high_2", "> high_2"))})
    
    rownames(logfc_b) <- rownames(logfc)
    
  }
  
  # 标记 P > 0.05
  
  logfc_b[pvalue >= 0.05] <- "P >= 0.05"
  
  # 每个分类定义一个颜色
  
  col_cat <- c("> high_2" = "#A80C3A",
               "high_1 - high_2" = "#ED5E57",
               "low_1 - high_1" = "#DDD3D2",
               "low_2 - low_1" = "#6B9AB7",
               "< low_2" = "#2F5B89",
               "P >= 0.05" = "white")
  
  # 设定字体颜色
  
  if(is.null(thres)) {
    cutoff <- min(abs(thres_l[2]), thres_h[1])
  } else {
    cutoff <- min(abs(thres[2]), thres[3])
  }
  
  cell_fun <- function(logfc, dataP, logfcCutoff = cutoff, PCutoff = 0.05, 
                       darkcol = "black", lightcol = "white", digit = 2, fontsize  = 6){
    function(j, i, x, y, width, height, fill){
      if(abs(logfc[i,j]) > logfcCutoff & dataP[i,j] < PCutoff){
        grid.text(round(logfc, digit)[i, j], x, y, 
                  gp = gpar(fontsize = fontsize, col  = lightcol))
      }else{
        grid.text(round(logfc, digit)[i, j], x, y, 
                  gp = gpar(fontsize = fontsize, col  = darkcol))
      }
    }
  }
  
  # 对热图进行聚类
  
  pheatmap <- pheatmap::pheatmap(logfc,
                                 cluster_rows = cluster.row,
                                 cluster_cols = cluster.col)
  
  if (cluster.row == TRUE & cluster.col == TRUE) {
    logfc <- logfc[pheatmap$tree_row$order,pheatmap$tree_col$order]
    logfc_b <- logfc_b[pheatmap$tree_row$order,pheatmap$tree_col$order]
    pvalue <- pvalue[pheatmap$tree_row$order,pheatmap$tree_col$order]
    
  } else if (cluster.row == TRUE & cluster.col == FALSE) {
    logfc <- logfc[pheatmap$tree_row$order,]
    logfc_b <- logfc_b[pheatmap$tree_row$order,]
    pvalue <- pvalue[pheatmap$tree_row$order,]
    
  } else if (cluster.row == FALSE & cluster.col == TRUE) {
    logfc <- logfc[,pheatmap$tree_col$order]
    logfc_b <- logfc_b[,pheatmap$tree_col$order]
    pvalue <- pvalue[,pheatmap$tree_col$order]
  }
  
  # 开始画图
  
  if (border == TRUE) {
    
    Heatmap(matrix = logfc_b, 
            name = "logFC", 
            rect_gp = gpar(col = "black", lwd = 0.5), 
            col = col_cat, 
            row_names_side = "left", 
            cell_fun = cell_fun(logfc, pvalue),
            cluster_rows = T, show_row_dend = F,
            cluster_columns = T, show_column_dend = F,
            row_names_gp = gpar(fontsize = 8), 
            column_names_gp = gpar(fontsize = 8), 
            column_names_rot = 45,
            border = "black")
    
  } else {
    
    Heatmap(matrix = logfc_b, 
            name = "logFC", 
            rect_gp = gpar(col = "NA", lwd = 1), 
            col = col_cat, 
            row_names_side = "left", 
            cell_fun = cell_fun(logfc, pvalue),
            cluster_rows = T, show_row_dend = F,
            cluster_columns = T, show_column_dend = F,
            row_names_gp = gpar(fontsize = 8), 
            column_names_gp = gpar(fontsize = 8), 
            column_names_rot = 45)
  }
}


# TCGA pancan生存分析 - 森林图 ====================

pancan_survival_forest <- function(data = data,
                                   info = info,
                                   select = select) {
  library(survival)
  library(ggplot2)
  library(tibble)
  library(forcats)
  
  # 整理表达数据
  
  data <- as.matrix(data)
  score <- data[select,]
  score <- data.frame(id = names(score), score = score)
  
  # 处理注释信息
  
  info <- rownames_to_column(info, var = "id")
  input <- merge(score, info, by = "id")
  
  # 整合生存数据
  
  input <- data.frame(score = input$score,
                      type = input$type,
                      status = input$OS,
                      time = input$time)
  
  # 开始COX分析
  
  coxdata <- do.call(rbind, lapply(unique(input$type), function(i){
    subdata <- input[input$type == i,]
    
    cox <- coxph(Surv(time, status) ~ subdata[,1], subdata)
    cox <- summary(cox)
    
    data.frame(id = i, HR = cox$coefficients[,"exp(coef)"],
               pvalue = cox$coefficients[,"Pr(>|z|)"], 
               lower = cox$conf.int[,3], upper = cox$conf.int[,4])
  }))
  
  # 结果可视化 
  
  coxdata <- coxdata[order(coxdata$HR),]
  coxdata$id <- fct_inorder(coxdata$id)
  sigdata <- coxdata[coxdata$pvalue < 0.05,]
  
  ggplot(coxdata, aes(x = HR,y = id)) +
    geom_errorbarh(aes(xmax = upper, xmin = lower), height = 0,size = 0.5) + 
    geom_point(aes(x = HR, y = id, size = 5),
               color = "grey70", shape = 18) + 
    geom_point(data = sigdata, aes(x = HR, y = id, size = 5),
               color = "#0070b2", shape = 18) +
    geom_vline(xintercept = 1, linetype = 'dashed', size = 0.5) +
    scale_x_continuous(breaks = c(0.5, 1, 2, 3)) +
    coord_trans(x = 'log2') + 
    labs(x = 'HR', y= '',title = select) + 
    
    theme_bw() + 
    theme(legend.position = "none",
          panel.grid = element_blank(),
          axis.text = element_text(colour = "black", size = 12.5),
          axis.title = element_text(colour = "black", size = 12.5),
          panel.border = element_rect(fill = NA, color = "black", linewidth = 1))
}


# TCGA pancan生存分析 - 生存曲线 ====================

pancan_survival_curve <- function(data = data,
                                  info = info,
                                  select = select,
                                  group.by = "optimal") {
  library(survival)
  library(survminer)
  
  # 函数1 ----------
  
  survival_curve_gene <- function(input = input,
                                  select = select,
                                  group.by = "optimal",
                                  name = "cohort") {
    # 确定阈值
    
    if (group.by == "median") {
      
      thres <- median(input$value)
      input$type <- ifelse(input$value > thres, "H", "L")
      
    } else if (group.by == "quantile") {
      
      thres1 <- quantile(input$value, probs = c(0.75), na.rm = T)
      thres2 <- quantile(input$value, probs = c(0.25), na.rm = T)
      input$type <- NA
      input$type[input$value > thres1] <- "H"
      input$type[input$value < thres2] <- "L"
      input <- na.omit(input)
      
    } else if (group.by == "optimal") {
      
      thres <- surv_cutpoint(input, time = "time", minprop = 0.15,
                             event = "status", variables = "value")
      thres <- thres$cutpoint[[1]]
      input$type <- ifelse(input$value > thres, "H", "L")
      
    }
    
    # 计算p值
    
    my.surv <- Surv(input$time, input$status)
    data.survdiff <- survdiff(my.surv ~ input$type)
    p.val = 1 - pchisq(data.survdiff$chisq, length(data.survdiff$n) - 1)
    
    # 计算HR
    
    mycox <- coxph(Surv(time,status) ~ value, data = input)
    coxResult <- summary(mycox)
    
    HR = coxResult$coefficients[,"exp(coef)"]
    lower_95CI = coxResult$conf.int[,3]
    upper_95CI = coxResult$conf.int[,4]
    
    HR <- paste("Hazard Ratio = ", round(HR,2), sep = "")
    CI <- paste("95% CI: ", paste(round(lower_95CI, 2),
                                  round(upper_95CI, 2), sep = " - "), sep = "")
    
    # 基本信息
    
    number_H <- paste("number H = ", sum(input$type == "H"), sep = "")
    number_L <- paste("number L = ", sum(input$type == "L"), sep = "")
    cutoff <- paste("cutoff = ", round(thres, 3), sep = "")
    
    # 开始画图
    
    if (group.by != "quantile") {
      
      fit <- survfit(Surv(time, status) ~ type, data = input)
      ggsurvplot(fit, data = input, size = 1, palette = c("#f63a4e","#0089c1"), 
                 risk.table = F, conf.int = F,
                 conf.int.style = "step", ncensor.plot = FALSE, censor = F,
                 font.legend = 12, font.title = 12, font.x = 12, font.y = 12,
                 pval = paste(pval = ifelse(p.val < 0.001, "p < 0.001", 
                                            paste("P = ",round(p.val,3), sep = "")),
                              HR, CI, number_H, number_L, cutoff, sep = "\n"),
                 legend.title = name)
      
    } else {
      
      fit <- survfit(Surv(time, status) ~ type, data = input)
      ggsurvplot(fit, data = input, size = 1, palette = c("#f63a4e","#0089c1"), 
                 risk.table = F, conf.int = F,
                 conf.int.style = "step", ncensor.plot = FALSE, censor = F,
                 font.legend = 12, font.title = 12, font.x = 12, font.y = 12,
                 pval = paste(pval = ifelse(p.val < 0.001, "p < 0.001", 
                                            paste("P = ",round(p.val,3), sep = "")),
                              HR, CI, sep = "\n"),
                 legend.title = name)
    }
  }
  
  
  # 整理数据 ----------
  
  data <- as.matrix(data)
  score <- data[select,]
  score <- data.frame(id = names(score), score = score)
  
  # 处理注释信息
  
  info <- rownames_to_column(info, var = "id")
  input <- merge(score, info, by = "id")
  
  # 整合生存数据
  
  input <- data.frame(value = input$score,
                      type = input$type,
                      status = input$OS,
                      time = input$time)
  
  # 开始可视化 ----------
  
  all_plots <- lapply(unique(input$type), function(i){
    
    subinput <- input[input$type == i,]
    subinput <- data.frame(value = subinput$value,
                           time = subinput$time,
                           status = subinput$status)
    
    survival_curve_gene(subinput,
                        group.by = group.by,
                        name = i)
  })
}



# 筛选高变异基因 ===============================================================

FSbyVar<-function(Data, cut.type="topk", value)
{
  vars=apply(Data,1,var)
  feature_num=length(vars)
  hist(vars, breaks=feature_num*0.1, col="red",
       main="Expression (Variance) distribution",
       xlab="The Variance of feature")
  if(cut.type=="topk")
  {
    index= sort(vars,decreasing = TRUE,index.return=TRUE)
    if(value>nrow(Data))
    {
      value=nrow(Data)
      cat("Warning: the feature selection number is beyond the original feature numnber")
    }
    cutoff=index$x[value]
    abline(v=cutoff,col = "blue",lty = 5,lwd=1.5)
    index=index$ix[1:value]
    selectData=Data[index,]
  }
  if(cut.type=="cutoff")
  {
    abline(v=value,col = "blue",lty = 5,lwd=1.5)
    index=which(vars>value)
    selectData=Data[index,]
  }
  selectData
}


